%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% @!@MDB
%%% -Simulink parameter 
%%% -Keine Torsionsfeder mehr im modell
%%% -Andere modellparameter- bezeichnungen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%set(0,'DefaultFigureRenderer','OpenGL')
%set(0,'DefaultFigureRendererMode', 'manual')
startup
optb=ol.optb;
optn=ol.optn;

delete(findall(0,'type','line'));

%SIMFILES={  'Galvo_sys_v20',...
%            'GalvoModel_v43'};
SIMFILES={  'Galvo_sys_cc_feed_v40',...
            'CurrentComp_v20',...
            'GalvoModel_v53',...
            'Galvo_sys_Ccont_Pcont_cc_GUT_v63',...
            'Loop_detailed_model_v11_bipolar',...
            'Loop_detailed_model_comp_cc_vccc_v14_JAWOLL',...
            'Galvo_sys_Cdisc_Pcont_ccvc_FET_SUB_REF_v65',...
            'Galvo_sys_Cdisc_Pcont_cc_nosub_GUT_v63_quantizizer'};
        
% *********************************************************************
%               Init block models
% *********************************************************************
param = loadGalvoParam(5,'eval');
paramCtrl = loadCtrlParam(5);
%evalGalvoParam(4);
	

%init = 0;
%SEARCH = {'Kp_cc'};
%VAL = 1;
%Kp_cc = 1;

%load_system(SIMFILES{end});
%set_param(  [SIMFILES{1} '/GalvoModel'],'OverrideUsingVariant',SIMFILES{2});
%set_param(SIMFILES{1}, 'AbsTol', '1e-5','MaxStep','1e-4');
%set_param(SIMFILES{2}, 'AbsTol', 'auto');
%sim(SIMFILES{1});
Aw=0.6;
FB_EN=1;
FS=50e-6;
%open_system(SIMFILES{end});

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Blocknachbau aus 
% endstufe_BJT_EMIT_MJ1101xG_ltc6090_compare_currentMirror_nur_ein_hv_FERTIG.asc
% Sensitivität, komplementäre 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Lc=170e-6; Rc=1.5; Rsh=0.003;
Vu1=-10/3; Vu2=20;

s = tf('s');
Cs = pid(-10,0,0);
As = 0.925;
Ps = 1/(s*Lc+Rc+Rsh);
Fs = 1;
Hs = Rsh*Vu1*Vu2*Fs;

G0 = Cs*As*Ps*Fs*Hs;

Ts = G0/(1+G0);
Ss = 1/(1+G0);
Gm = -G0/(1+G0);

bodeplot(Ts, Ss, G0, tf(1), optb);
legend('Ts','Ss','G0')


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Stromregler als eigener Regelkreis 
% Sensitivität, komplementäre 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Exact linearization of the Simulink model Galvo_sys_Cdisc_Pcont_ccvc_FET_SUB_REF_v66
%
% This MATLAB script is the command line equivalent of the exact
% linearization tab in linear analysis tool with current settings.
% It produces the exact same linearization results as hitting the Linearize button.

% MATLAB(R) file generated by MATLAB(R) 8.1 and Simulink Control Design (TM) 3.7.
%
% Generated on: 09-Oct-2014 01:04:46

model = 'Galvo_sys_Cdisc_Pcont_ccvc_FET_SUB_REF_v66';
model = 'Galvo_sys_Ccont_Pcont_cc_nosub_bandwidth_v68'
model = 'Galvo_sys_Ccont_Pcont_cc_nosub_bandwidth_AbsTolProb_v68'

factor='Galvo_sys_Cdisc_Pcont_ccvc_FET_SUB_REF_v66/factor';
factor='Galvo_sys_Cdisc_Pcont_ccvc_FET_SUB_REF_v66/deg2rad3';
factor = [model '/PosDemod'];

model = gcs;
factor=[];

types={'compsensitivity', 'sensitivity', 'looptransfer'};
clear sys sysG;

set_param(factor,'Gain','180/pi');
set_param(factor,'Gain','1');

%sysG=repmat( {''},1,3);
for m=1:1
    for j=1:length(types)
        io = getlinio(model);
        if isempty(io)
            warning('output argument of getlinio command is empty, please select a block/portnumber')
            blocks = find_system(model,'Type','Block')
            iotmp = linio([model '/M(s)'], 1, types{1});
            setlinio(model, iotmp);
            set_param(model,'ShowLinearizationAnnotations','on');
            return
        end
        io.Type = types{j};
        fprintf('m=%i,j=%i: %s\n',m,j,io.Type);
        oldio = setlinio(model,io);
        op = operpoint(model);
        sysG{m,j} = linearize(model,io);
        [nu de] = tfdata(sysG{m,j});
        sysG{m,j} = tf(nu(:),de(:))
    end
    if ~isempty(factor)
        set_param(factor,'Gain',num2str(1*str2num(get_param(factor,'Gain'))));
    end
end


f8=figure(8);
cla;
hold on;
nyquist(sysG{1,1},optn);
nyquist(sysG{1,2},optn);
nyquist(sysG{1,3},optn);
hold off;

%%
f7=figure(7);
cla;
SUB=120;
subplot(SUB+1);
hold all;
for k=1:3
    bodeplot(sysG{1,k});
end
hold off;
legend(types);

subplot(SUB+2);
hold all;
for k=1:3
    bodeplot(sysG{2,k});
end
hold off;
legend(types);

%%
FILES={'Galvo_sys_Cdisc_Pcont_ccvc_FET_SUB_REF_v66'};
closeFb=0;
%%
closeFb=1;
s2=linmod(FILES{1});
CcClose=linmodPost(s2,'wexp','icexp');

closeFb=0;
s2=linmod(FILES{1});
CcOpen=linmodPost(s2,'wexp','icexp');

% Plot step response for open and closed loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
f8=figure(8);
cla;
SUB=220;
hold all;
step(CcClose)
step(CcOpen)
hold off;
grid on;
legend('Ic')
%%
% linearize loop gain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
closeFb=0;
sG0=linmod(FILES{1});
G0=linmodPost(sG0,'G0u','G0y');

closeFb=1;
sGt=linmod(FILES{1});
Gt=linmodPost(sGt,'G0u','G0y');

f9=figure(9);
cla;
SUB=220;
hold all;
bodeplot(G0,optb)
bodeplot(Gt,optb)
bodeplot(feedback(G0,1),optb)
hold off;
legend('G0','Gt','feedback(G0,1)')
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ableitung für Ic aus logsout berechnen (Änderungsgeschw. Spulenstrom)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear Uc_set Ic
Uc_set(:,1)=logsout.getElement('Uc_set').Values.Time;
Uc_set(:,2)=logsout.getElement('Uc_set').Values.Data;
Ic(:,1)=logsout.getElement('Ic').Values.Time;
Ic(:,2)=logsout.getElement('Ic').Values.Data;

f33=figure(33);
cla;
SUB=220;
subplot(SUB+1);
hold all;
plot(Ic(:,1), Ic(:,2))
plot(Ic(:,1), diff(Ic(:,2))/diff(Ic(2:3,1)))
hold off;
grid on;
legend('Ic','dIc')

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Entwurf Antialias- Filter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fs        Abtastrate ADC
% fpass     Passband, Durchlassbereich des analogen Filters
% fstop     Stopband, Sperrbereich...
% N         Filterordnung ...
% DR        Dynamic range, theoretischer Dynamikbereich des ADCs
%
%           DR := max. zu Verarbeitende Signalamplitude 
%                --------------------------------------- 
%                 min. zu Verarbeitende Signalamplitude 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear fs DR fpass fstop N
fs = [20e3:10:200e3];
fs2 = [20e3:10e3:200e3];
length(fs);

fpass = 3.75e3;                 % passband, Bandbreite closed loop
res=[12 11 10];

str=[];
for k=1:3
    DR = 20*log10(2^res(k) / 1);        % DR bei voller Ausnutzung 12Bit ADC
    N(k,:) = DR./(20*log10(0.5*fs/fpass));
    N2(k,:) = DR./(20*log10(0.5*fs2/fpass));
    str=[str sprintf('DR=%.2g dB:',DR)];
end
    
f1 = figure(1);
delete(findall(0,'type','line'))
hold on;
plot(fs*1e-3,N);
plot(fs2*1e-3,N2,'o');
hold off;
xlabel('Sample frequency fs/kHz');
ylabel('Filter order');
title(sprintf('N(fs) - Dynamic range DR=%.2g dB\npassband fpass=%.3g kHz',DR,fpass))
legend(strsplit(str,':'))
grid on;

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Use Linmod inside subsystem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
FILE={'Test3',...
    'Galvo_sys_Cdisc_Pcont_ccvc_FET_SUB_REF_v66'};
%set_param([FILE{1} '/current ctrl S'],'commented','off');

%s1=linmodHighLevel(FILE{1},struct,'dlin');
%%
if 0
    inpInd=find(~cellfun(@isempty, strfind(s1.tf.InputName,'EXP')));
    outpInd=find(~cellfun(@isempty, strfind(s1.tf.OutputName,'EXP')));
    sys=s1.tf(outpInd, inpInd)

    sys.InputName = strrep(sys.InputName,'EXP','');
    sys.OutputName = strrep(sys.OutputName,'EXP','');
else
%    sys=s1.tf;  
SYSTEM=FILE{1}
S.linmod=linmod(SYSTEM);    
S.linmod.filename = SYSTEM;
uu = strrep(S.linmod.InputName, [S.linmod.filename '/'], '');
yy = strrep(S.linmod.OutputName, [S.linmod.filename '/'], '');
S.linmod.InputName = uu;
S.linmod.OutputName = yy;

S.ss = ss(S.linmod.a, S.linmod.b, S.linmod.c, S.linmod.d, 'u', uu,'y',yy);
[nu de]=tfdata(S.ss);
S.tf = tf(nu, de, 'u', uu,'y',yy);
[zs ps ks]=zpkdata(S.ss);
S.zpk = zpk(zs, ps, ks, 'u', uu,'y',yy);
end

% outA_2_opv
te=tf([-0.768  2.66e+08],[ 1  2.67e+08]);


Ccc=pid(3.5,0,0)
Gn=te*tf(1,[Lc Rc+Rsh]);
Gh=Rsh*25*tf(1,[1e-9 1]);


f1=figure(1);
cla;
hold all;
% bodeplot(S.tf(1,2), optb)
% bodeplot(S.tf(2,2), optb)
bodeplot(S.tf, optb)
bodeplot(feedback(Ccc*Gn,Gh), optb)
%bodeplot(feedback(sys(1,2),1), optb)
%bodeplot(feedback(sys(2,2),1), optb)
hold off;
%legend(sys.OutputName)
xlim([0.1, 1e6])
%%set_param([FILE{1} '/current ctrl S'],'commented','on');
%%save_system(FILE{1});
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DAC smoothing filters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Sallen Key topology:
% 
%                              || C1 
%                   -----------||------------------
%                   |          ||                  | 
%           ____    |    ____             |\       |
%   Ue ----|_R1_|---+---|_R2_|---+--------|+ \     |
%                                |        |    \___+____ Ua
%                              __|__      |    /   |
%                           C2 -----   +--|- /     |
%                                |     |  |/       |
%                               _|_    |           |
%                                      -------------
%
% Gs=Ua/Ue
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%------------------------------------------------------------------
% Design vom 03-10-2014
%------------------------------------------------------------------
stage={ {'R1=5.6e3', 'R2=6.8e3', 'C1=20e-9', 'C2=10e-9'};...
        {'R1=680', 'R2=1e3', 'C1=360e-9', 'C2=10e-9'} };
%------------------------------------------------------------------

s=tf('s');
cellfun(@evalc, stage{1},'UniformOutput',false);
Gs1=( 1/(R1*C1*R2*C2) )/(s^2+s*(1/(R2*C1)+1/(R1*C1))+1/(R1*C1*R2*C2) );

cellfun(@evalc, stage{2},'UniformOutput',false);
Gs2=( 1/(R1*C1*R2*C2) )/(s^2+s*(1/(R2*C1)+1/(R1*C1))+1/(R1*C1*R2*C2) );

Gs=Gs1*Gs2;

f1=figure(1);
cla;
subplot(121);
bodeplot(Gs,optb);
subplot(122);
step(Gs);
grid on;
tf2spiceLaplace(Gs);
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FFT auf ADin und ADout anwenden 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
FILE = {'Galvo_sys_Cdisc_Pcont_ccvc_FET_SUB_REF_v66'};
paramNameValStruct.SimulationMode = 'normal';
paramNameValStruct.AbsTol         = '1e-5';
paramNameValStruct.SaveState      = 'on';
paramNameValStruct.SaveOutput     = 'on';
paramNameValStruct.StateSaveName  = 'states';
paramNameValStruct.OutputSaveName = 'dat';

%set_param([FILE{1} '/current ctrl'],'OverrideUsingVariant','Ccc_old_pwr');
% for k=1:length(blk2log)
%     set_param(ph.cc_no_vc.(fields{k}).Outport(1),'DataLogging','off')
%     set_param(ph.cc_old_pwr.(fields{k}).Outport(1),'DataLogging','on')
% end
simOut{1,:} = sim(FILE{1},paramNameValStruct);
logsout1 = simOut{1,:}.get('logsout');
% t1 = logsout1.getElement('ADin').Values.Time;
% ADin = logsout1.getElement('ADin').Values.Data;
% ADout = logsout1.getElement('ADout').Values.Data;
t1 = logsout1.getElement('Uc_set').Values.Time;
Uc_set = logsout1.getElement('Uc_set').Values.Data;
Uset_STAR = logsout1.getElement('Uset*').Values.Data;
Uset = logsout1.getElement('Uset').Values.Data;

f1 = figure(1);
stem(t1,Uc_set)
stem(t1,Uset)

%%
f1 = figure(1);
f2 = figure(2);
f3 = figure(3);
doFFT(Uc_set, t1, f1)
doFFT(Uset_STAR, t1, f2)
doFFT(Uset, t1, f3)
%%
Fs=10e3;
Ts=1/Fs;

tt=[0:Ts:5-Ts];
f0=100;

y1=sin(2*pi*f0*tt)
doFFT(y1, tt, f1)
quantize
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bandbreite closed loop 
%% Sensitivität S(s), inverse  T(s) 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% param = loadGalvoParam(4);
% paramCtrl = loadCtrlParam(4);
% evalGalvoParam(4);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% S(s) = Gw(s) = G0(s)/(1+G0(s));
% T(s) = Gz(s) = 1/(1+G0(s));
%        Gm(s) = -G0(s)/(1+G0(s));
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
run('kompl_kreis_linmod_sensitiv')


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ToDo nach zusammenlöten der ADC- DAC- Platine:  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
FILE = {'Galvo_sys_Cdisc_Pcont_ccvc_FET_v65'};

selSys = 1;
open_system(FILE(selSys));

%% 

%obd = find_system('type', 'block_diagram');
blk = find_system( FILE{selSys} ,'Type','Block');
ind = find(~cellfun(@isempty, strfind(blk, 'Gcc FET complement')));
%%



cc=struct;

estimCCmodel = 1;       % select cc for referenced model block
load_system( FILE{selSys} );
cc.ActiveVariant_1 = get_param(blk(ind),'ActiveVariant');
cc.ActiveModelFile_1 = get_param(blk(ind),'ModelFile');

estimCCmodel = 0;       % select cc for referenced model block
load_system( FILE{selSys} );
cc.ActiveVariant_0 = get_param(blk(ind),'ActiveVariant');
cc.ActiveModelFile_0 = get_param(blk(ind),'ModelFile');

cc.est = linmod('CurrentComp_LR_estimated_old_pwr_b10');
cc.noest = linmod('CurrentComp_v63_uset');
%%
cc.est.ss=ss(cc.est.a, cc.est.b, cc.est.c, cc.est.d);
cc.noest.ss=ss(cc.noest.a, cc.noest.b, cc.noest.c, cc.noest.d);





clear Gsys;
for selSys=1
    S = cc.est;
    S.filename = FILE{selSys};
    u_ = strrep(S.InputName, [S.filename '/'], '');
    y_ = strrep(S.OutputName, [S.filename '/'], '');
    S.InputName = u_;
    S.OutputName = y_;

    %GvCCa = ss(S.a, S.b, S.c, S.d, 'u', u_, 'y', y_);           % Kompletter Regelkreis 
    statespace = ss(S.a, S.b, S.c, S.d, 'u', u_, 'y', y_);           % Kompletter Regelkreis 

    if ((length(S.InputName) > 1) && (length(S.OutputName) > 1))
        sprintf('%s\n\tMIMO system\n%s',ds,ds)
    else
        if length(S.InputName) > 1
            sprintf('%s\n\tMISO system\n%s',ds,ds)
        else
            sprintf('%s\n\tSIMO system\n%s',ds,ds)
        end
    end

    [num, den] = tfdata(statespace);
    if exist('Gsys','var') > 0
        n = length(Gsys);
    else
        n = 1;
    end

    Gsys{n,1} = tf(num , den, 'u', u_, 'y', y_)
    Gsys{n,2} = FILE{selSys}
end


bodeplot(cc.est.ss, cc.noest.ss,optb)
% *********************************************************************    
% *********************************************************************    
% *********************************************************************    
% *********************************************************************    

%%  Nachweis dass Regelparameter aus simulink übernommen werden können
%   - est. tf der alten 12V endstufe
%   - Reglerbandbreit klein genug wegen sättigung der Endstufen- FET's
    FILES = {   'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_afterLoopEst.raw',...
                'aktuell/endstufe_FET_lochraster_KOB_fixes_26-09-2014_G0.raw',...
                'aktuell/endstufe_FET_lochraster_KOB_fixes_26-09-2014_Gtot_unitygain.raw',...
                'aktuell/endstufe_FET_lochraster_KOB_fixes_26-09-2014_G0_unitygain.raw',...
                'endstufe_BJT_EMIT_MJ1101xG_ltc6090_ada4700_compare_FERTIG.raw',...
                'cheby_DAC_lochraster_3khz.raw'};
    fSel = [3; 4];
    fSel = [4];
    
    clear fr fitsG0 ccG0
    
    sigName ='V(sumb)';
    sigName ='V(errB)';
    sigName ='V(out_a)';
    sigName ='I(Rshunt)';
    sigName ='V(Isensa2)';
%    sigName ='V(opv)';
%    sigName ='V(shunt)';
%    sigName ='V(isensb)';
    sigName ='V(smooth)';
    sigName ='V(out_a)';

    intVect = [0.1 1e6];
    pv = [[1 0];[1 1];[2 0];[2 1];[2 2];[3 0];[3 1];[3 2];[3 3];[4 0];[4 1];[4 2];[4 3];[4 4]];
    pSel = [length(pv)-5:length(pv)];
    pSel = [1:length(pv)-3];
    
%% creakte fieldnames from raw filenames    
    spl = strrep(FILES(fSel), {'.raw'},{'_DOT_raw'})        
    spl = cellfun(@strsplit, spl,[repmat({'_';},1,length(FILES(fSel)))], 'UniformOutput', false);

    size(FILES(fSel));
    for k=1:length(FILES(fSel))
        fieldnam{k} = sprintf('%s_',spl{1,k}{end-3:end})
        fr.(fieldnam{k}(1:end-1)) = estimationLoop(FILES{fSel(k)}, sigName, intVect, pv(pSel,:));
    end

    fr
    fr.G0_unitygain_DOT_raw.v_out_a

%*********************************************************************
%%    bestes fit- ergebniss raussuchen und speichern in sysEst
% *********************************************************************    
 
    fitsG0 = cellfun(@str2num, strrep(fr.G0_unitygain_DOT_raw.v_out_a(:,4) ,'%',''))/100;
    af = fields(fr.G0_unitygain_DOT_raw);
    
%     fitsGtot = cellfun(@str2num, strrep(fr.Gtot_unitygain_DOT_raw.v_out_a(:,4) ,'%',''))/100;
%    af = fields(fr.compare_FERTIG_DOT_raw);
%    fitsG0 = cellfun(@str2num, strrep(fr.compare_FERTIG_DOT_raw.(af{:})(:,4) ,'%',''))/100;
%    fitsGtot = cellfun(@str2num, strrep(fr.compare_FERTIG_DOT_raw.v_out_a(:,4) ,'%',''))/100;
    
    fns = fields(fr);
    [~, ind(1)] = max(fitsG0);
    ccG0.est   = fr.(fns{1}).(af{:})(ind(1),:);
    ccG0.est{1,1}.OutputName = ccG0.est(7);
    [nu den] = tfdata(ccG0.est{1,1});
    ccG0.tf = tf(nu, den, 'y',ccG0.est{1,1}.OutputName );
    
    if length(ind) > 1
        [~, ind(2)] = max(fitsGtot);
        ccGt.est = fr.(fns{2}).v_out_a(ind(2),:);
        ccGt.est{1,1}.OutputName = ccGt.est(7);
        [nu den] = tfdata(ccGt.est{1,1});
        ccGt.tf = tf(nu, den, 'y',ccGt.est{1,1}.OutputName );
    end
    
    ccG0.est
    ccG0.tf
    fprintf('numerator:    [%i  %i  %i]\n',ccG0.tf.num{1})
    fprintf('denominator:  [%i  %i  %i]\n',ccG0.tf.den{1})
    
% *********************************************************************    
% *********************************************************************    
% *********************************************************************    
% *********************************************************************    

%% get port handles to which the logging signals are connected
% *********************************************************************    

FILE = {'Galvo_sys_Cdisc_Pcont_ccvc_FET_SUB_REF_v65'};
%open_system(FILE{1});

% clear ph;
% 
% blk2log={'Cc(s)', 'Plant Actuator SAT' };
% fields = strrep(blk2log, {' '}, {'_'});
% fields = strrep(fields, {'('}, {'__'});
% fields = strrep(fields, {')'}, {''});
% 
% for k=1:length(blk2log)
%     ph.cc_old_pwr.(fields{k}) = get_param([FILE{1} '/current ctrl/cc_old_pwr/' blk2log{k}] ,'PortHandles');
%     ph.cc_no_vc.(fields{k}) = get_param([FILE{1} '/current ctrl/cc_no_vc/' blk2log{k}] ,'PortHandles');
% end
%%
Gzero=1;
for k=1:length(G)
    Gzero = Gzero*G{k}.tf;
end

f1 = figure(1);
cla;
bodeplot(G{1}.tf,G{2}.tf,G{3}.tf,G{4}.tf,G{5}.tf, optb); hold all
legend({G{1}.tf.OutputName{:},...
        G{2}.tf.OutputName{:},...
        G{3}.tf.OutputName{:},...
        G{4}.tf.OutputName{:},...
        G{5}.tf.OutputName{:}});
xlim([10e3, 10e6]);

f2 = figure(2);
cla
bodeplot(Gzero, optb); hold all;
legend('zero')
title('G0 durch multiplizieren von G{?}')
%%
f3 = figure(3);
cla;
bodeplot(feedback(G{1}.tf*G{2}.tf*G{3}.tf*G{4}.tf*G{5}.tf,1), optb); hold all
bodeplot(feedback(Gzero,1), optb)
xlim([10e3, 10e6]);

%%
ccG0opv_sum8
ccG0outA_opV
ccG0Vshunt_outA
ccG0IRshunt_outA
ccG0Visensa_outA

GA=ccG0opv_sum8.tf;
GB=ccG0Visensa_outA.tf;
GG=feedback(GA,GB)
GG2=feedback(GA*GB,1)

bodeplot(GG, optb); hold all;
bodeplot(GG2, optb); hold all;
legend({GG.OutputName{1}, GG2.OutputName{1}})

%%   Read logging data from model logging file
% *********************************************************************    

clear l simOut

paramNameValStruct.SimulationMode = 'normal';
paramNameValStruct.AbsTol         = '1e-5';
paramNameValStruct.SaveState      = 'on';
paramNameValStruct.SaveOutput     = 'on';
paramNameValStruct.StateSaveName  = 'states';
paramNameValStruct.OutputSaveName = 'dat';

set_param([FILE{1} '/current ctrl'],'OverrideUsingVariant','Ccc_old_pwr');
% for k=1:length(blk2log)
%     set_param(ph.cc_no_vc.(fields{k}).Outport(1),'DataLogging','off')
%     set_param(ph.cc_old_pwr.(fields{k}).Outport(1),'DataLogging','on')
% end
simOut{1,:} = sim(FILE{1},paramNameValStruct);


set_param([FILE{1} '/current ctrl'],'OverrideUsingVariant','Ccc_no_vc');
% for k=1:length(blk2log)
%     set_param(ph.cc_no_vc.(fields{k}).Outport(1),'DataLogging','on')
%     set_param(ph.cc_old_pwr.(fields{k}).Outport(1),'DataLogging','off')
% end
simOut{2,:} = sim(FILE{1},paramNameValStruct);

logsout1 = simOut{1,:}.get('logsout');
logsout2 = simOut{2,:}.get('logsout');

%%
% Vergleich FILE{1} mit unterschiedlichen subsystem Varianten 
% "Ccc_no_vc": Stromreglermodell ohne unterlagerten Spannungsregler 
% "Ccc_old_pwr": Stromreglermodell für die alte 12V Endstufe
% *********************************************************************  
f1=figure(1);

if exist('sx','var')
    delete(sx)
end
%STYLE = {'-r','--b'};
SUB = 220;

for k=1:4
    sx(k,:) = subplot(SUB+k);
    hold all;
    grid on;
end

el1=logsout1.getElementNames;
el2=logsout2.getElementNames;


for k=1:4
    subplot(sx(k));
    plot(logsout1.getElement(k).Values.Time',...
        logsout1.getElement(k).Values.Data') %,STYLE{1})
    plot(logsout2.getElement(k).Values.Time',...
        logsout2.getElement(k).Values.Data') %,STYLE{2})
    legend({el1{k}})
    hold off;
end

%%




f2=figure(2);
delete(findall(f2,'type','line'));
SUB = 210;

subplot(SUB+1);
hold all;
plot(simOut{1}.get('dat'))
grid on;
hold off;

subplot(SUB+2);
hold all;
plot(simOut{2}.get('dat'))
grid on;
hold off;

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   PID tune and plot
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     hch = get(0,'children');
%     tags = get(hch,'Tag');
%     ind(1) = find(~cellfun(@isempty, strfind( tags,'STEP')))
%     ind(2) = find(~cellfun(@isempty, strfind( tags,'BODEPLOT')))
%     ind(3) = find(~cellfun(@isempty, strfind( tags,'NYQUIST')))
    
    
    opts = pidtuneOptions('PhaseMargin',50);

    [Cp, info1] = pidtune(ccG0.tf,'P',opts);
    [Cpi, infoi1] = pidtune(ccG0.tf,'PI',opts);
    
%*********************************************************************
%%    some plots 
% *********************************************************************
    figs = findall(0,'type','Figure');
%    ind = find(figs > 10);
    delete(findall( figs(:),'type','line'));
%     
%     ps = pole([feedback(ccG0.tf,1); ccGt.tf; ccG0.tf])
%     Ts = 1./imag(ps)
% Cp = tf(1);
% Cpi = tf(1);
SYSV.G0         =   ccG0.tf;
SYSV.Gt_nogain  =   ccGt.tf;
SYSV.G0_fb      =   feedback(ccG0.tf,1);
SYSV.Cp_G0      =   Cp*ccG0.tf;
SYSV.Cpi_G0     =   Cpi*ccG0.tf;

fna = fieldnames(SYSV);

fh.step = figure(3);
hold all;


for k=1:length(fna)-1
    step(SYSV.(fna{k}));
end

hold off;
grid on;
legend(fna(1:end-1),'interpreter','none')
set(fh.step,'Position',[2470   210   560   420])


fh.bode = figure(4);
hold all;
for k=1:length(fna) -1
    bodeplot(SYSV.(fna{k}), optb);
end
hold off;
legend(fna(1:end-1),'interpreter','none')
%    setoptions(h1, 'FreqUnits', 'kHz');
set(fh.bode,'Position',[2190   548   560   420])

fh.nyquist = figure(5);
%    opt.XLimMode='manual';
%    opt.XLim = [-1.5 0.1];
hold all;
for k=1:length(fna) -1
    nyquist(SYSV.(fna{k}), optn);
end
hold off;
legend(fna(1:end-1),'interpreter','none')

grid off;
set(fh.nyquist,'Position',[2771   553   560   420])

%%
fprintf('Kp=%.3g\n',Cp.Kp)
fprintf('Kp=%.3g\tKi=%.3g\n',Cpi.Kp,Cpi.Ki)




%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   PID tune and plot
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     hch = get(0,'children');
%     tags = get(hch,'Tag');
%     ind(1) = find(~cellfun(@isempty, strfind( tags,'STEP')))
%     ind(2) = find(~cellfun(@isempty, strfind( tags,'BODEPLOT')))
%     ind(3) = find(~cellfun(@isempty, strfind( tags,'NYQUIST')))

%%    

opts = pidtuneOptions('PhaseMargin',50);

[Cp1, info1] = pidtune(ccG0.tf,'PI',opts);
[Cpi1, infoi1] = pidtune(ccG0.tf,'PID',opts);

figure( fh.f3 );
hold all;
step(feedback(Cp1*ccG0.tf,1));
step(feedback(Cpi1*ccG0.tf,1));
hold off;
grid on;
legend('closed(Cp*ccG0)','closed(Cpi*ccG0)');

figure( hch(ind(2)) );
hold all;
h1=bodeplot(feedback(Cp1*ccG0.tf,1),optb);
h2=bodeplot(feedback(Cpi1*ccG0.tf,1),optb);
legend('closed(Cp*ccG0)','closed(Cpi*ccG0)');
hold off;
setoptions(h1, 'FreqUnits', 'kHz');

figure( hch(ind(3)) );
%    opt.XLimMode='manual';
%    opt.XLim = [-1.5 0.1];
hold all;
nyquist(Cp1*ccG0.tf, optn);
nyquist(Cpi1*ccG0.tf, optn);
hold off;
grid off;
legend('Cp*ccG0','Cpi*ccG0');

%%
%%
%%
%%
%%
%%
% *********************************************************************
%               tescht...
% *********************************************************************
clear a b ce cd
Kp=1;
Kh=1;
% for k=1:25
%     Kp=k;
%     a{k}=linmodHighLevel(gcs);
%     b(k)=a{k};
% end
% 
% ce={b.tf};
% cd(1,:)=cellfun(@dcgain, ce)';
% clear ce;

%Kp=1;
Kh=1;
for k=1:20
    Kh=1/k;
    a{k}=linmodHighLevel(gcs);
    b(k)=a{k};
end

ce={b.tf};
cd(2,:)=cellfun(@dcgain, ce)';
clear ce;
xt=[1:length(cd)];
%%
f1=figure(1);
plot(xt,cd(1,:))
legend('Kps')

f2=figure(2);
plot(xt,cd(2,:))
legend('Khs')

f3=figure(3);
plot(xt,cd(1,:),xt,cd(2,:))
legend('Kps','Khs')

%%
% *********************************************************************
%               kompletter Kreis, bandbreite ...
% *********************************************************************
FILES={ 'Galvo_sys_Cdisc_Pcont_cc_nosub_GUT_v63',...
        'Galvo_sys_Ccont_Pcont_cc_GUT_v63',...
        'Loop_detailed_model_comp_cc_vccc_v14_JAWOLL'};
S1=struct([]);


S1=linmodHighLevel(FILES{end},S1,'dlin');

%bodeplot(S1.ss(1),'b-',S1.ss(2),'b--',optb);
f1=figure(1);
hold all;
for k=1:length(S1.ss.OutputName)
    bodeplot(S1.ss(k,1),optb);
end
    legend(S1.ss.OutputName);
hold off;
title(S1.linmod.filename,'interpreter','none')
%%
S2=linmodHighLevel(FILES{2});
%bodeplot(S2.ss(1),'r-',S2.ss(2),'r--',optb);
f2=figure(2);
hold all;
for k=1:length(S2.ss.OutputName)
    bodeplot(S2.ss(k,1),optb);
end
    legend(S2.ss.OutputName);
hold off;
title(S2.linmod.filename,'interpreter','none')

%%
close all

%% ********************************************************************
% Alter Stromregler: 
%   - 2.88mH/1.53Ohm + 1.5Ohm  -->  R-L des Galvos   
% *********************************************************************
RL=1.53+1.5; 
LL=2.888e-3;

P=tf(1,[LL RL]);


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                     kompletter Kreis 
%                   G0  Gtot    S(s)    T(s)
%               Sensitivität, komplementäre- 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
FILES={ 'Galvo_sys_Cdisc_Pcont_cc_nosub_GUT_v63',...
        'Galvo_sys_Ccont_Pcont_cc_GUT_v63'};
FB_EN=0;
S0c=linmodHighLevel(FILES{2});
FB_EN=1;
% Stc=linmodHighLevel(FILES{2});

G0c=S0c.ss(1);

Gw = G0c/(1+G0c);
Gz = 1/(1+G0c);
Gm = -G0c/(1+G0c);


wv=logspace(0,5,75);

optb.FreqUnits='rad/s';
f3=figure(3);
clf;
subplot(121);
hold all;
optb.PhaseVisible='on';
optb.MagVisible ='on';

bodeplot(Gw,'b*-',wv,optb);
bodeplot(Gz,'g*-',wv,optb);
bodeplot(Gm,'r-',wv,optb);
bodeplot(G0c,'c*-',wv,optb);

%legend('Gw(s) = T(s)','Gz(s) = S(s)','Gm(s)','G0(s)');

childrenHnd =get(f3, 'Children');
axes(childrenHnd(3));
legend('T(s) = Gw','S(s) = Gz','Gm(s) = -Gw(s)','G0(s)');

hold off;
title(S0c.linmod.filename,'interpreter','none')

%legend(S1.ss.OutputName);
%%
% *********************************************************************
% nochmal das gleiche aber mit höherer genauigkeit im bereich von wc 
% *********************************************************************
NN=400;
[~,Pm,Wgm,Wpm]=margin(G0c);
% |G0(j.Wpm)| = 1

nwc=log10(Wpm);

% ca. eine dekade über und unter wc (= Wpm)
%wv=logspace(nwc-0.35, nwc+0.5,NN);
wv=logspace(nwc-0.5, nwc+0.5,NN);

%f4=figure(4);
sh=subplot(122);
hold all;

optb.FreqUnits='rad/s';
optb.PhaseVisible='off';
optb.MagVisible ='on';

bodeplot(Gw,'b*-',wv,optb);
bodeplot(Gz,'g*-',wv,optb);
bodeplot(Gm,'r-',wv,optb);
bodeplot(G0c,'c*-',wv,optb);


childrenHnd =get(f3, 'Children');
axes(childrenHnd(3));
xl=get(gca,'Xlim');

% wbs wbt wc
% Find point of intersection between sensitivity S(s) and -3dB line
[magz, ~, wvq]=bode(Gz, wv);
magz=20*log10(squeeze(magz));
[magw, ~, wvq]=bode(Gw, wv);
magw=20*log10(squeeze(magw));

idz = find(magz > -3, 1);
%px = wv(idx)/(2*pi);
ptzx = wv(idz);
ptzy = magz(idz);

idw = find(magw < -3,1);
%px = wv(idx)/(2*pi);
ptwx = wv(idw);
ptwy = magw(idw);

db3=repmat(-3,length(wv),1);

%plot(wv/(2*pi),repmat(-3,1,length(wv)),'m--')
mk={'x'; [17 3]; 'Red' };
plot(wv,repmat(-3,1,length(wv)),'r--')
plot(Wpm, 0, mk{1}, 'MarkerSize', mk{2}(1), 'LineWidth',mk{2}(2),'MarkerEdgeColor',mk{3})
plot(ptzx, ptzy, mk{1}, 'MarkerSize', mk{2}(1), 'LineWidth',mk{2}(2),'MarkerEdgeColor',mk{3})
plot(ptwx, ptwy, mk{1}, 'MarkerSize', mk{2}(1), 'LineWidth',mk{2}(2),'MarkerEdgeColor',mk{3})
legend('T(s) = Gw','S(s) = Gz','Gm(s) = -Gw(s)','G0(s)');

fsiz=22;

text(ptzx, ptzy*0.7,['W_{BS}= ' num2str(round(ptzx)) ' rad/s  '],...
    'FontSize',fsiz(1),'HorizontalAlignment','right')
text(ptwx, ptwy*0.7,['W_{BT}= ' num2str(round(ptwx)) ' rad/s  '],...
    'FontSize',fsiz(1),'HorizontalAlignment','left')
text(Wpm, -ptwy*0.7,['W_{c}= ' num2str(round(Wpm)) ' rad/s  '],...
    'FontSize',fsiz(1),'HorizontalAlignment','center')
hold off;
title(S0c.linmod.filename,'interpreter','none')




%%
% *********************************************************************
%               Nochmal testen mit RC- RC- Strecke
% *********************************************************************
FILES={'RC_RC'};
R1=1.2e3; C1=220e-9; T1=R1*C1; 
syms p;

%open_system(FILES{1});
uoff=1.45;      % ca. mittelwert des DAC- levels

Aw=1.2

% FB=0;
% G0=linmodHighLevel(gcs)
% FB=1;
% Gtot=linmodHighLevel(gcs)
g0sym=Kp/(T1*p+1)^2;
G0.tf=sym2tf(g0sym);
[z p k]=zpkdata(G0.tf);
G0.zpk=zpk(z,p,k);
Gtot.tf=feedback(G0.tf,1);
Gtot.zpk=feedback(G0.zpk,1);
%%
optb=bodeoptions;
optb.FreqUnits='Hz';
optb.grid='on';

f1=figure(1);
SUB=220;

subplot(SUB+1);
bodeplot(G0.tf, Gtot.tf, optb);
legend('G0','Gtot')

optn=nyquistoptions;
optn.ShowFullContour='off';
optn.grid='off';

subplot(SUB+2);
nyquist(G0.tf, Gtot.tf, optn);
legend('G0','Gtot')

subplot(SUB+3);
rlocus(G0.tf, Gtot.tf);
legend('G0','Gtot')

[ps(1,:), ~]=pzmap(G0.tf);
[ps(2,:), ~]=pzmap(Gtot.tf);
subplot(SUB+4);
hold on;
pzmap(G0.tf, Gtot.tf)
% plot(real(ps(1,:)),imag(ps(1,:)),'rx','LineWidth',2)
% plot(real(ps(2,:)),imag(ps(2,:)),'bx','LineWidth',2)
grid off;
legend('G0','Gtot')

%% 
% *********************************************************************
%               table spice models
% *********************************************************************
MOD = { 'IRF9640 VDMOS(pchan Rg=3 Vto=-3.5 Rd=.15 Rs=.15 Rb=.15 Kp=8 lambda=.01 mtriode=.5 Cgdmax=1.5n Cgdmin=.07n Cgs=1n Cjo=1n Is=38p mfg=International_Rectifier Vds=-200 Ron=.5 Qg=44n)',...
        'IRFP9240 VDMOS(pchan Rg=3 Vto=-4 Rd=200m Rs=50m Rb=100m Kp=8.2 Lambda=.10 Cgdmax=1.8n Cgdmin=.07n Cgs=.77n Cjo=.77n Is=76p mfg=International_Rectifier Vds=-200 Ron=500m Qg=44n)',...
        'IRFP240 VDMOS(Rg=3 Vto=4 Rd=72m Rs=18m Rb=36m Kp=4.9 Lambda=.03 Cgdmax=1.34n Cgdmin=.1n Cgs=1.25n Cjo=1.25n Is=67p mfg=International_Rectifier Vds=200 Ron=180m Qg=70n)',...
        'IRFP250N VDMOS(Rg=1.44 Vto=4.0 Rd=47m Rs=0m Rb=5.6m Kp=13 Cgdmax=3.9n Cgdmin=0.10n Cgs=1.9n Cjo=1.25n Is=5p tt=186n mfg=International_Rectifier Vds=200 Ron=75m Qg=123n)'};
MOD1=MOD;

for k=1:4
    MOD{k}=strrep(MOD{k},'(',' ');
    MOD{k}=strrep(MOD{k},')',' ');
    MOD{k}=strsplit(MOD{k},' ');
    TYPE{k}=MOD{k}(1:3);
    MOD{k}(1:3)=[];
end
type=TYPE{1}
mod=MOD{1}
for k=1:length(MOD)
%    NAMES{k} =      
end    
    f = figure('Position',[200 200 400 150]);
dat = rand(3); 
rnames = cellfun(@(x) x{1}, TYPE,  'UniformOutput', false);
cnames = {'First','Second','Third'};
t = uitable('Parent',f,'Data',dat,'ColumnName',cnames,... 
            'RowName',rnames,'Position',[20 20 360 100]);
    
% %         return
% clear m1
% for k=1:4
%     m1{k}=sort(strsplit(MOD{k},' ')');    
% end
% m1{1}
% 
% str=[];
% for k=1:min(cellfun(@length, m1))
%     str=[str sprintf('%s\t\t%s\t\t%s\t\t%s\t\t\n',...
%         m1{1}{k},m1{2}{k},m1{3}{k},m1{4}{k})];
% end
% sprintf('%s',str)
%%
% *********************************************************************
%               Update simulink configs struct
% *********************************************************************
clear open_bd ind del
open_bd = find_system('type', 'block_diagram');
ind = [1:length(open_bd)];

del{1} = find(~cellfun(@isempty, strfind(lower(open_bd),'simulink')));
del{2} = find(~cellfun(@isempty, strfind(lower(open_bd),'simviewers')));
del{3} = find(~cellfun(@isempty, strfind(lower(open_bd),'eml_lib')));
if length(find(cellfun(@isempty, del))) > 0
    
    ind(del{~cellfun(@isempty,del)}) = [];
end
% 
% if exist('simulinkConfigSets','var')
%     save('simulinkConfigSetsBACK','-struct',...
%         simulinkConfigSets.Galvo_sys_cc_neu_v32.);
%     clear savesimulinkConfigSets;
% end
clear simulinkConfigSets;

for k=1:length(open_bd(ind))
    tmp1 = getActiveConfigSet(SIMFILES{k})
    simulinkConfigSets.(SIMFILES{k}) = tmp1;
end
simulinkConfigSets


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Read logging data from model logging 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear l

    for k=1:logsout.numElements  
        l.(strrep( logsout.getElement(k).Values.Name ,'*','_stern'))=logsout.getElement(k).Values.Data;
    end
    l.time = logsout.getElement(1).Values.Time;
    
%% FFT based on fixed- stepsize simulation log output   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Fs = 1000;                    % Sampling frequency
T = 1/Fs;                     % Sample time
L = length(l.times);                     % Length of signal
%t = (0:L-1)*T;                % Time vector
t=l.times;
% Sum of a 50 Hz sinusoid and a 120 Hz sinusoid

% x = 3*sin(2*pi*50*t);% + sin(2*pi*120*t); 
% y = x + 2*randn(size(t));     % Sinusoids plus noise
y=l.Uc

% p1=figure(1);
% plot(Fs*t(1:50),y(1:50))
% title('Signal Corrupted with Zero-Mean Random Noise')
% xlabel('time (milliseconds)')

% It is difficult to identify the frequency components by looking 
% at the original signal. Converting to the frequency domain, the 
% discrete Fourier transform of the noisy signal y is found by 
% taking the fast Fourier transform (FFT):

NFFT = 2^nextpow2(L); % Next power of 2 from length of y
Y = fft(y,NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);

p2=figure(2);
% Plot single-sided amplitude spectrum.
plot(f,2*abs(Y(1:NFFT/2+1))) 
title('Single-Sided Amplitude Spectrum of y(t)')
xlabel('Frequency (Hz)')
ylabel('|Y(f)|')

%%
f10=figure(10);
clf
SUB=100*logsout.numElements + 10;
    for k=1:logsout.numElements
        if SUB > 110
            sb(k)=subplot(SUB+k);
        end
        plot(l.time, l.(logsout.getElement(k).Values.Name))
    end
    
    e_inf = sum(l.(logsout.getElement(k).Values.Name)(end-10:end))/10;
    disp(sprintf('e(inf) = %.3e', e_inf))
    grid on;
    

    
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   state space model
%   Polplatzierung für ein Servosystem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Matlab & Tools, (U. Brunner / J. Hoffmann) Ab S.335
%------------------------------------------------------------------

SSLIMOD={   'GalvoModel_v43',...
            'Galvo_sys_SS_v1'};

if ~exist('Gsys','var')
    load('GalvoLinmods.m','-mat','Gsys');   
    disp('Gsys loaded from m- file');
end

%------------------------------------------------------------------
% ss Matritzen bilden für simulink modell
%------------------------------------------------------------------
% Für das Platzieren der gewünschten Pole benötigt der Zustandsregler
% alle im state space vorhanden Zustandsgrößen, also den Zustands-
% Vektor x(t).
% Dieser wird über eine Rückführungsmatrix  K  an den Eingang des
% ss- Modells zurück gekoppel.  
%
%   dx(t) = A.x(t) + B.u(t)     % Standard ss modell
%   u(t)  = -K.x(t)             % Rückführung
%       ==>     
%   dx(t) = (A - B.K).x(t)      % Homogenes DGL- System 1. Ordnung
%
%   Die Pole (oder Wurzeln der charakteristischen Gleichung) können
%   durch die Matrix K beliebig platziert werden,
%   WENN die Eingangsmatrix B und die Systemmatrix A bestimmte 
%   Bedingungen erfüllen... 
%   
%   ... wie gut ein System beobachtbar bzw. steuerbar ist, wird über 
%   die Controllability- und Observability- Matritzen bewertet.
%
%   ------------------------------------------
%       Steuerbarkeit   -   Beobachtbarkeit
%       Controllability -   Observability
%   ------------------------------------------
%
%   Die Steuerbarkeit im Sinne der Polplatzierung verlangt, dass die
%   Controllabilitymatrix Co den RANG n in höhe der Systemordnung hat.
%
%   Die Beobachtbarkeitsmatrix beschreibt, wie gut sich die n-
%   Zustandsgrößen des Systems aus der Ausgangsgröße rekonstruieren 
%   lassen... ( Beobachter )
%
%   Co = [B, A.B, A^2.B, ...A^(n-1).B]      < rank( Co ) =!= n_sys >
%   Co = ctrb(A, B)
%
%   Ob = [C, C.A, C.A^2, ...C.A^(n-1)]      
%   Ob = obsv(A, B)
%
%   Die Rückführungsmatrix K kann bei bekannten Wunschpolen mit den 
%   Matlab funktionen 
%   
%   K = place(A, B, p);     oder    K = acker(A, B, p);
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

%%
% g1=1/(Lc*p)/(1+1/(Lc*p)*(Rc+Rsh))
% g2=1/(JR*p)/(1+1/(JR*p)*KFR)
% gtot=(g1*g2*KMT)/((1+g1*g2*KMT*KBM)*p)
%
% gtot = KMT/(p*(KBM*KMT + KFR*Rc + KFR*Rsh + KFR*Lc*p + JR*Rc*p + JR*Rsh*p + JR*Lc*p^2))
%     
% param=loadGalvoParam(4)
% na=fieldnames(param)
% paramC=struct2cell(param)
% subStr=subs(gtot,na,paramC)
% sys10=sym2tf(subStr)

CL = @(x,n) repmat(x, 1, n);
cl = CL('-',60);

[A, B, C, D] = ssdata(Gsys{1}(4));       % SISO ss Model

Gsys{end+1,1} = ss(A, B, C, D);
Gsys{end,1}.InputName = Gsys{1,1}.InputName;
Gsys{end,1}.OutputName = Gsys{1,1}(4).OutputName;

Co = ctrb(A, B);                  % Steuerbarkeit
Co2 = [B, A*B, A^2*B];   
disp(sprintf('%s\nRang von Co:\trank(Co) = %i', cl, rank(Co)))
disp(sprintf('Rang von Co2:\trank(Co2) = %i', rank(Co2)))

disp(sprintf('%s\n\nBeobachtbarkeitsmatrix Ob = obsv(A,B '' )\n',cl))
Ob = obsv(A, B');
disp(Ob)
disp(cl)

disp(sprintf('\n%s\n%s\n\tSteht so im Buch, müsste aber Ausgangsmatrix sein\n%s\n%s',...
                CL('*', 60), CL('*', 60), CL('*', 60), CL('*', 60)))

disp(sprintf('\n\nBeobachtbarkeitsmatrix Ob = obsv(A,C)\n'))
Ob = obsv(A, C);
disp(Ob)
disp(cl)


%save('GalvoLinmods.m', 'Gsys','-append');

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NUR LINMOD
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%set_param( [SIMFILES{1} '/CopeMain'],'open','off');
%LIMOD={'Galvo_CC_linmod_v30'};
ds='---------------------------------------------------';
LIMOD={  'CurrentComp_v63_uset',...
         'Galvo_sys_cc_detailed_pwr_v40',...
         'CurrentComp_v20_shunt_fb',...
         'CurrentComp_v20',...
         'GalvoModel_v53',...
         'GalvoModel_v43'};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
clear Gsys;
for selSys=1
    open_system(LIMOD{selSys});
    set_param(LIMOD{selSys}, 'MaxStep', '1e-6');
    clear S;

    S = linmod(LIMOD{selSys});
    S.filename = LIMOD{selSys};
    u_ = strrep(S.InputName, [S.filename '/'], '');
    y_ = strrep(S.OutputName, [S.filename '/'], '');
    S.InputName = u_;
    S.OutputName = y_;

    %GvCCa = ss(S.a, S.b, S.c, S.d, 'u', u_, 'y', y_);           % Kompletter Regelkreis 
    statespace = ss(S.a, S.b, S.c, S.d, 'u', u_, 'y', y_);           % Kompletter Regelkreis 

    if ((length(S.InputName) > 1) && (length(S.OutputName) > 1))
        sprintf('%s\n\tMIMO system\n%s',ds,ds)
    else
        if length(S.InputName) > 1
            sprintf('%s\n\tMISO system\n%s',ds,ds)
        else
            sprintf('%s\n\tSIMO system\n%s',ds,ds)
        end
    end

    [num, den] = tfdata(statespace);
    if exist('Gsys','var') > 0
        n = length(Gsys);
    else
        n = 1;
    end

    Gsys{n,1} = tf(num , den, 'u', u_, 'y', y_)
    Gsys{n,2} = LIMOD{selSys}
end

f99=figure(99);
delete(findall(f99,'type','line'));

leg=[];
length(Gsys(:,1))
for k=1:length(Gsys(:,1))
    step(Gsys{k,1})
    leg = [leg sprintf('%s:',Gsys{k,2})]
    hold all;
end
hold off;

legend(strsplit(leg(1:end-1),':'))
%end
return

syms Kp Ki Kd N p
pid=Kp+Ki/p+Kd*N/(1+N/p);
Kp=1.7;Ki=0.2;Kd=-1.26;N=0.1781;
PID=sym2tf(eval(pid))

loop=feedback(PID*GvCCb(2),1);
s1=balred(loop,1);
kb=1/pole(s1)





%%
% ------------------------------------------------------------------------
% ----- Nochmal in klein
% ----- Estimate tf of current controller simulated in LTSpice
% ------------------------------------------------------------------------
RAWS={ 'powerstage_PushPull_FET_lochraster_KOB.raw',...
       'powerstage_PushPull_FET_ADA4700_hv.raw',...
       'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_pwrInv.raw'};

RAWS={ 'powerstage_PushPull_FET_lochraster_KOB.raw',...
       'powerstage_PushPull_FET_ADA4700_hv-G0-alles.raw',...
       'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_pwrInv-G0-alles.raw',...
       'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_inkl_sum.raw',...
       'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_afterLoopEst.raw',...
       'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_inkl_sum_BAUEN.raw',...
       'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_cc_vccc.raw',...
       'aktuell/endstufe_BJT_MJ1101xG_ada4700_sum_BS52_62_ref_current_mirror.raw',...
       'aktuell/endstufe_FET_lochraster_KOB_fixes_26-09-2014.raw'};
   
indResp = [4];

FILES = RAWS(end);
%%
% ------------------------------------------------------------------------
% cl=clock;
% timeAndDate=sprintf('Date: %i-%i-%i\tTime: %i:%i:%i', fliplr(cl(1:3)), round(cl(end-2:end)));
% 
% ds='---------------------------------------------------';
% sprintf('%s\n\t Start frequency response - model estimation\n\t\t%s \n%s', ds, timeAndDate, ds)
% 
% clear G0_fet G0_bjt G0_fetEST G0_bjtEST G0 ;
% G0 = struct('fet_iw',idtf(1,[1 1]),'fet_uw', idtf(1,[1 1]),...
%             'bjt_iw',idtf(1,[1 1]),'bjt_uw', idtf(1,[1 1]));
% G0;
% 
% if 0
% k=1;
%     G0.fet_iw = idSpice( FILES{k}, 'I(RFB)', [0 2e6], [3 1], '0');
%     sprintf('%s\nFreq response estimation for FET tf I(RFB)/w ready!\nFits: %f %%',...
%                     FILES{k}, G0.fet_iw.Report.Fit.FitPercent)
% 
%     G0.fet_uw = idSpice( FILES{k}, 'V(Ucoil)', [0 2e6], [4 3], '0');
%     sprintf('%s\nFreq response estimation for FET tf V(Icoil)/w ready!\nFits: %f %%',...
%                     FILES{k}, G0.fet_uw.Report.Fit.FitPercent)
% 
% 	G0.fet_iw.InputName = 'IV(cmd)';
% 	G0.fet_uw.InputName = 'IV(cmd)';
% 	G0.fet_iw.OutputName = 'I(RFB)';
% 	G0.fet_uw.OutputName = 'V(Ucoil)';
% 
% 
% k=2;
%     G0.bjt_iw = idSpice( FILES{k}, 'I(RFB)', [0 2e6], [3 1], '0');
%     sprintf('%s\nFreq response estimation for BJT tf I(RFB)/w ready!\nFits: %f %%',...
%                     FILES{k}, G0.bjt_iw.Report.Fit.FitPercent)
% 
%     G0.bjt_uw = idSpice( FILES{k}, 'V(Ucoil)', [0 2e6], [4 3], '0');
%     sprintf('%s\nFreq response estimation for BJT tf V(Icoil)/w ready!\nFits: %f %%',...
%                     FILES{k}, G0.bjt_uw.Report.Fit.FitPercent)
% 
% 	G0.bjt_iw.InputName = 'IV(cmd)';
% 	G0.bjt_uw.InputName = 'IV(cmd)';
% 	G0.bjt_iw.OutputName = 'I(RFB)';
% 	G0.bjt_uw.OutputName = 'V(Ucoil)';
% 
%     
%     
% G0EST = G0;
% 
% end
%%
% ------------------------------------------------------------------------
% ----- Loop estimation 
% ------------------------------------------------------------------------
k=1;
intVect=[1 10e6];
sigName='I(Rshunt)';
sigName='V(out_a)';
invokeNames=0;
%Gl
%pv=[[2 0];[2 1];[2 2];[3 0];[3 1];[3 2];[3 3]] ;
pv=[[1 0];[1 1];[2 0]];%[2 1];[2 2];[3 0];[3 1]];%[3 2];[3 3];[4 0];[4 1];[4 2];[4 3];[4 4]];
%pv=[[2 0];[2 1]];
%pv=[[3 3];[4 0];[4 1];[4 2];[4 3];[4 4]] ;
%pv=[pv(1:end-1,:); [3 3];[4 0];[4 1];[4 2];[4 3];[4 4]] ;
%pv=[[1 0];[1 1]]

for NN=1:1
%     if invokeNames
%         sigName=sprintf('auto:%i',NN);
%     end

    cl=clock;
    timeAndDate=sprintf('Date: %i-%i-%i\tTime: %i:%i:%i', fliplr(cl(1:3)), round(cl(end-2:end)));
    clear G0;

    G0=struct;

    ds='---------------------------------------------------';
    disp(sprintf('\n\n%s\n\t Start frequency response - model estimation\n\t\t%s \n%s',...
        ds, timeAndDate, ds))
    disp(sprintf('%s\n%s\n', FILES{1},ds))

    DUMMY='DUMMY';
    for k=1:length(pv(:,1))
        disp(sprintf('%s\npz vector: [%i %i]\t\t(...)',ds , pv(k,:)))
        tt1=tic;
    %     sigNameField = strrep(sigName,'(','_');
    %     sigNameField = strrep(sigNameField,')','');
        if invokeNames
            [G0.(DUMMY){k,1} sigNameInv ErrorFlag] = idSpice( FILES{1}, sigName, intVect,...
                    pv(k,:), '0');
        else
            [G0.(DUMMY){k,1} sigNameInv ErrorFlag] = idSpice( FILES{1}, 'V(out_a)', intVect,...
                    pv(k,:), '0');
            sigNameInv = 'V(out_a)';
        end
        
        ttSpent = toc(tt1);
        disp(sprintf('Freq response estimation done!\nFits: *** %.3f%% ***\t\ttime spent: %.2fs',...
                    G0.(DUMMY){k,1}.Report.Fit.FitPercent, ttSpent))
        G0.(DUMMY){k,2}=sprintf('[%i %i]', pv(k,:));
        G0.(DUMMY){k,3}=sprintf('%.1f %.1e',intVect);
        G0.(DUMMY){k,4}=sprintf('%.2f%%',G0.(DUMMY){k,1}.Report.Fit.FitPercent);
        G0.(DUMMY){k,5}=sprintf(FILES{1});
        G0.(DUMMY){k,6}={ ['[' num2str(G0.(DUMMY){k}.num(1,:),'%.2e  ') ']'],...
                        ['[' num2str(G0.(DUMMY){k}.den(1,:),'%.2e  ') ']']};
        G0.(DUMMY){k,7}=sprintf(sigNameInv);
        G0.(DUMMY){k,8}=timeAndDate;
        G0.(DUMMY){:};
        if ErrorFlag ~= 0
            break
        end
    end

    %%%%%% copy and rename field DUMMY to the signal name returned by idSpice()
    [G0.(sigNameInv)] = G0.DUMMY
    %G0 = rmfield(G0, DUMMY);

    if ~exist('Gl','var')
        load('estimationLoop.m','-mat','Gl');
        disp('Gl loaded')
    end
    G0.(sigNameInv){:,end};

    Gl{end+1}=G0.(sigNameInv);

end
save('estimationLoop.m', 'Gl','-append');


%%
s_perc = Gl{end}([1:end],4,1);
perc = cellfun(@str2num, strrep(s_perc,'%',''));
ind = find(max(perc));
sys = Gl{end}{ind,1,1};
sys.OutputName = cat(1,Gl{end}{ind,7});

disp(sprintf('\n%s\n%s\nMax. Fit: %s\n%s\n%s', ds, ds, Gl{end}{ind,4,1},ds,ds))
sys
%%
sys1=Gl{end}{2,1}
sysEst = cat(1,Gl{end}{1,1});
sysEst.OutputName = cat(1,Gl{end}{1,7});

% Find VAR in LTspice import data structure
% find(~cellfun(@isempty, (strfind(resp.variable_name_list(1,:), 'V(out_a)'))))

% Gl(end-1)=[]
%%
% ------------------------------------------------------------------------
% ----- Compare estimated tf to the numeric raw data
% ------------------------------------------------------------------------
cpl=Gl{1,end}(3,1);
[num den]=tfdata(cpl{:})
cpl{2}.tf=tf(num, den)

pb=bodeoptions;
pb.FreqUnits='Hz';
pb.XLim=[1 100e6];
pb.YLim{1,1}=[-50 25];     % YLim Mag
pb.YLim{1,2}=[-115 85];    % YLim Phase
%pb.YLim=[-100 25];
pb.Grid='on';

f94=figure(94);
hb=bodeplot(cpl{2}.tf,pb);
title(sprintf( ['Freq response estimation - closed loop V(out_A)/V(Ucmd)\n',...
               'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_inkl_sum.raw']), 'Interpreter','none');

%% -----------------------------------------------------------------------
% ----- model block to tf
% ------------------------------------------------------------------------

tmp=loadGalvoParam('desc');
cellfun(@syms, tmp(:,1));
syms s p
clear tmp;
whos

G1=(1/s*1/Lc)/(1+(1/s*1/Lc)*(Rsh+Rc));
G1=G1*KMT;
pretty(G1)
G2=(1/s*1/JR)/(1+(1/s*1/JR)*KFR);
pretty(G2)     % BEM nach pos verschoben
G3=(G2*1/s)/(1+(G2*1/s)*KFR);
pretty(G3)
Gtot=(G1*G3)/(1+(G1*G3)*(KBM*s));
pretty(Gtot)

simp=simplify(Gtot);
coll=collect(simp);
pretty(simp)
pretty(coll)

simpP=subs(simp,'s','p')

param=loadGalvoParam(4);
paramCtrl=loadCtrlParam(4);
evalGalvoParam(4);

tf1=sym2tf(eval(simpP))
clear s
%% -----------------------------------------------------------------------
% ----- load numeric raw data
% ------------------------------------------------------------------------
resp=LTspice2Matlab(FILES{1});  
SIGNALS={'V(out_a)','I(out_a)','V(stim)','I(Rshunt)'};

ind=[];
for k=1:length(SIGNALS)
    ind{k} = find(~cellfun(@isempty, (strfind(resp.variable_name_list(1,:), SIGNALS{k}))));
end
clrpo=cellfun(@isempty, ind);
ind(clrpo)=[];
SIGNALS(clrpo)=[];

ind = cell2mat(ind);
if isempty(ind)
    SIGNALS
    error( 'Signals not found' )
else
    sig.V = [];
    sig.I = [];
    for k=1:length(ind)
        sig.(SIGNALS{k}(:,1)).(SIGNALS{k}(:,3:end-1)) = resp.variable_mat(ind(k),:);
    end
end
sig.t=resp.time_vect;

%p=stepoptions;

fn=fieldnames(sig.V);

sv1=figure(90);
SUB=220;

for k=1:length(fn)
    hs(k)=subplot(SUB+k)
    plot(sig.t, sig.V.(fn{k}));
end
grid on;

fn=fieldnames(sig.I);
for k=1:length(fn)
    hs(k)=subplot(SUB+k)
    plot(sig.t, sig.I.(fn{k}));
end
grid on;
legend(fn)




    
%%
[num den]=tfdata(G0.VoutA)
sys1=tf(num, den)
syms p
param=loadGalvoParam(4)
evalGalvoParam
glc=(1/(Lc*p)/(1+(Rsh/(p*Lc))))
pretty (glc)
glc=sym2tf(glc)

pb=bodeoptions;
pb.FreqUnits='MHz';
f98=figure(98);
bodeplot(sys1);
f97=figure(97);
bodeplot(glc);

p=nyquistoptions;
p.ShowFullContour='off';
f96=figure(96);
nyquist(sys1,p);
f95=figure(95);
rlocus(sys1);
%%
% 
% [num, den] = tfdata(G0.fet_iw);
% G0tf.fet_iw = tf(num, den);
% [num, den] = tfdata(G0.fet_uw);
% G0tf.fet_uw  = tf(num, den);
% 
% [num, den] = tfdata(G0.bjt_iw);
% G0tf.bjt_iw = tf(num, den);
% [num, den] = tfdata(G0.bjt_uw);
% G0tf.bjt_uw  = tf(num, den);

G0tf = [];

uu = G0.fet_iw.InputName{:};
yy = G0.fet_iw.OutputName{:};
[num, den] = tfdata(G0.fet_iw);
G0tf{1,1} = tf(num, den,'u',uu,'y',yy);

uu = G0.fet_uw.InputName{:};
yy = G0.fet_uw.OutputName{:};
[num, den] = tfdata(G0.fet_uw);
G0tf{1,2}  = tf(num, den,'u',uu,'y',yy);


uu = G0.bjt_iw.InputName{:};
yy = G0.bjt_iw.OutputName{:};
[num, den] = tfdata(G0.bjt_iw);
G0tf{2,1} = tf(num, den,'u',uu,'y',yy);

uu = G0.bjt_uw.InputName{:};
yy = G0.bjt_uw.OutputName{:};
[num, den] = tfdata(G0.bjt_uw);
G0tf{2,2}  = tf(num, den,'u',uu,'y',yy);

%%
% ------------------------------------------------------------------------
% ----- Bode
% ------------------------------------------------------------------------
%
%[files, match] = arrayf(@(x) x(indResp), cellfun(@strsplit, RAWS, {'_','_','_'}, 'UniformOutput', false));
%cols={'blue', 'green', 'red', 'cyan', 'magenta', 'black'};
delete(findall(f4,'type','line'))

opt = bodeoptions;
opt.FreqUnits = 'kHz';
opt.PhaseWrapping = 'off';
opt.Title.Interpreter = 'none';
opt.Grid = 'on';
opt.PhaseMatching = 'on';
opt.PhaseMatchingFreq = 0.1;
opt.PhaseMatchingValue = 0;
opt.XLim = [0.1, 1e6];
opt.Title.String = FILES(1);


f4 = figure(4);
SUB=120;

B1=subplot(SUB+1);
hold all;
bd1(1)=bodeplot(G0tf{1,1}, opt);
bd1(2)=bodeplot(G0tf{1,2}, opt);
hold off;
legend([G0tf{1,1}.OutputName{1} ' / ' G0tf{1,1}.InputName{1}],...
       [G0tf{1,2}.OutputName{1} ' / ' G0tf{1,2}.InputName{1}]);

opt.Title.String = FILES(2);
B2=subplot(SUB+2);
hold all;
bd2(1)=bodeplot(G0tf{2,1}, opt);
bd2(2)=bodeplot(G0tf{2,2}, opt);
hold off;
legend([G0tf{2,1}.OutputName{1} ' / ' G0tf{2,1}.InputName{1}],...
       [G0tf{2,2}.OutputName{1} ' / ' G0tf{2,2}.InputName{1}]);
%%
% ------------------------------------------------------------------------
% ----- Bode von den closed loops
% ------------------------------------------------------------------------
delete(findall(5,'type','line'))

opt = bodeoptions;
opt.FreqUnits = 'kHz';
opt.PhaseWrapping = 'off';
opt.Title.Interpreter = 'none';
opt.Grid = 'on';
opt.PhaseMatching = 'on';
opt.PhaseMatchingFreq = 0.1;
opt.PhaseMatchingValue = 0;
opt.XLim = [0.1, 1e6];

opt.Title.String = sprintf('%s \nClosed Loop',FILES{1});

f5 = figure(5);
SUB=120;

B1=subplot(SUB+1);
hold all;
bd1(1)=bodeplot(feedback(G0tf{1,1},1), opt);
bd1(2)=bodeplot(feedback(G0tf{1,2},1), opt);
hold off;
legend([G0tf{1,1}.OutputName{1} ' / ' G0tf{1,1}.InputName{1}],...
       [G0tf{1,2}.OutputName{1} ' / ' G0tf{1,2}.InputName{1}]);

opt.Title.String = sprintf('%s \nClosed Loop',FILES{2});
B2=subplot(SUB+2);
hold all;
bd2(1)=bodeplot(feedback(G0tf{2,1},1), opt);
bd2(2)=bodeplot(feedback(G0tf{2,2},1), opt);
hold off;
legend([G0tf{2,1}.OutputName{1} ' / ' G0tf{2,1}.InputName{1}],...
       [G0tf{2,2}.OutputName{1} ' / ' G0tf{2,2}.InputName{1}]);
   
   
%setoptions(bd2,opt);

%%
% ------------------------------------------------------------------------
% ----- nyquist
% ------------------------------------------------------------------------
%return

f8=figure(8);
SUB=120;

opt=nyquistoptions;
opt.ShowFullContour='off';
opt.Title.String = FILES(1);
opt.Title.Interpreter = 'none';

sp = cellfun(@strsplit, RAWS, {'_','_','_'}, 'UniformOutput', false)

B(1) = subplot(SUB+1);
hold all;
hn(1) = nyquistplot(G0tf{1,1}, opt);
hn(2) = nyquistplot(G0tf{1,2}, opt);
hold off;
legend([G0tf{1,1}.OutputName{1} ' / ' G0tf{1,1}.InputName{1}],...
       [G0tf{1,2}.OutputName{1} ' / ' G0tf{1,2}.InputName{1}]);
% legend( cellfun(@strjoin, cellfun(@(x) x(end-2:end),...
%         sp(indResp), 'UniformOutput', false), 'UniformOutput', false));

opt.Title.String = FILES(2);
B(2) = subplot(SUB+2);
hn(3) = nyquistplot(G0tf{2,1}, opt, G0tf{2,2}, opt);
%hn(4) = nyquistplot(G0tf{2,2}, opt);
legend([G0tf{2,1}.OutputName{1} ' / ' G0tf{2,1}.InputName{1}],...
       [G0tf{2,2}.OutputName{1} ' / ' G0tf{2,2}.InputName{1}]);

   
   
%%
% ------------------------------------------------------------------------
% ----- root locus
% ------------------------------------------------------------------------
%return

f9=figure(9);
SUB=120;


sp = cellfun(@strsplit, RAWS, {'_','_','_'}, 'UniformOutput', false)

s9(1) = subplot(SUB+1);
rlocus(G0tf{1,1}, 'b', G0tf{1,2}, 'g-');

grid off;
legend([G0tf{1,1}.OutputName{1} ' / ' G0tf{1,1}.InputName{1}],...
       [G0tf{1,2}.OutputName{1} ' / ' G0tf{1,2}.InputName{1}]);
ht(1) = title(s9(1), FILES(1));
set(ht(1),'Interpreter','none')
   
opt.Title.String = FILES(2);
s9(2) = subplot(SUB+2)
rlocus(G0tf{2,1}, 'b', G0tf{2,2}, 'g-');
grid off;
legend([G0tf{2,1}.OutputName{1} ' / ' G0tf{2,1}.InputName{1}],...
       [G0tf{2,2}.OutputName{1} ' / ' G0tf{2,2}.InputName{1}]);
ht(2) = title(s9(2), FILES(2));
set(ht(2),'Interpreter','none')

% legend( cellfun(@strjoin, cellfun(@(x) x(end-2:end),...
%         sp(indResp), 'UniformOutput', false), 'UniformOutput', false));


% 
% 
% %%
% if 0
% % ------------------------------------------------------------------------
% % ----- Estimate tf of current controller simulated in LTSpice
% % ------------------------------------------------------------------------
%     RAWS={ 'powerstage_PushPull_FET_lochraster_KOB.raw',...
%            'powerstage_PushPull_FET_ADA4700_hv.raw',...
%            'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_pwrInv.raw'};
% 
%     RAWS={ 'powerstage_PushPull_FET_lochraster_KOB.raw',...
%            'powerstage_PushPull_FET_ADA4700_hv-G0-alles.raw',...
%            'powerstage_PushPull_BJT_MJ1101xG_LT_HvOp_pwrInv-G0-alles.raw'};
% 
% estLTI='/home/mainster/CODES_local/matlab_workspace/RT_projects/GalvoProjekt/estimatedLTI/';
% 
% indResp = [2, 3];
% 
% fieldnames_={'filename',RAWS{indResp},'estOrder',zeros(2,4)}
% filenames=RAWS(indResp);
% obj=struct( 'filename',filenames,...
%             'estOrder',{[[3, 1];[4, 3]], [[3, 2];[3, 2]]},...
%             'w_i',{cell(length(indResp), 1)},...
%             'w_u',{cell(length(indResp), 1)})
% 
%         %'w_i',{{idtf(1,[1 1]), idtf(1,[1 2])}},...
%          %   'w_u',{{idtf(1,[1 1]), idtf(1,[1 1])}})
% % ------------------------------------------------------------------------
% % row vectors containing num and den orders for estimation
% % ------------------------------------------------------------------------
% % {k,1} -> tfCCi RAWS{k}    {k,2} -> tfCCu RAWS{k}
% % {1,:} -> tfCCi, tfCCu pzs for file 1
% % {2,:} -> tfCCi, tfCCu pzs for file 2
% % ------------------------------------------------------------------------
% cl=clock;
% timeAndDate=sprintf('Date: %i-%i-%i\tTime: %i:%i:%i', fliplr(cl(1:3)), round(cl(end-2:end)));
% 
% ds='---------------------------------------------------';
% sprintf('%s\n\t Start frequency response - model estimation\n\t\t%s \n%s', ds, timeAndDate, ds)
% 
% 
%     for k=1:length(indResp)
%         if ~exist('tfCC.mat','file')
% 
%             obj(k).w_i{1} = idSpice( obj(k).filename, 'I(RFB)',...
%                             [0 2e6], obj(k).estOrder(1,:), '0');
%             sprintf('%s\nFreq response estimation for tf I(RFB)/w ready!\nFits: %f %%',...
%                             obj(k).filename,...
%                             obj(k).w_i{1}.Report.Fit.FitPercent)
%                     
%             obj(k).w_i{1}.InputName = 'I_{cmd}';
%             obj(k).w_i{1}.OutputName = 'I_{FB}';
% 
%             obj(k).w_u{1} = idSpice( obj(k).filename, 'V(Ucoil)',...
%                             [0 2e6], obj(k).estOrder(2,:), '0');
%             sprintf('%s\nFreq response estimation for tf V(coil)/w ready!\nFits: %f %%',...
%                             obj(k).filename,...
%                             obj(k).w_u{1}.Report.Fit.FitPercent)
%                     
%             obj(k).w_u{1}.InputName = 'I_{cmd}';
%             obj(k).w_u{1}.OutputName = 'V_{coil}';
% 
%         else
%             load('tfCC.mat');
%             sprintf('estimated tfCC loaded from %s\n', [estLTI 'tfCC.mat'])
%         end
%     end
% end
% 
% m=1;
% for k=1:size(obj,2)
%     obj(k).frd={obj(k).w_i{1}, obj(k).w_u{1}};
% %     obj(k).tfs(m)=tf(obj(k).frd{m}.num, obj(k).frd{m}.den);
% %     m = m+1;
% %     obj(k).tfs(m)=tf(obj(k).frd{m}.num, obj(k).frd{m}.den);
% %     m=m+1;
% end

% ------------------------------------------------------------------------
% ----- Bode
% ------------------------------------------------------------------------
%%
%[files, match] = arrayf(@(x) x(indResp), cellfun(@strsplit, RAWS, {'_','_','_'}, 'UniformOutput', false));
%cols={'blue', 'green', 'red', 'cyan', 'magenta', 'black'};
delete(findall(f4,'type','axes'))
f4 = figure(4);
SUB=120;

% -------------- Plot ----------------------------------
hold on;
subplot(SUB+1);
    
for k=1:size(obj,2)
    B(k)=subplot(SUB+k);
    bd(k)=bodeplot(obj(k).frd{:});
    legend([obj(k).frd{1}.OutputName{1} ' / ' obj(k).frd{1}.InputName{1}],...
           [obj(k).frd{2}.OutputName{1} ' / ' obj(k).frd{1}.InputName{1}]);
    
end

opt = bodeoptions;
opt.FreqUnits = 'kHz';
opt.PhaseWrapping = 'off';
opt.Title.Interpreter = 'none';
opt.Grid = 'on';

v=get(B(1),'XLim');
%set(B(1),'XLim',[1, v(2)]);
%opt.YLim = [-200, 25];

opt.Title.String = obj(1).filename;
opt2 = opt;
opt2.Title.String = obj(2).filename;

%opt.XLim = [1, 1e5];

setoptions(bd(1),opt)
setoptions(bd(2),opt2)

%legend( cellfun(@strjoin, cellfun(@(x) x(end-2:end),...
%        sp(indResp), 'UniformOutput', false), 'UniformOutput', false));

% -------------- Plot ----------------------------------
% 
% opt.Title.String = { 'I_{FB}/I_{cmd}'};
% hold on;
% for k=1:length(tfCCi)
%     h5 = bodeplot(tfCCi{k}, cols{k}, opt);
% end
% grid on;
% legend( cellfun(@strjoin, cellfun(@(x) x(end-2:end),...
%         sp(indResp), 'UniformOutput', false), 'UniformOutput', false));


%%

% ------------------------------------------------------------------------
% ----------- tf Leistungstransistoren -----------------------------
% ------------------------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               1.653e15 s + 1.086e21
%  ------------------------------------------
%  s^3 + 1.944e07 s^2 + 1.959e15 s + 1.086e21
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Auf Ordnung 2 reduziert
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  0.1489 s^2 - 8.982e06 s + 2.217e15
%  ----------------------------------
%     s^2 + 2.252e07 s + 2.218e15
%
% Gpw=tf([0.15 -9e6 2.2e15],[1 2.25e7 2.2e15])
% Gcl=tf(1,[eval(param.Lc) eval(param.Rc)+eval(param.Rsh)])
% GF=tf(1, [1/100e3 1])
% PI=pid(5,2,0,0)
%%

% *********************************************************************
% *********************************************************************
%       Current controller: Auslegung
%
%       Gcu(s):     tf von UFB / Uin_coil
%       Gci(s):     tf von IFB / Uin_coil  
%       T1:         Zeitkonstante Strecke
%
%       Gpw(s):     tf der endstufe Uout_A/Uin6 (op zur Anst. der kompl.
%       T2:         Zeitkonstante endstufe
%
% *********************************************************************
% *********************************************************************
Kpsu = 1/16;    % fest
Kpsi = 10/16;   % fest
Kppw = 10;      % variabel

Gcu = tf(Kpsu, [106e-6 1]);
Gci = tf(Kpsu, [106e-6 1]);
Gpw = tf(Kppw, [450e-9 1]);
dyn = zpk([],[-1/450e-9 -1/106e-6], (1/450e-9*1/106e-6));
% Gcu*Gpw = Kpsu*Kppw*dyn

G1=Kppw*Kpsu*dyn;
opts = pidtuneOptions('PhaseMargin',60);

[Cp1, info1] = pidtune(G1,'P',opts);
[Cpi1, infoi1] = pidtune(G1,'PI',opts);

f3 = figure(3);
step(feedback(Cp1*G1,1));
hold all;
step(feedback(Cpi1*G1,1));
hold off;
grid on;
legend('Cp1','Cpi1');

f4 = figure(4);
h1=bodeplot(feedback(Cp1*G1,1));
hold all;
h2=bodeplot(feedback(Cpi1*G1,1));
legend('Cp1','Cpi1');
hold off;
setoptions(h1, 'FreqUnits', 'kHz');

f5 = figure(5);
opt = nyquistoptions;
opt.ShowFullContour='off';
nyquist(Cp1*G1, opt);
hold all;
nyquist(Cpi1*G1, opt);
hold off;
grid off;
legend('Cp1','Cpi1');

Cbase = pidtune(G1,'PI',opts);
pidtool(G1, Cbase);

%%
% *********************************************************************
% *********************************************************************
%       Current controller:
%       Inputs: Ic*     (coilcurrent command)
%               uuBEM   (Back emf voltage)
% *********************************************************************
% *********************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MISO current controller
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
load_system(SIMFILES{2});
%set_param( [SIMFILES{2} '/CopeMain'],'open','off');
set_param(SIMFILES{2}, 'MaxStep', '1e-4');

tfcc=linmod(SIMFILES{2});
tfcc.filename = SIMFILES{2};
uu = strrep(tfcc.InputName, [tfcc.filename '/'], '');
yy = strrep(tfcc.OutputName, [tfcc.filename '/'], '');
tfcc.InputName = uu;
tfcc.OutputName = yy;

P = ss(tfcc.a, tfcc.b, tfcc.c, tfcc.d, 'u', uu, 'y', yy);           % Kompletter Regelkreis 
[num, den] = ss2tf(tfcc.a, tfcc.b(:,1), tfcc.c, tfcc.d(:,1));
Gbem_y=tf(num, den, 'u', uu{1}, 'y', yy);
[num, den] = ss2tf(tfcc.a, tfcc.b(:,2), tfcc.c, tfcc.d(:,2));
Gic_y=tf(num, den,'u', uu{2}, 'y', yy);

% NUM=mat2cell(num, [ones(1, size(num,1))], size(num,2));
% Ptf = tf(NUM, den, 'u', uu, 'y', yy); 

[A, b, c, d] = sData(P);

step(Gic_y)
hold all;
step(Gbem_y)
hold off
%%

if 0
par = get_param(SIMFILES{1},'ObjectParameters');
names = fieldnames(par);
for k=1:length(SEARCH)
    ind{k}=find(~cellfun(@isempty, strfind(names,SEARCH{k})));
    if isempty(ind{k})
       add_param(SIMFILES{1}, SEARCH{k}, num2str(VAL(k)))
    else 
%        sprintf('Parameter %s existiert bereits\n', SEARCH{k})
       set_param(SIMFILES{1}, SEARCH{k}, num2str(VAL(k)))
    end
end



    simOut = sim(SIMFILES{1},'SimulationMode','normal',...
                'AbsTol','1e-5',...
                'MaxStep','1e-6',...
                'StopTime', '30e-3', ... 
                'ZeroCross','on', ...
                'AveTime','on','TimeAveName','tout', ...
                'AveState','on','StateAveName','xoutNew',...
                'SignalLogging','on','SignalLoggingName','logsout',...
                'AveOutput','on','OutputAveName','youtNew')

        to = simOut.get('xoutNew');
        h=sig.values;
        h(:,1);
        sig = simOut.get('xoutNew').signals;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%% Figure 5 %%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    f5=figure(5);
    SUB=510;

    for k=1:length(sig)
        subplot(SUB+k)
        plot(to.time , sig(1,k).values) 
    end
end
%%
% *********************************************************************
% *********************************************************************
%        closed loop SIMO- Model, CC and PID 
% *********************************************************************
% *********************************************************************

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SIMO system inkl. Input/Output- Namen aus komplettem Regelkreis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
load_system(SIMFILES{1});
%set_param( [SIMFILES{1} '/CopeMain'],'open','off');
set_param(SIMFILES{1}, 'MaxStep', '1e-4');
S = linmod(SIMFILES{1});
S.filename = SIMFILES{1};
uu = strrep(S.InputName, [S.filename '/'], '');
yy = strrep(S.OutputName, [S.filename '/'], '');
S.InputName = uu;
S.OutputName = yy;

simoa = ss(S.a, S.b, S.c, S.d, 'u', uu, 'y', yy);           % Kompletter Regelkreis 
[num, den] = ss2tf(S.a, S.b, S.c, S.d);

NUM=mat2cell(num, [ones(1, size(num,1))], size(num,2));
simob = tf(NUM, den, 'u', uu, 'y', yy); 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Figure 1 %%%%%%%%%%%%%
f1=figure(1);
SUB=110;
Tfin = 5e-3;

subplot(SUB+1);
step(simoa([1,3,5]), Tfin)
grid
title('Step response closed loop Simulink');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
        
% *********************************************************************
% *********************************************************************
%       Nur das Streckenmodell aus Simulink,
%       Regler in Matlab ertellen, verbinden ...
% *********************************************************************
% *********************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SIMO Plant model
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
load_system(SIMFILES{2});
%set_param( [SIMFILES{2} '/CopeMain'],'open','off');
set_param(SIMFILES{2}, 'MaxStep', '1e-4');

Plant=linmod(SIMFILES{2});
Plant.filename = SIMFILES{2};
uu = strrep(Plant.InputName, [Plant.filename '/'], '');
yy = strrep(Plant.OutputName, [Plant.filename '/'], '');
Plant.InputName = uu;
Plant.OutputName = yy;

P = ss(Plant.a, Plant.b, Plant.c, Plant.d, 'u', uu, 'y', yy);           % Kompletter Regelkreis 
[num, den] = ss2tf(Plant.a, Plant.b, Plant.c, Plant.d);

NUM=mat2cell(num, [ones(1, size(num,1))], size(num,2));
Ptf = tf(NUM, den, 'u', uu, 'y', yy); 

[A, b, c, d] = sData(P);
%%
% *********************************************************************
%       Some plant analyze
% *********************************************************************
% eigenvalues of the system matrix, A, (equivalent to the poles of the 
% transfer fucntion) determine the stability.
%
% det(s*I-A) = 0  -->  Eig(A)
%
poles = eig(A);
sprintf('Streckenpole über simulink und linmod berechnet:\n%.1f\n%.1f\n%.1f\n',poles(1:3))


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Eigener Zustandsraum der Strecke
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% JR'     % Rotor inertia
% KMT'    % Torque constant
% Rc'     % Coil resistance
% Lc'     % Coil inductance
% KFR'    % Rotor dynamic friction
% KTB'    % Torsion bar constant
% KBM'    % Back electromotive force
% Rsh'    % Current shunt resistor
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
param = loadGalvoParam(4);
va = fieldnames(param)';
v2 ={'syms' va{1:end}};

syms x1 x2 x3 xd1 xd2 xd3 u

for k=1:size(va,2)
    eval(['syms ' va{k}]);
end

A1 = [ -(Rc+Rsh)/Lc   -KBM/JR    0;     
         KMT/Lc      -KFR/JR  -KTB;     
           0          1/JR      0    ];

b1=[1; 0; 0];
c1=[0, 0, 1];
d1=0;
x=[x1; x2; x3];
xd=[xd1; xd2; xd3];

ds='---------------------------------------';
sprintf('%s\n\t\tSystem matrix A:\n%s', ds, ds)
pretty(A1) 
sprintf('%s\n\tEquation of motion:   dx = A*x+b*u \n%s', ds, ds)
pretty(A1*x+b*u) 
sprintf('\n\n%s\nState space after param substitution:\n%s', ds, ds)

s2c = struct2cell(param)';

P1 = ss( eval(subs(A1, va, s2c)),...
         eval(subs(b1, va, s2c)),...
         eval(subs(c1, va, s2c)),...
         eval(subs(d1, va, s2c)));

     
P1.InputName=P1.InputName
P1.OutputName=P1.OutputName{1};
P1     


%SIMO3 = tf(num, den, 'u', uu, 'y', yy(1)); 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

return

     
        
return        
        
        
% ---------------------------------------------------------------
% ----- Estimate tf of current controller, simulated by LTSpice
% ---------------------------------------------------------------
tfCC=idSpice(   'galvoCanner/OpAmp_LT1028_biased_currentsource.raw',...
                'I(Shunt2)',[0 2e6],0);
            
%-------------------------------
%---  PID tuning
%-------------------------------
opts = pidtuneOptions('PhaseMargin',40);
[tfCTRL,info] = pidtune(( tfCC*tfGv ),'pid',opts);

opts = pidtuneOptions('PhaseMargin',40);
[tfCTRL_f,info] = pidtune(( tfCC*tfGv ),'pidf',opts);

opts = pidtuneOptions('PhaseMargin',40);
C0 = pidstd(1,1,1); 
[tfCTRL_s,info] = pidtune(( tfCC*tfGv ),C0,opts);
        
        
        
        
% par=loadGalvoParam(4);
% pName = fieldnames(par);
% pValue = struct2cell(par);
% 
% str=[];
% for k=1:length(pName)
%    str = sprintf('%s''%s'',''%s'',',str,pName{k},pValue{k});
% end

% set_param(gcb, 'UserData',par);
% set_param(gcb, 'UserDataPersistent', 'on');
% 
% RootParNam = fieldnames (get_param(0,'ObjectParameters'));
% load_system(SIMFILES{2});
% ModelParNam = fieldnames (get_param(SIMFILES{2},'ObjectParameters'));
% GlobalParameterNames = setdiff (RootParNam,ModelParNam)

% return
% add_param(SIMFILES{2},'JR','6e-8','KMT','9.3e-3','Rc','1.5',...
%                       'Lc','160e-6','KFR','4e-12','KTB','1e-6',...
%                       'KBM','170e-6','Rsh','100e-3');
% delete_param(SIMFILES{2},'JR','KMT','Rc','Lc','KFR','KTB','KBM','Rsh');
% 
%param = loadGalvoParam(4);


return


% set_param('Galvo_sys_v12/GalvoModelVarSel', 'UserData',param);
% set_param('Galvo_sys_v12/GalvoModelVarSel', 'UserDataPersistent', 'on');

%%% Search for blocks with userdata
bl=find_system(0,'type','Block');
ind=find(~cellfun(@isempty,get_param(bl,'UserData')));

a=get(bl(ind),'Name')
b=get(bl(ind),'UserData')
a(:)
b{:}

open(SIMFILES{1});
return
paramCtrl=loadCtrlParam([]);
SimEnd = 30e-3;   
%open(SIMFILES{1});

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% kleiner workaround wegen Simulink SegFault %%%
%%% bei geöffneten Cope- views                %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ind=NaN;
ch = allchild(0);
names = get(ch,'Name');
if iCell(names)
    ind=find(~cellfun(@isempty, strfind(lower(names), 'Cope')));
else
    ind=find(strfind(lower(names), 'Cope'));
end
if ~isnan(ind)
    close(ch(ind));
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SIMO system inkl. Input/Output- Namen aus Blockdiagramm ableiten
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
load_system(SIMFILES{1});
S = linmod(SIMFILES{1});
S.filename = SIMFILES{1};
uu = strrep(S.InputName, [S.filename '/'], '');
yy = strrep(S.OutputName, [S.filename '/'], '');
S.InputName = uu;
S.OutputName = yy;

simoa = ss(S.a, S.b, S.c, S.d, 'u', uu, 'y', yy);           % Kompletter Regelkreis 
[num, den] = ss2tf(S.a, S.b, S.c, S.d);

NUM=mat2cell(num, [ones(1, size(num,1))], size(num,2));
simob = tf(NUM, den, 'u', uu, 'y', yy); 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Figure 1 %%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
f1=figure(1);
SUB=120;
Tfin = 2e-3;

subplot(SUB+1);
step(simoa, Tfin)



return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Eigener Zustandsraum der Strecke
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
a=[ -(CR + SHR)/CL, -BEM/RIN,   0;
    TRC/CL,         -FR/RIN,    -KTR;
    0               1/RIN,      0 ];
b=[1; 0; 0];
c=[0, 0, 1];
d=0;

[num, den] = ss2tf(a, b, c, d);
%SIMO3 = tf({num(1,:); num(2,:)}, den, 'u', uu, 'y', yy); 
SIMO3 = tf(num, den, 'u', uu, 'y', yy(1)); 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

return



[num, den] = ss2tf(GvS.a, GvS.b, GvS.c, GvS.d);
SIMO1 = tf({num(1,:); num(2,:)}, den, 'u', uu, 'y', yy); 

%[num, den] = linmod('GalvoModel_v31');

f15=figure(15);
SUB=130;
subplot(SUB+1);
step(SIMO1)

subplot(SUB+2);
step(SIMO2);

subplot(SUB+3);
step(SIMO3);

return

% AmpleTime = 1;                             % Symbolzeit
% simin.time = [0:AmpleTime:simulationTime]; % Zeitvektor

        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% kleiner workaround wegen Simulink SegFault %%%
%%% bei geöffneten Cope- views                %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
open_bd = find_system('type', 'block_diagram');
ind = find(strcmp(open_bd, 'simulink'));
if ind > 0
    open_bd(ind)=[];
end 

ret=[];
for k=1:length(SIMFILES)
%     ind(k)=~isempty(strfind(open_bd, SIMFILES{k}))
% 
%     if isempty(ind)
%         disp('blockdiagram not found')
%     else

    if isempty(ret)         
        ret = questdlg( 'Close blockdiagrams?', ...
                        'Simulink workaround', ...
                        'Yes', 'No', 'No');
    end
        if strcmp(ret, 'Yes') 
%            Ave_system(open_bd(ind));
            close_system(open_bd);
        end
    end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

param=loadGalvoParam([]);
paramCtrl=loadCtrlParam([]);

CurrentController=Simulink.Variant ('Variant_CC == 1');
NO_CurrentController=Simulink.Variant ('Variant_CC == 0');
Variant_CC=1;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SIMO system inkl. Input/Output- Namen aus Blockdiagramm ableiten
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Gv = linmod('GalvoModel_v31_19082014');
Gv.filename = 'GalvoModel_v31_19082014';
uu = strrep(Gv.InputName, [Gv.filename '/'], '');
yy = strrep(Gv.OutputName, [Gv.filename '/'], '');
Gv.InputName = uu;
Gv.OutputName = yy;

G=ss(Gv.a,Gv.b, Gv.c, Gv.d);



return;


vKp_cc = [0.06 0.1 0.5];

legstr=[];
for k=1:3
%    Kp_cc = Kp_cc + 3.33*(k-1)
    paramCtrl.Kp_cc = sprintf('%f',vKp_cc(k));
    legstr = [legstr sprintf('Kp_cc = %s:',paramCtrl.Kp_cc)];

    [num, den] = linmod(SIMFILES{2});   % v31 inkl. cc mit unterCh.
    Gv31cc(k,:) = tf(num,den);          % stromverstärkungen
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SIMO system inkl. Input/Output- Namen aus Blockdiagramm ableiten
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
GvS = linmod('GalvoModel_v31');
GvS = linmod('GalvoModel_v31');
GvS.filename = 'GalvoModel_v31';
uu = strrep(GvS.InputName, [GvS.filename '/'], '');
yy = strrep(GvS.OutputName, [GvS.filename '/'], '');
GvS.InputName = uu;
GvS.OutputName = yy;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SIMO- tf aus linmod-struct (Zustandsraum)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[num, den] = ss2tf(GvS.a, GvS.b, GvS.c, GvS.d);
SIMO1 = tf({num(1,:); num(2,:)}, den, 'u', uu, 'y', yy); 

[num, den] = linmod('GalvoModel_v31');
SIMO2 = tf({num(1,:); num(2,:)}, den, 'u', uu, 'y', yy); 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Eigener Zustandsraum
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
a=[ -(CR + SHR)/CL, -BEM/RIN,   0;
    TRC/CL,         -FR/RIN,    -KTR;
    0               1/RIN,      0 ];
b=[1; 0; 0];
c=[0, 0, 1];
d=0;

[num, den] = ss2tf(a, b, c, d);
%SIMO3 = tf({num(1,:); num(2,:)}, den, 'u', uu, 'y', yy); 
SIMO3 = tf(num, den, 'u', uu, 'y', yy(1)); 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

f15=figure(15);
SUB=130;
subplot(SUB+1);
step(SIMO1)

subplot(SUB+2);
step(SIMO2);

subplot(SUB+3);
step(SIMO3);

%cellfun(@open, SIMFILES)

return 


f1=figure(1);
hold all;
step(Gv31cc(1,:))
step(Gv31cc(2,:))
step(Gv31cc(3,:))
hold off;
legend(strsplit(legstr,':'))


return

open(SIMFILES{1})

t2=linmod(SIMFILE);
t2.filename=SIMFILE;
t2.InputName=strrep(t2.InputName, t2.filename, '');
%[num2, den2] = linmod('GalvoModel_v3_diCret_simo');
[num den]=ss2tf(t2.a,t2.b,t2.c,t2.d, 1);
sys2(:,2)=fieldnames(t2);
sys2(1,1)={t2};
sys2(:,3)=struct2cell(t2);

if size(num,1) == 1
    Gv=tf(num, den) %,...
end
if size(num,1) == 2
    Gv=tf({num(1,:); num(2,:)}, den) %,...
end
if size(num,1) == 2
    Gv=tf({num(1,:); num(2,:); num(3,:)}, den) %,...
end
%        'OutputName',strrep(sys2{1}.OutputName, t2.filename, '' ),...
%        'InputName',sys2{1}.InputName);
%[y1, tt]=step(Gv,linspace(0,10e-3,1000));
f2=figure(2);
step(Gv)
legend('Gv')



% 
% tt1(:,1)=tt;
% tt1(:,2)=tt;
% tt1(:,3)=tt;
% 
% hold on;
% subplot(311)
% plot(tt,y1(:,1))
% subplot(312)
% plot(tt,y1(:,2))
% subplot(313)
% plot(tt,y1(:,3))
% hold off
% ---------------------------------------------------------------
% ----- Estimate tf of current controller, simulated by LTSpice
% ---------------------------------------------------------------
%   tfCC=idSpice(   'galvoCanner/OpAmp_LT1028_biased_currentsource.raw',...
%                  'I(Shunt2)',[0 2e6],[3,2],0);


