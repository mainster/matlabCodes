function  pzgui(ReqStr)
% Creates and services the continuous-time
% pole/zero map graphical user interface (pzgui),
% which is the main "front panel" of the PZGUI tool.

% The following copyrighted m-files comprise the PZGUI tool:
%    ** The contents of these files may not be included **
%    **  in any other program without explicit written  **
%    **    consent from the author, Mark A. Hopkins     **
%     bodepl.m        pzg_bodex.m     pzg_islogx.m     pzg_seltxt.m
%     contents.m      pzg_box.m       pzg_isunwrp.m    pzg_tools.m
%     contourpl.m     pzg_c2d.m       pzg_lims.m       pzg_tpwr.m
%     dpzgui.m        pzg_cntr.m      pzg_maprep.m     pzg_txan.m
%     dupdatep.m      pzg_cphndl.m    pzg_menu.m       pzg_unre.m
%     figopts.m       pzg_d2c.m       pzg_moda.m       pzg_unwrap.m
%     fr_disp.m       pzg_disab.m     pzg_onoff.m      pzg_updtfilt.m
%     freqserv.m      pzg_efmt.m      pzg_pfesim.m     pzg_xtrfrq.m
%     gainfilt.m      pzg_err.m       pzg_prvw.m       pzgcalbk.m
%     helpserv.m      pzg_errvis.m    pzg_ptr.m        pzgui.m
%     ldlgfilt.m      pzg_fndo.m      pzg_recovr.m     pzmvserv.m
%     nicholpl.m      pzg_gle.m       pzg_reptxt.m     resppl.m
%     nyqistpl.m      pzg_grid.m      pzg_res.m        rlocuspl.m
%     pidfilt.m       pzg_inzpk.m     pzg_rsppfe.m     sensplot.m
%     pz_move.m       pzg_isdby.m     pzg_rss.m        updatepl.m
%     pzg_bkup.m      pzg_ishzx.m     pzg_scifmt.m     updtpzln.m
%                     pzg_islink.m    pzg_sclpt.m      zmimntcpt.m
% (c) 1996 - 2014
%    by Professor Mark A. Hopkins, Ph.D.
%       Electrical and Microelectronic Engineering
%       Rochester Institute of Technology
%       Rochester NY, USA 14623        Email:  mark.hopkins@rit.edu
%
% SHAREWARE INFORMATION:
%               FREE, IF USED ONLY FOR EDUCATIONAL PURPOSES.
%   Otherwise:
%    (corporations, companies, and other for-profit users) 
%    Individual licenses -- US$200 per computer
%    Site license -- US$2000 per industrial site, any number of users
%    Make check payable to "Mark A. Hopkins", and remit to address above
% ----------------------------------------------------------------------
global PZG
evalin('base','global PZG')

pwmsgbox_h = -1;
if isempty(PZG) || ~isfield( PZG,'plot_h') ...
  ||( numel(PZG(1).plot_h) < 12 )
  CT_PZGUI = findobj( allchild(0),'type','figure', ...
      'name','Continuous-Time P/Z Map G.U.I.');
  DT_PZGUI = findobj( allchild(0),'type','figure', ...
      'name','Discrete-Time P/Z Map G.U.I.');
  if ~isempty(CT_PZGUI) || ~isempty(DT_PZGUI)
    pzg_recovr
  end
end

if ( nargin > 0 ) && ischar(ReqStr)
  local_service_request(ReqStr);
  return
elseif ~nargin && isempty(gcbf)
  pzg_onoff(1);
end

CT_PZGUI = pzg_fndo( 1, 12,'fig_h');
if isempty(CT_PZGUI) || ~isappdata(CT_PZGUI,'hndl')
  CT_PZGUI = findobj( allchild(0),'type','figure', ...
    'name','Continuous-Time P/Z Map G.U.I.');
  delete(CT_PZGUI)
  pwmsgbox_h = ...
    msgbox({'Please wait while the Continuous-Time PZGUI interface'; ...
      'is constructed, and the various plot data are initialized.';' '}, ...
     'pzgui Advisory');
  drawnow
end
DT_PZGUI = pzg_fndo( 2, 13,'fig_h');


if isempty(PZG)
  % Define the continuous-time parameters.
  PZG(1).PZGUIname = 'Continuous-Time P/Z Map G.U.I.';
  PZG(1).Domain = 's';
  PZG(1).Selection = [1 1];
  PZG(1).FrqSelNdx = [];
  PZG(1).NyqSelNdx = [];

  PZG(1).PureDelay = 0;
  PZG(1).Ts = 0.005;
  PZG(1).Gain = 15;
  PZG(1).ZeroLocs = -70;
  PZG(1).PoleLocs = [ -3+31j; -3-31j ];
  PZG(1).N = [];
  PZG(1).D = [];
  PZG(1).pade.Z = [];
  PZG(1).pade.P = [];
  PZG(1).pade.K = 1;
  PZG(1).pade.N = 1;
  PZG(1).pade.D = 1;

  PZG(1).DCgain = ...
    real( PZG(1).Gain * prod(-PZG(1).ZeroLocs) ./ prod(-PZG(1).PoleLocs) );

  PZG(1).recompute_frf = 1;
  PZG(1).BodeFreqs = [];
  PZG(1).BodeMag = [];
  PZG(1).BodePhs = [];
  PZG(1).TFEFreqs = [];
  PZG(1).TFEMag = [];
  PZG(1).TFEPhs = [];

  modalss = pzg_moda( 1, 1, 1, 0,'', 1 );
  if ~isempty(modalss)
    PZG(1).CLPoleLocs = tzero( modalss.a, modalss.b, modalss.c, modalss.d+1 );
    PZG(1).CLZeroLocs = PZG(1).ZeroLocs;
    PZG(1).CLGain = PZG(1).Gain;
  else
    PZG(1).CLGain = PZG(1).Gain;
    PZG(1).CLZeroLocs = PZG(1).ZeroLocs;
    PZG(1).N = [];
    PZG(1).D = [];
    PZG(1).Dc = ...
      PZG(1).Gain*[ zeros(1,numel(PZG(1).D)-numel(PZG(1).N)) PZG(1).N ] ...
      +PZG(1).D;
    PZG(1).CLPoleLocs = roots(PZG(1).Dc);
  end
  PZG(1).CLBodeFreqs = [];
  PZG(1).CLBodeMag = [];
  PZG(1).CLBodePhs = [];

  % Define the discrete-time parameters.
  PZG(2).PZGUIname = 'Discrete-Time P/Z Map G.U.I.';
  PZG(2).Domain = 'z';
  PZG(2).Selection = [1 1];
  PZG(2).FrqSelNdx = [];

  PZG(2).PureDelay = 0;
  PZG(2).Ts = PZG(1).Ts;
  PZG(2).Gain = 0.086556451342561;
  PZG(2).ZeroLocs = [ 0.701836874287323 ]; %#ok<NBRAK>
  PZG(2).PoleLocs = [ 0.973301955431202 + 0.152081679048812i; ...
                      0.973301955431202 - 0.152081679048812i ];
  PZG(2).N = [];
  PZG(2).D = [];

  PZG(2).DCgain = ...
    real( PZG(2).Gain * prod(1-PZG(2).ZeroLocs) ./ prod(1-PZG(2).PoleLocs) );

  PZG(2).recompute_frf = 1;
  PZG(2).BodeFreqs = [];
  PZG(2).BodeMag = [];
  PZG(2).BodePhs = [];
  PZG(2).CLBodeFreqs = [];
  PZG(2).TFEMag = [];
  PZG(2).TFEPhs = [];

  PZG(2).CLGain = PZG(2).Gain;
  PZG(2).CLZeroLocs = PZG(2).ZeroLocs;
  PZG(2).N = [];
  PZG(2).D = [];
  PZG(2).Dc = [];
  PZG(2).CLPoleLocs = roots(PZG(2).Dc);
  PZG(2).CLBodeMag = [];
  PZG(2).CLBodePhs = [];
  PZG(2).TFEFreqs = [];

  % Define the various plot names.
  PZG(1).OLBodeName = 'Continuous-Time Open-Loop';
  PZG(2).OLBodeName = 'Discrete-Time Open-Loop';

  PZG(1).CLBodeName = 'Continuous-Time Closed-Loop';
  PZG(2).CLBodeName = 'Discrete-Time Closed-Loop';

  PZG(1).NicholsName = 'Continuous-Time System Nichols Chart';
  PZG(2).NicholsName = 'Discrete-Time System Nichols Chart';

  PZG(1).RootLocusName = 'Continuous-Time System Root Locus';
  PZG(2).RootLocusName = 'Discrete-Time System Root Locus';

  PZG(1).OLTimeRespName = 'Continuous-Time Open-Loop Time Response';
  PZG(2).OLTimeRespName = 'Discrete-Time Open-Loop Time Response';

  PZG(1).CLTimeRespName = 'Continuous-Time Closed-Loop Time Response';
  PZG(2).CLTimeRespName = 'Discrete-Time Closed-Loop Time Response';
  PZG(1).NyquistName = 'Continuous-Time System Nyquist Plot';
  PZG(2).NyquistName = 'Discrete-Time System Nyquist Plot';
  PZG(1).SensPlotName = 'Continuous-Time Closed-Loop Output Sensitivity';
  PZG(2).SensPlotName = 'Discrete-Time Closed-Loop Output Sensitivity';
  PZG(1).NyqContourPlotName = 'Continuous-Time Nyquist Contour';
  PZG(2).NyqContourPlotName = 'Discrete-Time Nyquist Contour';

  PZG(1).DefaultBackgroundColor = 'k';
  PZG(2).DefaultBackgroundColor = 'k';

  PZG(1).TFEFreqs = [];
  PZG(1).TFEMag = [];
  PZG(1).TFEPhs = [];
  PZG(2).TFEFreqs = [];
  PZG(2).TFEMag = [];
  PZG(2).TFEPhs = [];
  PZG(1).NegSelect = 0;
  PZG(2).NegSelect = 0;
  PZG(1).pzg_show_frf_computation = 0;
  PZG(2).pzg_show_frf_computation = 0;
  PZG(1).NyqSelNdx = [];
  PZG(2).NyqSelNdx = [];
  PZG(1).DefaultBackgroundColor = 'k';
  PZG(2).DefaultBackgroundColor = 'k';
end

if strcmp('w',PZG(1).DefaultBackgroundColor)
  foreground_color = 'k';
  checkbox_foreground_color = [ 0 0 0 ];
  checkbox_background_color = [ 1 1 1 ];
  checkbox_background_color2 = [ 1 1 1 ];
else
  foreground_color = 'w';
  checkbox_foreground_color = [ 1 1 1 ];
  checkbox_background_color = [ 0 0 0 ];
  checkbox_background_color2 = [ 0 0 0 ];
end

for k = 1:2
  if ~isfield(PZG(k),'plot_h')
    PZG(k).plot_h = cell(14,1);
  elseif numel(PZG(k).plot_h) < 14
    PZG(k).plot_h = ...
      [ PZG(k).plot_h(:); cell( 14-numel(PZG(k).plot_h), 1 ) ];
  elseif size(PZG(k).plot_h,2) ~= 1
    PZG(k).plot_h = PZG(k).plot_h(:);
  end
end

if ~isempty(CT_PZGUI)
  temp0 = get(CT_PZGUI,'UserData');
  if isappdata( CT_PZGUI,'hndl')
    hndl = getappdata( CT_PZGUI,'hndl');
  end
else
  hndl = [];
  temp0 = [];
end

ColorOrder = [ 1 0.8 0.4; 1 0 1; 0.4 0.8 1; 1 0 0; 0 1 0; 0 0 1];

if ~isfield( PZG(1),'PureDelay')
  PZG(1).PureDelay = 0;
  PZG(2).PureDelay = 0;
end

% Refresh the contour data, if necessary.
if ~isequal( PZG(1).recompute_frf, 0 ) ...
  || ~isfield( PZG(1),'cntr_data') ...
  || isempty( PZG(1).cntr_data ) ...
  ||~isstruct( PZG(1).cntr_data ) ...
  ||~isfield( PZG(1).cntr_data,'contour_freq')
  PZG(1).recompute_frf = 0;
  pzg_cntr(1);
  pzg_bodex(1);
end

pz_markersize = 14;
pz_linewidth = 2.5;
if numel(PZG(1).PoleLocs) > 20
  pz_markersize = 10;
  pz_linewidth = 2;
end

new_ct_figure = 0;
if isempty(CT_PZGUI)
  % Check that the Control System Toolbox is available.
  ver_str = ver;
  if isstruct(ver_str)
    ctrl_license = [];
    for k = 1:numel(ver_str)
      if isequal( ver_str(k).Name,'Control System Toolbox') ...
        ||any( strfind( lower(ver_str(k).Name),'control system') )
        ctrl_license(end+1) = k; %#ok<AGROW>
      end
    end
    if isempty(ctrl_license)
      if ishandle(pwmsgbox_h)
        delete(pwmsgbox_h)
      end
      errdlg_h = ...
        errordlg( ...
          {'PZGui cannot function without the Control System Toolbox.'; ...
           'The Control System Toolbox does not appear to be licensed.'; ...
           ' '; ...
           '  ... Exiting PZGUI'; ...
           ' ';'    Click "OK" to continue ...';' '}, ...
          'PZGui Requires Control System Toolbox','modal');
      uiwait(errdlg_h)
      return
    end
  end
  
  ScrSize = get(0,'ScreenSize');
  norm_gui_ohead = [10 55]./ScrSize(3:4);
  if ~isempty(DT_PZGUI)
    DT_Hndls = get(DT_PZGUI,'UserData');
    % Try to arrange the two main GUIs so they're both visible.
    dtpzgui_pos = get( DT_PZGUI,'position');
    ctpzgui_pos = dtpzgui_pos;
    if ( 1-sum(dtpzgui_pos([1,3])) ) > ( dtpzgui_pos(3)+2*norm_gui_ohead(1) )
      ctpzgui_pos(1) = ...
        dtpzgui_pos(1) + 1.02*dtpzgui_pos(3)+norm_gui_ohead(1);
    else
      ctpzgui_pos(1) = ...
        max( 0.01, dtpzgui_pos(1)-1.02*dtpzgui_pos(3)-norm_gui_ohead(1) );
    end
    ScrPos = ctpzgui_pos;
  else
    ScrPos = [];
  end
  
  new_ct_figure = 1;
  CT_PZGUI = ...
    figure( ...
      'units','pixels', ...
      'Position', [ScrSize(3:4)-[500 435] 495 385], ...
      'Name', PZG(1).PZGUIname, ...
      'Color', PZG(1).DefaultBackgroundColor, ...
      'menubar','figure', ...
      'numbertitle','off', ...
      'integerhandle','off', ...
      'handlevisibility','callback', ...
      'dockcontrols','off', ...
      'Interruptible','On', ...
      'tag','PZGUI main user interface', ...
      'windowbuttonupfcn', ...
        ['global PZMoving pzg_drawbox,' ...
         'PZMoving=0;' ...
         'pzg_drawbox.button_down=0;' ...
         'clear pzg_drawbox PZMoving,' ...
         'pzg_box([],1)'], ...
      'CloseRequestFcn', ...
        ['global PZG;' ...
         'temp_helph=pzg_fndo(1,(12:13),''pzg_help_checkbox'');' ...
         'for temp_kh=1:numel(temp_helph),' ...
           'if isequal(1,ishandle(temp_helph(temp_kh))),' ...
             'set(temp_helph(temp_kh),''Value'',0,' ...
                '''foregroundcolor'',' ... 
                    '1-get(get(temp_helph(temp_kh),''parent''),''color''),' ...
                '''fontweight'',''normal'');' ...
           'end,' ...
         'end,' ...
         'temp_link_h=pzg_fndo(2,13,''LinkCheckbox'');' ...
         'if~isempty(temp_link_h),' ...
           'set(temp_link_h,''value'',0,' ...
               '''backgroundcolor'',PZG(1).DefaultBackgroundColor);' ...
         'end,' ...
         'temp_link_h=pzg_fndo(2,13,''LinkMethod'');' ...
         'if~isempty(temp_link_h),' ...
           'set(temp_link_h,' ...
                '''backgroundcolor'',PZG(2).DefaultBackgroundColor);' ...
         'end,' ...
         'if isfield(PZG(1),''frcomp_fig'')' ...
            '&&~isempty(PZG(1).frcomp_fig)' ...
            '&&isequal(1,ishandle(PZG(1).frcomp_fig)),' ...
            'delete(PZG(1).frcomp_fig),' ...
         'end,' ...
         'PZG(1).frcomp_fig=[];' ...
         'updtpzln(''s'');' ...
         'pzg_seltxt(1,[],[],0);' ...
         'temp_boxh=pzg_fndo(2,13,''draw_box_checkbox'');' ...
         'if~isempty(temp_boxh),' ...
           'set(temp_boxh,''value'',0);' ...
           'set(get(temp_boxh,''parent''),''pointer'',''arrow'');' ...
         'end,' ...
         'temp_boxh=pzg_fndo((1:2),(10:13),''pzgbox'');' ...
         'for temp_kbox=1:numel(temp_boxh),' ...
           'if~isempty(temp_boxh(temp_kbox)),' ...
             'set(temp_boxh(temp_kbox),''visible'',''off'');' ...
           'end,' ...
         'end,' ...
         'clear global pzg_drawbox,' ...
         'PZG(1).plot_h{12}=[];' ...
         'PZG(2).plot_h{12}=[];' ...
         'pzg_bkup,' ...
         'clear temp_link_h temp_boxh temp_kbox temp_helph temp_kh;' ...
         'closereq']);
  set( CT_PZGUI,'units','normalized');
  if ( numel(ScrPos) == 4 ) && ( max(ScrPos) <= 1 ) ...
    &&( min(ScrPos) >= 0 )
    set( CT_PZGUI,'position', ScrPos );
  end

  % Put an "Options" menu item in the figure's menubar.
  opt_menu_h = ...
    uimenu('parent', CT_PZGUI, ...
           'label', 'PZGUI OPTIONS', ...
           'tag','pzgui_options_menu');
  setappdata( CT_PZGUI,'hndl', hndl )
  pzg_menu( opt_menu_h,'s');
  hndl = getappdata( CT_PZGUI,'hndl');
  
  hndl.plot_name = get( CT_PZGUI,'name');
  hndl.dom_ndx = 1;
  hndl.ploth_ndx = 12;
  
  % If pzgui path is not part of the Matlab path, add it at the end.
  whichpzg = which('pzgui');
  if ~isempty(whichpzg)
    pzgpath = fileparts(whichpzg);
    if isempty( strfind( path, pzgpath ) )
      try                                       %#ok<TRYNC>
        evalin('base',['addpath(''' pzgpath ''',''-end'');'])
      end
    end
  end
  
  temp0 = zeros(95,2);
  CTgca = axes('parent',CT_PZGUI, ...
               'nextplot','add', ...
               'xgrid','on', ...
               'ygrid','on', ...
               'tag','pzg pzmap plot axes');
  temp0(1,1) = CTgca;
  hndl.ax = CTgca;
  hndl.ax_title = get( CTgca,'title');
  hndl.ax_xlabel = get( CTgca,'xlabel');
  hndl.ax_ylabel = get( CTgca,'ylabel');
  
  if strcmp( PZG(1).DefaultBackgroundColor,'k')
    set( CTgca,'Color','k','XColor','w','YColor','w','ColorOrder',ColorOrder );
  else
    set( CTgca,'Color','w','XColor','k','YColor','k','ColorOrder',ColorOrder );
  end
  if ScrSize(3) > 1024
    set( CTgca,'Position',[0.12 0.23 0.66 0.67], ...
        'Interruptible','On', ...
        'FontSize',10 );
  else
    set( CTgca,'Position',[0.12 0.23 0.66 0.67], ...
        'Interruptible','On', ...
        'FontSize',8 );
  end
  set( hndl.ax_xlabel,'string','Real(S), rad/s', ...
      'Color', 1-get(CTgca,'color') );
  set( hndl.ax_ylabel,'string','Imag(S), rad/s', ...
      'Color', 1-get(CTgca,'color') );
  set( hndl.ax_title, ...
      'string','     Open-Loop S-plane P/Z Map           ', ...
      'Color', 1-get(CTgca,'color') )
    
  if isempty(PZG(1).ZeroLocs)
    temp_z=0;
    tempVis='Off';
  else
    temp_z=PZG(1).ZeroLocs;
    tempVis='On';
  end
  temp0(3,1) = ...
    plot( real(temp_z),imag(temp_z),'ro', ...
         'parent', CTgca, ...
         'MarkerSize', pz_markersize-2, ...
         'LineWidth', pz_linewidth, ...
         'Visible',tempVis, ...
         'Tag','PZG S-Plane Zeros');
  hndl.PZG_Zeros_line = temp0(3,1);
  if isempty(PZG(1).ZeroLocs)
    set( temp0(3,1),'Xdata',[],'Ydata',[],'Visible','On')
  end
  hndl = pzg_maprep( PZG(1).ZeroLocs,'zero', hndl );
  
  if isempty( PZG(1).PoleLocs )
    temp_p=0;
    tempVis='Off';
  else
    temp_p=PZG(1).PoleLocs;
    tempVis='On';
  end
  temp0(2,1) = ...
      plot(real(temp_p),imag(temp_p),'gx', ...
          'parent', CTgca, ...
          'Interruptible','On', ...
          'MarkerSize', pz_markersize, ...
          'LineWidth', pz_linewidth, ...
          'Visible',tempVis,'Tag','PZG S-Plane Poles');
  hndl.PZG_Poles_line = temp0(2,1);
  if isempty(PZG(1).PoleLocs)
    set( temp0(2,1),'Xdata',[],'Ydata',[],'Visible','On')
  end
  hndl = pzg_maprep( PZG(1).PoleLocs,'pole', hndl );
   
  HelpString = {'        THE INTERACTIVE POLE/ZERO MAP' ' ' ...
          ' This part of the G.U.I. panel is a pole/zero' ...
          ' map in which the locations of the poles' ...
          ' and zeros can be manipulated interactively,' ...
          ' by using the mouse.' ' ' ...
          ' Position the mouse cursor on top of the' ...
          ' pole or zero you want to move, and you should' ...
          ' see the mouse cursor change to a "hand".' ...
          ' (If poles and zeros are too close together to' ...
          ' be easily resolved, the cursor will not change.)' ...
          ' Then click the left or right mouse-button' ...
          ' to DRAG-AND-DROP it to a new location' ...
          ' (i.e., hold down the mouse-button while you' ...
          ' move the cursor to the intended location,' ...
          ' then let up the mouse button).' ' ' ...
          ' If you move a complex pole or zero, its' ...
          ' complex conjugate automatically moves with it.' ' ' ...
          ' Depending upon the speed of your computer' ...
          ' -- and the size of the model --' ...
          ' there can be a noticeable delay as the pole ' ...
          ' or zero tries to follow the mouse cursor.' ' ' ...
          ' After the mouse button is released,' ...
          ' all plots automatically recomputed & updated.'}';
  set( CTgca,'UserData', HelpString );

  dt_str = date;
  n = [ 40 99 41 32 77 46 65 46 72 111 112 107 105 110 ...
       115 44 32 49 57 57 54 45 double(dt_str(end-3:end)) ];
  HelpString = {'PZGui is Copyrighted' ...
    ['(c) 1996-' dt_str(end-3:end) ] ...
    '   Professor Mark A. Hopkins, Ph.D.' ...
    '     Electrical and Microelectronic Engr.' ...
    '     79 Lomb Memorial Blvd.' ...
    '     Rochester Institute of Technology' ...
    '     Rochester, New York  14623' ...
    '     mark.hopkins@rit.edu' ' '...
    ' The contents of these files may not be' ...
    ' included in any other program without explicit' ...
    ' written consent from the author, Mark A. Hopkins.' ...
    ' ' 'SHAREWARE DETAILS:' ' ' ... 
    '     FREE,  if used ONLY for educational purposes.' ' ' ...
    ' Otherwise:' '  (corporations, companies, other for-profits)' ...
    '   > Individual licenses -- US$200 per computer' ... 
    '   > Site license -- US$2000 per industrial site,' ...
    '        any number of users at that site.' ...
    '   Make check payable to: "Mark A. Hopkins",' ...
    '   and remit to the address listed above.' }';
  uicontrol(CT_PZGUI,'Style','pushbutton', ...
      'Units','normalized', ...
      'Position', [-0.005 0.970 0.190 0.035], ...
      'String', char(n), ...
      'fontsize', 8, ...
      'BackgroundColor', get(CT_PZGUI,'color'), ...
      'ForegroundColor', 1-get(CT_PZGUI,'color'), ...
      'tooltipstring', char(n), ...
      'UserData', HelpString, ...
      'Callback', ...
        ['temp_dlg_h=findobj(allchild(0),''name'',' ...
            '''PZGui Copyright Info'');' ...
         'if isempty(temp_dlg_h),' ...
           'temp_dlg_h=msgbox(get(gcbo,''UserData''),' ...
             '''PZGu Ciopyright Info'');' ...
           'temp_pos=get(temp_dlg_h,''position'');' ...
           'temp_pos(2)=0.6*temp_pos(2);' ...
           'set(temp_dlg_h,''position'',temp_pos);' ...
         'else,' ...
           'figure(temp_dlg_h);' ...
         'end,' ...
         'clear temp_pos temp_dlg_h'] );

  HelpString = ...
   {'FOR HELP,' 'MOVE MOUSE-CURSOR TO AN OBJECT' ' ' ...
    'PZGui is copyrighted, (c)1996-2014:' ...
    'by Professor Mark A. Hopkins, Ph.D.' ...
    '  Electrical and Microelectronic Eng.' ...
    '  79 Lomb Memorial Blvd.' ...
    '  Rochester Institute of Technology' ...
    '  Rochester, New York  14623' ...
    '  mark.hopkins@rit.edu' ' '...
    ' The contents of these files may not be' ...
    ' included in any other program without explicit' ...
    ' written consent from the author, Mark A. Hopkins.' ...
    ' ' 'SHAREWARE DETAILS:' ... 
    ' FREE, if used ONLY for educational purposes.' ' ' ...
    ' Otherwise (corporations, companies, other for-profits):' ...
    ' Individual licenses may be purchased for U.S. $200' ... 
    ' per computer, or a site license may be purchased' ... 
    ' for U.S. $2000.  A site license is good for' ... 
    ' any number of machines at one industrial site.' ' ' ...
    ' Make check payable to: "Mark A. Hopkins".' ...
    ' and remit to the address listed above.' }';
  temp0(9,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'String','Help', ...
      'Value', 0, ...
      'Units','normalized', ...
      'Position',[0.905 0.065 0.09 0.04], ...
      'HorizontalAlignment','center', ...
      'BackgroundColor', checkbox_background_color2, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'TooltipString','open a context-sensitive "help" window', ...
      'tag','pzg help checkbox', ...
      'Callback', ...
         ['if get(gcbo,''Value''),' ...
            'set(gcbo,''foregroundcolor'',''r'',' ...
                 '''fontweight'',''bold''),' ...
            'helpserv(get(gcbf,''Name''));' ...
          'else,' ...
            'set(gcbo,''foregroundcolor'',1-get(gcbf,''color''),' ...
                 '''fontweight'',''normal''),' ...
          'end;'], ...
      'UserData',HelpString );
  hndl.pzg_help_checkbox = temp0(9,2);

  HelpString = {' CENTER THE POLE/ZERO PLOT ' ...
                ' ' ...
                ' Center the pole/zero plot ' ...
                ' and scale it to ' ...
                ' the poles and zeros ' ...
                ' that are defined '};
  uicontrol(CT_PZGUI,'style','pushbutton', ...
                'units','normalized', ...
                'position',[ 0.82 0.065 0.07 0.04 ], ...
                'string','Center', ...
                'UserData', HelpString, ...
                'TooltipString','center on the main s-plane poles and zeros', ...
                'callback', 'zmintcpt(''open zoom'',gcbf);');

  HelpString = {'HOLD THE DC-GAIN FIXED (CONSTANT)'; ...
                ' '; ...
                'When this box is checked, the DC gain of'; ...
                'the transfer function is kept at a constant'; ...
                ' value, even as poles and zeros are changed.'; ...
                ' '; ...
                'If any poles or zeros are located at s = 0,'; ...
                'the gain of the appropriate derivative'; ...
                'of the transfer function is held constant.'};
  hndl.Fix_DC_checkbox = ...
    uicontrol(CT_PZGUI,'style','checkbox', ...
                'units','normalized', ...
                'position',[0.895 0.115 0.104 0.04], ...
                'string','Fix DC', ...
                'value', 0, ...
                'tag','C-T Fix DC checkbox', ...
                'UserData', HelpString, ...
                'BackgroundColor', checkbox_background_color2, ...
                'ForegroundColor', checkbox_foreground_color, ...
                'TooltipString','keep DC gain constant when P/Z are changed', ...
                'callback', ...
                  ['pzg_onoff(0);' ...
                   'drawnow,' ...
                   'try,' ...
                     'global PZG,' ...
                     'if get(gcbo,''value''),' ...
                       'PZG(1).DCgain=PZG(1).Gain;' ...
                       'if~isempty(PZG(1).PoleLocs==0)' ...
                         '&&any(PZG(1).PoleLocs~=0),' ...
                         'temp_nz_ndx=find(PZG(1).PoleLocs~=0);' ...
                         'PZG(1).DCgain=PZG(1).DCgain' ...
                           '/prod(-PZG(1).PoleLocs(temp_nz_ndx));' ...
                       'end,' ...
                       'if~isempty(PZG(1).ZeroLocs)' ...
                         '&&any(PZG(1).ZeroLocs~=0),' ...
                         'temp_nz_ndx=find(PZG(1).ZeroLocs~=0);' ...
                         'PZG(1).DCgain=PZG(1).DCgain' ...
                           '*prod(-PZG(1).ZeroLocs(temp_nz_ndx));' ...
                       'end,' ...
                       'PZG(1).DCgain=real(PZG(1).DCgain);' ...
                     'else,' ...
                       'PZG(1).DCgain=[];' ...
                     'end,' ...
                   'catch,pzg_err(''Fix DC checkbox'');end,' ...
                   'pzg_onoff(1);' ...
                   'pzg_unre;' ...
                   'clear temp_nz_ndx,']);
  hndl.verrel = ...
    uicontrol(CT_PZGUI,'Style','text', ...
        'String',{'Ver. 8.0.19';'18Jul2014'}, ...
        'Units','normalized', ...
        'Position',[0.63 0.93 0.15 0.07], ...
        'HorizontalAlignment','Right', ...
        'BackgroundColor', PZG(1).DefaultBackgroundColor, ...
        'ForegroundColor', foreground_color, ...
        'tag','pzgui ver & rel', ...
        'UserData', PZG );
  
  HelpString = {' Pure Delay '; ' '; ...
          ' If the system has any "pure delay"'; ...
          ' (also called "process delay" or'; ...
          ' "transport delay"), set this parameter'; ...
          ' equal to the number of seconds of delay.'; ...
          ' '; ...
          ' Default value of pure delay is zero.'; ...
          ' '; ...
          ' Note that a 4th-order Pade approximant'; ...
          ' is used in the root-locus plot and'; ...
          ' in the closed-loop response computation,'; ...
          ' whenever the delay is not zero.'};
  uicontrol(CT_PZGUI,'Style','frame', ...
            'units','normalized', ...
            'position',[0.800 0.928 0.20 0.070], ...
            'backgroundcolor',[0.9 0.9 0.9])
  uicontrol(CT_PZGUI,'Style','text', ...
      'Units','normalized', ...
      'Position',[0.805 0.931 0.07 0.064], ...
      'String',{'pure';'delay'}, ...
      'Fontweight','bold', ...
      'fontsize', 7, ...
      'HorizontalAlignment','center', ...
      'BackgroundColor',[0.9 0.9 0.9], ...
      'ForegroundColor',[0 0 0], ...
      'TooltipString','delay (for 4-pole Pade approximant)', ...
      'UserData',HelpString );
  if ~isfield(PZG(1),'PureDelay')
    PZG(1).PureDelay = 0;
  else
    PZG(1).PureDelay = abs(PZG(1).PureDelay);
  end
  hndl.PZGUI_pure_delay = ...
    uicontrol(CT_PZGUI,'Style','edit', ...
      'String', pzg_efmt(PZG(1).PureDelay), ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.88 0.942 0.10 0.045], ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[.9 .9 1], ...
      'ForegroundColor',[0 0 0], ...
      'tag','PZGUI pure delay', ...
      'TooltipString','delay (for 4-pole Pade approximant)', ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'tempCs1=pzmvserv(''s'');' ...
         'if tempCs1;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
           'pzgui;updatepl;' ... 
         'end;' ...
         'catch,pzg_err(''Pure Delay text-entry'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs1;% Set PureDelay'], ...
      'UserData',HelpString );
  
  
  HelpString = {' SAMPLE PERIOD Ts ' ' ' ...
          ' When you are studying relationships between' ...
          ' the continuous-time and discrete-time domains,' ...
          ' set the time between samples by changing' ...
          ' the value that appears in this window.' ' ' ...
          ' The default value of Ts is 0.005 seconds.' ...
          ' The sample time must be in units of seconds;' ...
          ' it is the reciprocal of the sample frequency (in Hz).' ' ' ...
          ' You can use powers-of-ten notation to enter' ...
          ' a sample time.  For example 3.3 microseconds' ...
          ' could be entered as:    3.3e-6' }';
  uicontrol(CT_PZGUI,'Style','frame', ...
            'units','normalized', ...
            'position',[0.800 0.864 0.20 0.057], ...
            'backgroundcolor',[0.9 0.9 0.9])
  uicontrol(CT_PZGUI,'Style','text', ...
      'Units','normalized', ...
      'Position',[0.82 0.868 0.05 0.048], ...
      'String','Ts', ...
      'Fontweight','bold', ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[0.9 0.9 0.9], ...
      'ForegroundColor',[0 0 0], ...
      'TooltipString','enter sample-period for Z-plane conversion', ...
      'UserData',HelpString );

  if ~isempty(DT_PZGUI)
    tempVis = 'off';
  else
    tempVis = 'on';
  end
  temp0(13,2) = uicontrol(CT_PZGUI,'Style','edit', ...
      'String', pzg_efmt(PZG(1).Ts), ...
      'Fontweight','bold', ...
      'Fontsize', 8, ...
      'Units','normalized', ...
      'Position',[0.87 0.873 0.12 0.045], ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[.9 .9 1], ...
      'ForegroundColor',[0 0 0], ...
      'TooltipString','enter sample-period for Z-plane conversion', ...
      'tag','pzgui Set TS', ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'tempCs2=pzmvserv(''s'');' ...
         'pzg_box(''redraw box'');' ...
         'catch,pzg_err(''Ts text-entry'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs2;% Set TS'], ...
      'Visible',tempVis, ...
      'UserData',HelpString );
  hndl.pzgui_Set_TS = temp0(13,2);
  
  HelpString = {'       TRANSFER FUNCTION GAIN ' ' '...
          ' The full system model is specified by a set' ...
          ' of poles, a set of zeros, and a GAIN.' ' ' ...
          ' You set the gain by entering' ...
          ' its value  in this data window.' ' ' ...
          ' The default GAIN is unity.' ' ' ...
          ' NOTE: ' ...
          ' This is NOT the DC gain; it is the leading' ...
          ' coefficient of the numerator polynomial' ...
          ' (the leading coefficient of the denominator' ...
          ' polynomial is assumed to be unity).'}';
  uicontrol(CT_PZGUI,'Style','frame', ...
            'units','normalized', ...
            'position',[0.800 0.793 0.20 0.057], ...
            'backgroundcolor',[0.7 0.7 0.7])
  temp0(1,2) = uicontrol(CT_PZGUI,'Style','edit', ...
      'String', pzg_efmt(PZG(1).Gain), ...
      'Fontweight','bold', ...
      'fontsize', 11, ...
      'Units','normalized', ...
      'Position',[0.865 0.801 0.134 0.045], ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[.9 .9 1], ...
      'ForegroundColor',[0 0.25 0.5], ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'tempCs3=pzmvserv(''s'');' ...
         'if tempCs3;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
           'pzgui;updatepl;' ... 
         'end;' ...
         'catch,pzg_err(''Gain text-entry'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs3 ;% Set Gain'], ...
      'UserData',HelpString, ...
      'TooltipString', num2str(PZG(1).Gain,16), ...
      'tag','CT ZPK-gain entry window');
  hndl.zpk_gain_entry_window = temp0(1,2);
  uicontrol(CT_PZGUI,'Style','text', ...
      'Units','normalized', ...
      'String','Gain', ...
      'fontsize', 10, ...
      'Fontweight','bold', ...
      'Position',[0.802 0.796 0.063 0.045], ...
      'HorizontalAlignment','Left', ...
      'BackgroundColor',[0.7 0.7 0.7], ...
      'ForegroundColor',[0 0 0.9], ...
      'TooltipString','Gain K (of Z/P/K model)', ...
      'UserData',HelpString );


  HelpString = {' DRAW A BOX IN THE S-PLANE' ' '...
          ' You can check or un-check this box' ...
          ' simply by clicking on it.' ' ' ...
          ' This feature is excellent for invesigating' ...
          ' the mappings between continuous-time and' ...
          ' discrete-time domains.' ' ' ...
          ' When this box is checked, the zoom feature' ...
          ' in the pole/zero map is disabled, and replaced' ...
          ' by the ability to draw a box in the S-plane.' ' ' ...
          ' The box is composed of six lines (sides and' ...
          ' diagonals, each of which is a different color.' ...
          ' ' ' IF YOU HAVE THE D-T LINK ENABLED, then' ...
          ' whenever you draw a new box, its edges and' ...
          ' diagonals are mapped into the Z-plane by' ...
          ' either e^(sT) or the bilinear transformation.' ...
          '  (If you are currently mapping poles and zeros' ...
          ' by the ZOH method, then e^(sT) is used to' ...
          ' map the box into the Z-Plane.)' ' ' ...
          ' If you change the sample time Ts or the' ...
          ' type of mapping, the box''s mapping will be' ...
          ' recomputed and refreshed in the D-T display,' ...
          ' provided that this box is checked.' }';
  temp0(16,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',0, ...
      'String','Draw Box', ...
      'Units','normalized', ...
      'Position',[0.35 0.065 0.16 0.047], ...
      'HorizontalAlignment','Left', ...
      'BackgroundColor', checkbox_background_color2, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'TooltipString','draw box instead of zoom -- box also mapped to Z-plane', ...
      'UserData',HelpString, ...
      'Tag','pzgui draw box checkbox', ...
      'Callback', ...
        ['global PZG;' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
           'if get(gcbo,''value''),' ...
             'temp_help_h=' ...
               'findobj(allchild(0),''name'',''PZGui Help Window'');' ...
             'if ~isempty(temp_help_h),' ...
               'delete(temp_help_h);' ...
             'end,' ...
             'temp_dpzguih=pzg_fndo(2,13,''fig_h'');' ...
             'if isempty(temp_dpzguih),' ...
               'dpzgui;' ...
               'figure(gcbf),' ...
             'end,' ...
           'end,' ...
         'catch,pzg_err(''Draw Box checkbox'');end,' ...
         'tempUIdrwbxsh=findobj(gcbf,''type'',''uicontrol'');' ...
         'pzg_onoff(1);' ...
         'clear temp_dpzguih temp_posct temp_help_h;' ...
         'clear temp_posdt tempUIdrwbxsh;' ...
         ]);
  hndl.draw_box_checkbox = temp0(16,2);

  HelpString = {'     ERASE PUSHBUTTON ' ' ' ...
          ' This button erases boxes that have' ...
          ' been drawn, as well as lines related' ...
          ' to the "Show-FRF-Computation" tool,' ...
          ' which will be closed.' ' ' ...
          ' Click on this button to erase any box' ...
          ' you have drawn using the "Draw Box"' ...
          ' check-box immediately to the left.' ' '}';
  temp0(17,2) = uicontrol(CT_PZGUI,'Style','pushbutton', ...
      'String','Erase', ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.52 0.061 0.08 0.04], ...
      'BackgroundColor',[0.7 0.9 0.8], ...
      'ForegroundColor',[0 0 0], ...
      'TooltipString','erase all drawn boxes, and de-select frequency', ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'tempCs4=pzmvserv(''s'');' ...
         'catch,pzg_err(''Erase pushbutton'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs4;% Erase'], ...
      'UserData',HelpString );

  HelpString = {'     UNDO PUSHBUTTON ' ' ' ...
          ' Push this button to undo the' ...
          ' last change that was made to' ...
          ' the open-loop model.' ' ' ...
          ' That includes changes such as' ...
          ' added/deleted/moved poles & zeros,' ...
          ' changed gain, and changed sample period.' ...
          ' ' 'The "undo" is domain-specific.' ...
          ' In other words, pressing "Undo" in' ...
          ' the continous-time P/Z Map does not' ...
          ' affect the discrete-time model,' ...
          ' and vice-versa (EXCEPT changes' ...
          ' to the sample period, Ts).'}';
  undo_h = ...
    uicontrol(CT_PZGUI,'Style','pushbutton', ...
        'String','Undo', ...
        'Fontweight','bold', ...
        'Units','normalized', ...
        'Position',[0.625 0.061 0.08 0.04], ...
        'BackgroundColor',[0.7 0.9 0.8], ...
        'ForegroundColor',[0 0 0], ...
        'tag','pzgui UNDO pushbutton', ...
        'TooltipString','undo the last change to p/z/k', ...
        'Callback', ...
          ['global PZG,' ...
           'pzg_onoff(0);' ...
           'drawnow,' ...
           'try,' ...
           'tempCs5=pzmvserv(''s'');' ...
           'if tempCs5;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
              'pzgui;updatepl;end;' ...
           'catch,pzg_err(''UNDO pushbutton'');end,' ...
           'pzg_onoff(1);' ...
           'pzg_unre;' ...
           'clear tempCs5;% UNDO'], ...
        'UserData',HelpString );
  hndl.pzgui_UNDO_pushbutton = undo_h;
  if ~isfield( PZG(1),'undo_info') || isempty( PZG(1).undo_info )
    set( undo_h,'enable','off')
  end

  HelpString = {'     REDO PUSHBUTTON ' ' ' ...
          ' Push this button to re-do the' ...
          ' last "undo" change that was made to' ...
          ' the open-loop model.' ' ' ...
          }';
  redo_h = ...
    uicontrol(CT_PZGUI,'Style','pushbutton', ...
        'String','Redo', ...
        'Fontweight','bold', ...
        'Units','normalized', ...
        'Position',[0.71 0.061 0.08 0.04], ...
        'BackgroundColor',[0.7 0.9 0.8], ...
        'ForegroundColor',[0 0 0], ...
        'tag','pzgui REDO pushbutton', ...
        'TooltipString','redo the last "Undo" change to p/z/k', ...
        'Callback', ...
          ['global PZG,' ...
           'pzg_onoff(0);' ...
           'drawnow,' ...
           'try,' ...
           'tempCs5=pzmvserv(''s'');' ...
           'if tempCs5;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
              'pzgui;updatepl;end;' ...
           'catch,pzg_err(''REDO pushbutton'');end,' ...
           'pzg_onoff(1);' ...
           'pzg_unre;' ...
           'clear tempCs5;% REDO'], ...
        'UserData',HelpString );
  hndl.pzgui_REDO_pushbutton = redo_h;
  if ~isfield( PZG(1),'redo_info') || isempty( PZG(1).redo_info )
    set( redo_h,'enable','off')
  end
  
    
  HelpString = {'     DISPLAY DAMPING GRID ' ' ' ...
          ' When this checkbox is checked, ' ...
          ' a grid of constant damping factors' ...
          ' and constant natural frequencies' ' ' ...
          ' will be displayed.' }';
  temp0(18,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',1, ...
      'String','Grid', ...
      'Units','normalized', ...
      'Position',[0.81 0.115 0.08 0.04], ...
      'HorizontalAlignment','Left', ...
      'BackgroundColor', checkbox_background_color2, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_grid(get(gcbf,''userdata''),gcbf,' ...
            'PZG(1).plot_h{12}.ax_h,12,PZG(1).plot_h{12}.hndl);'], ...
      'Tag','GridOnCheckbox', ...
      'TooltipString','show/hide grid lines', ...
      'UserData',HelpString );
  hndl.GridOnCheckbox = temp0(18,2);


  HelpString = {'      OPEN THE DISCRETE-TIME P/Z-MAP G.U.I.' ' ' ...
          ' This pushbutton control allows you' ...
          ' to open the Discrete-Time pzgui very easily.' ' ' ...
          ' When you click on this button, the D-T GUI' ...
          ' is created, or brought to the front if it' ...
          ' already exists.'};
  uicontrol(CT_PZGUI,'Style','pushbutton', ...
       'Value',0, ...
       'String','D-T pzgui', ...
       'Units','normalized', ...
       'Position',[0.005 0.103 0.10 0.038], ...
       'HorizontalAlignment','Left', ...
       'BackgroundColor',[0.7 0.9 0.8], ...
       'ForegroundColor',[0 0 0], ...
       'UserData',HelpString, ...
       'Tag','open D-T pzgui', ...
       'TooltipString','open the discrete-time P/Z-map G.U.I.', ...
       'Callback', ...
         ['global PZG,' ...
          'pzg_onoff(0);' ...
          'drawnow,' ...
          'temp_dt_pzg=pzg_fndo(2,13,''fig_h'');' ...
          'if isempty(temp_dt_pzg),' ...
            'temp_qdlg_ans=questdlg(' ...
              '{''Do you want to LINK the D-T to the C-T model?'';' ...
              ''' ''},''Establish C-T to D-T Link ??'',' ...
              '''Yes, create C-T to D-T link'',' ...
              '''No, simply open D-T pzgui'',' ...
              '''No, simply open D-T pzgui'');' ...
            'if isempty(temp_qdlg_ans),' ...
              'clear temp_dt_pzg temp_qdlg_ans,' ...
              'pzg_onoff(1);' ...
              'return,' ...
            'elseif strcmpi(temp_qdlg_ans,''Yes, create C-T to D-T link''),' ...
              'temp_dtlink_h=' ...
                'findobj(gcbf,''tag'',''pzgui Link Checkbox'');' ...
              'set(temp_dtlink_h,''value'',1,''backgroundcolor'',[0 0.7 0]);' ...
              'temp_dtlink_h=findobj(gcbf,''tag'',''D-T LinkMethod'');' ...
              'set(temp_dtlink_h,''backgroundcolor'',[0 0.7 0]);' ...
              'try,' ...
                'pzgui;updatepl;' ...
              'catch,pzg_err(''D-T pzgui pushbutton'');end,' ...
              'pzg_unre;' ...            
            'end,' ...
          'end,' ...
          'dpzgui;' ...
          'pzg_onoff(1);' ...
          'clear temp_dt_pzg temp_qdlg_ans temp_dtlink_h']);
  
  HelpString = {'      DISCRETE-TIME P/Z MAP LINK' ' ' ...
          ' You can check or un-check this box' ...
          ' simply by clicking on it.' ' ' ...
          ' Whenever this box is checked, a discrete-' ...
          ' time pole/zero map corresponding to the' ...
          ' continuous-time pole/zero map in this window' ...
          ' will be created and linked, so that as this' ...
          ' pole/zero map, or Ts, or GAIN are changed,' ...
          ' corresponding changes are made in the D-T map.' ...
          ' ' ' The method of computing the D-T locations' ...
          ' may be selected in the pull down menu to the' ...
          ' right of this checkbox. ' ...
          ' The default method is ZOH Equivalent.'}';
  temp0(14,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
       'Value',0, ...
       'String','D-T Link by:', ...
       'Units','normalized', ...
       'Position',[0.005 0.057 0.145 0.040], ...
       'HorizontalAlignment','Left', ...
       'BackgroundColor', checkbox_background_color2, ...
       'ForegroundColor', checkbox_foreground_color, ...
       'UserData',HelpString, ...
       'Tag','pzgui Link Checkbox', ...
       'TooltipString','link/unlink S-plane model onto Z-plane', ...
       'Callback', ...
         ['global PZG;' ...
          'pzg_onoff(0);' ...
          'drawnow,' ...
          'try,' ...
            'if get(gcbo,''value''),' ...
              'set(gcbo,''backgroundcolor'',[0 0.7 0]);' ...
              'set(findobj(gcbf,''tag'',''D-T LinkMethod''),' ...
                  '''backgroundcolor'',[0 0.7 0]);' ...
              'temp_ctlink_h=' ...
                 'findobj( allchild(0),' ...
                           '''type'',''uicontrol'',' ...
                           '''style'',''checkbox'',' ...
                           '''tag'',''dpzgui Link Checkbox'');' ...
              'if~isempty(temp_ctlink_h),' ...
                'set(temp_ctlink_h,''value'',0,' ...
                     '''backgroundcolor'',get(gcbf,''color''));' ...
              'end,' ...
              'temp_ctlink_h=pzg_fndo(2,13,''LinkMethod'');' ...
              'if~isempty(temp_ctlink_h),' ...
                'set(temp_ctlink_h,''backgroundcolor'',get(gcbf,''color''));' ...
              'end,' ...
            'else,' ...
              'set(gcbo,''backgroundcolor'',get(gcbf,''color''));' ...
              'set(findobj(gcbf,''tag'',''D-T LinkMethod''),' ...
                  '''backgroundcolor'',get(gcbf,''color''));' ...
            'end,' ...
            'pzgui;updatepl;' ...
          'catch,pzg_err(''D-T Link checkbox'');end,' ...
          'pzg_onoff(1);' ...
          'pzg_unre;' ...
          'clear temp_ctlink_h; % D-T Link checkbox'] );
  hndl.LinkCheckbox = temp0(14,2);

  SelectStr = {'z=e^(sT)';'ZOH equiv';'bilinear'};
  HelpString = {' ***  C-T > D-T COMPUTATION METHOD  ***' ' ' ...
          ' THIS IS A PULL-DOWN SELECTION MENU.' ' ' ...
          ' Click the arrow on the right end of the menu' ...
          ' to select the method by which the discrete-' ...
          ' time poles and zeros will be computed' ...
          ' from the continuous-time pole and zero locations.'}';
  if ~isempty(DT_PZGUI)
    InitVal = get( DT_Hndls(15,2),'Value' );
  else
    InitVal = 2;
  end
  
  fig_bg_color = get( CT_PZGUI,'color');
  temp0(15,2) = uicontrol(CT_PZGUI,'Style','popupmenu', ...
      'String',SelectStr, ...
      'fontsize', 8, ...
      'Value', InitVal, ...
      'Units','normalized', ...
      'Position',[0.13 0.075 0.175 0.03], ...
      'BackgroundColor',fig_bg_color, ...
      'ForegroundColor',1-fig_bg_color, ...
      'UserData',HelpString, ...
      'Tag','D-T LinkMethod', ...
      'TooltipString','method of converting S-plane model to Z-plane', ...
      'Callback', ...
         ['global PZG;' ...
          'pzg_onoff(0);' ...
          'drawnow,' ...
          'try,' ...
            'tempA=get(gcbf,''UserData'');' ...
            'temp=findobj(allchild(0),''Name'',PZG(2).PZGUIname);' ...
            'if ~isempty(temp),' ...
              'tempB=get(temp,''UserData'');' ...
              'if isequal(get(tempB(15,2),''Value''),get(gcbo,''Value'')),' ...
                 'return,' ...
              'end,' ...
              'freqserv(''deselect frequency'');' ...
              'set(tempB(15,2),''Value'',get(gcbo,''Value''));' ...
              'if get(gcbo,''Value'')<3,' ...
                'set(tempA([21;31],1),''Visible'',''On'');' ...
                'set(tempA([41;51],2),''Visible'',''On'');' ...
                'set(tempA([41;51;71;81],1),''Visible'',''Off'');' ...
              'else,' ...
                'set(tempA([21;31;41;51],1),''Visible'',''Off'');' ...
                'set(tempA([71;81],1),''Visible'',''On'');' ...
                'set(tempA([41;51],2),''Visible'',''Off'');' ...
              'end,' ...
              'if get(tempB(14,2),''Value'')||get(tempB(10,2),''Value''),' ...
                'dpzgui;dupdatep;' ...
              'end,' ...
            'else,' ...
              'set(tempA([21;31;71;81],1),''Visible'',''Off'');' ...
              'set(tempA([41;51],1),''Visible'',''On'');' ...
              'set(tempA([41;51],2),''Visible'',''Off'');' ...
            'end;' ...
            'if ~get(tempA(18,2),''Value''),' ...
              'set(tempA([21;31;71;81],1),''Visible'',''Off'');' ...
              'set(tempA([41;51],(1:2)),''Visible'',''Off'');' ...
            'end,' ...
            'pzgui;updatepl;' ...
            'pzg_box(''redraw box'');' ...
          'catch,pzg_err(''D-T Link Method popupmenu'');end,' ...
          'pzg_onoff(1);' ...
          'pzg_unre;' ...
          'clear temp tempA tempB'] );
  hndl.LinkMethod = temp0(15,2);

  
  HelpString = {'OPEN-LOOP BODE PLOTTING CHECK BOX' ' ' ...
          ' You can check this box simply by clicking on it.' ' ' ...
          ' When this box is checked, the OPEN-LOOP Bode' ...
          ' magnitude and phase plots will be created, and' ...
          ' will automatically be updated as you change the' ...
          ' pole/zero configuration, or the GAIN, or the delay.' ...
          ' ' ' IN THE RESULTING BODE PLOT, if you position' ...
          ' the cursor near the FREQ RESPONSE LINE, itself,' ...
          ' that frequency will be highlighted in all' ...
          ' the Bode, Nichols and Nyquist plots, and the' ...
          ' frequency will be displayed near the cursor.' ...
          ' ' ...
          ' The ZOOM feature is enabled and linked in all' ...
          ' of the Bode plots, so whenever you zoom in or out' ...
          ' in one of the plots, the frequency ranges in' ...
          ' the other plots are adjusted to be identical.'}';
  plot_exist = [ pzg_fndo( 1,1,'fig_h'); pzg_fndo( 1,2,'fig_h') ];
  temp0(2,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',~isempty(plot_exist), ...
      'String','OLbode', ...
      'Units','normalized', ...
      'Position',[0.005 0.005 0.125 0.045], ...
      'BackgroundColor', checkbox_background_color, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'UserData',HelpString, ...
      'tag','C-T OLbode checkbox', ...
      'TooltipString','open-loop Bode plot', ...
      'Callback', ...
        ['global PZG;' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
           'if get(gcbo,''Value'')==1;' ...
             'bodepl(PZG(1).BodeFreqs,' ...
                    'PZG(1).BodeMag,PZG(1).BodePhs,' ...
                    'PZG(1).OLBodeName,PZG(1).FrqSelNdx,' ...
                    'PZG(1).OLBodeName,' ...
                    '[0.005 0.67 0.29 0.28],' ...
                    '[''if pzg_disab,return,end,' ...
                      'try,tempfs=freqserv(gcbf,1);pzg_ptr;' ...
                      'catch,pzg_err(''''button down'''');' ...
                      'end,clear tempfs;'']);' ...
           'end;' ...
           'olbs_tempH=findobj(allchild(0),''Name'',' ...
                   '[PZG(1).OLBodeName '' Magnitude'']);' ...
           'if~isempty(olbs_tempH),' ... 
             'figure(olbs_tempH(1)),' ...
             'set(gcbo,''value'',1),' ...
           'end,' ...
           'olbs_tempH=findobj(allchild(0),''Name'',' ...
                   '[PZG(1).OLBodeName '' Phase'']);' ...
           'if~isempty(olbs_tempH),' ...
             'figure(olbs_tempH(1)),' ...
             'set(gcbo,''value'',1),' ...
           'end,' ...
         'catch,pzg_err(''O.L.Bode checkbox'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'pzg_bkup,' ...
         'clear olbs_tempH;']);
  hndl.OLbode_checkbox = temp0(2,2);

  HelpString = {'CLOSED-LOOP BODE PLOTTING CHECK BOX' ' ' ...
          ' You can check this box simply by clicking on it.' ' ' ...
          ' When this box is checked, the CLOSED-LOOP Bode' ...
          ' magnitude and phase plots will be created, and' ...
          ' will automatically be updated as you change the' ...
          ' pole/zero configuration, or the GAIN, or the delay.' ...
          ' ' ' IN THE RESULTING BODE PLOT, if you position' ...
          ' the cursor near the FREQ RESPONSE LINE, itself,' ...
          ' that frequency will be highlighted in all' ...
          ' the Bode, Nichols and Nyquist plots, and the' ...
          ' frequency will be displayed near the cursor.' ...
          ' ' ...
          ' The ZOOM feature is enabled and linked in all' ...
          ' of the Bode plots, so whenever you zoom in or out' ...
          ' in one of the plots, the frequency ranges in' ...
          ' the other plots are adjusted to be identical.' }';
  plot_exist = [ pzg_fndo( 1,3,'fig_h'); pzg_fndo( 1,4,'fig_h') ];
  temp0(3,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',~isempty(plot_exist), ...
      'String','C.Lbode', ...
      'Units','normalized', ...
      'Position',[0.135 0.005 0.125 0.045], ...
      'BackgroundColor', checkbox_background_color, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'UserData',HelpString, ...
      'tag','C-T CLbode checkbox', ...
      'TooltipString','unity neg feedback closed-loop Bode plot', ...
      'Callback', ...
        ['global PZG;' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
           'if get(gcbo,''Value'')==1;' ...
             'bodepl(PZG(1).CLBodeFreqs,' ...
                    'PZG(1).CLBodeMag,PZG(1).CLBodePhs,' ...
                    'PZG(1).CLBodeName,PZG(1).FrqSelNdx,' ...
                    'PZG(1).CLBodeName,' ...
                    '[0.3 0.67 0.29 0.28],' ...
                    '[''if pzg_disab,return,end,' ...
                      'try,tempfs=freqserv(gcbf,1);pzg_ptr;' ...
                      'catch,pzg_err(''''button down'''');' ...
                      'end,clear tempfs'']);' ...
           'end;' ...
           'clbs_tempH=findobj(allchild(0),''Name'',' ...
                   '[PZG(1).CLBodeName '' Magnitude'']);' ...
           'if~isempty(clbs_tempH),' ...
             'figure(clbs_tempH(1)),' ...
             'set(gcbo,''value'',1),' ...
           'end,' ...
           'clbs_tempH=findobj(allchild(0),''Name'',' ...
                   '[PZG(1).CLBodeName '' Phase'']);' ...
           'if~isempty(clbs_tempH),' ...
             'figure(clbs_tempH(1)),' ...
             'set(clbs_tempH,''doublebuffer'',''off'');' ...
             'set(clbs_tempH,''doublebuffer'',''on'');' ...
             'set(gcbo,''value'',1),' ...
           'end,' ...
         'catch,pzg_err(''C.L.Bode checkbox'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'pzg_bkup,' ...
         'clear clbs_tempH;']);
  hndl.CLbode_checkbox = temp0(3,2);

  HelpString = {'        NICHOLS CHARTING CHECK BOX' ' ' ...
          ' You can check this box simply by clicking on it.' ' ' ...
          ' When this box is checked, the C-T Nichols chart' ...
          ' will be created, and will automatically be updated' ...
          ' as you change the pole/zero configuration, or the' ...
          ' GAIN, or the pure delay.' ...
          ' ' ' IN THE RESULTING Nichols chart, if you position' ...
          ' the cursor near the FREQ RESPONSE LINE, itself,' ...
          ' that frequency will be highlighted in all' ...
          ' the Bode and Nyquist plots, and the frequency' ...
          ' will be displayed near the cursor.' ...
          ' ' 'While ordinarily the C-T Nichols chart contains' ...
          ' the mapping of the positive jW-axis, here there is' ...
          ' a checkbox to also view the data from the rest of the' ...
          ' Nyquist contour, and that can be quite informative.' ...
          ' ' ' Another checkbox enables display of three "equi-margin"' ...
          ' gain-phase margins, at 3dB, 6dB, and 9dB.' ...
          ' ' ' There is also a checkbox to highlight the relationships' ...
          ' between the cursor location in the the Nichols chart and the' ...
          ' closed-loop magnitude and phase plots, as you move the cursor' ...
          ' around in any of those three plots.  This can be a big help' ...
          ' in understanding the "Nichols grid".' ...
          ' '}';  
  plot_exist = pzg_fndo( 1,6,'fig_h');
  temp0(4,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',~isempty(plot_exist), ...
      'String','Nichols', ...
      'Units','normalized', ...
      'Position',[0.26 0.005 0.125 0.045], ...
      'BackgroundColor', checkbox_background_color, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'UserData',HelpString, ...
      'tag','C-T Nichols checkbox', ...
      'TooltipString','Nichols chart', ...
      'Callback', ...
        ['global PZG;' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
           'if get(gcbo,''Value'')==1;' ...
             'ScrSize=get(0,''ScreenSize'');' ...
             'if ScrSize(3)>1024,' ...
               'ScrPos=[10 20 450 320];' ...
             'elseif ScrSize(3)>800,' ...
               'ScrPos=[10 20 360 250];' ...
             'else,' ...
               'ScrPos=[10 20 280 200];' ...
             'end,' ...
             'nicholpl(PZG(1).BodeFreqs,' ...
                      'PZG(1).BodeMag,' ...
                      'PZG(1).BodePhs,' ...
                      'PZG(1).NicholsName,' ...
                      'PZG(1).FrqSelNdx,' ...
                      'PZG(1).NicholsName,' ...
                      'ScrPos,' ...
                      '[''try,tempfs=freqserv(gcbf,1);pzg_ptr;' ...
                        'catch,pzg_err(''''button down'''');' ...
                        'end,clear tempfs;'']);' ...
           'end,' ...
           'temp_f=findobj(allchild(0),''Name'',PZG(1).NicholsName);' ...
           'if~isempty(temp_f)', ...
             'figure(temp_f(1)),' ...
             'set(gcbo,''value'',1);' ...
           'end,' ...
         'catch,pzg_err(''Nichols checkbox'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'pzg_bkup,' ...
         'clear ScrPos ScrSize temp_f;']);
  hndl.Nichols_checkbox = temp0(4,2);

  HelpString = {'        NYQUIST PLOT CHECK BOX' ' ' ...
          ' You can check this box simply by clicking on it.' ' ' ...
          ' When this box is checked, the C-T Nyquist chart' ...
          ' will be created, and will automatically be updated' ...
          ' as you change the pole/zero configuration, or the GAIN,' ...
          ' or the pure delay.' ' ' ...
          ' The Nyquist Contour plot is also created at the same' ...
          ' time. This shows the contour points at which the ' ...
          ' transfer function is evaluated to produce the Nyquist plot.' ...
          ' The contour plot is "not to-scale" because it must show the' ...
          ' infinite-radius semicircle by which the contour encircles' ...
          ' the entire right half of the S-plane.' ...
          ' ' ' Where poles or zeros are on the stability boundary (i.e.,' ...
          ' on the jW-axis), the Nyquist contour makes semicircular' ...
          ' detours, with infinitesimal radii, into the right half-plane.' ...
          ' For the poles, these detours, which are necessary to the Nyquist' ...
          ' criterion, are automatically created in the contour plot, with' ...
          ' full mapping capability to the Nyquist plot.  For the zeros,' ...
          ' although the detours are not required, the associated mappings' ...
          ' are illuminating, especially in terms of the phase effects.' ...
          ' ' ' There is a checkbox for nonlinear scaling in the plot,' ...
          ' which is very useful when you need to see the unit circle' ...
          ' in detail at the same time you need to see large magnitudes.' ...
          ' ' ' Another checkbox enables display of three "equi-margin"' ...
          ' gain-phase margins, at 3dB, 6dB, and 9dB.' ...
          ' ' ' In the Nyquist plot, if you position the cursor' ...
          ' near the FREQ RESPONSE LINE, itself, that frequency will be' ...
          ' highlighted in all the frequency-domain plots. The same is' ...
          ' true for the contour plot.' ' '}';
  plot_exist = pzg_fndo( 1,7,'fig_h');
  temp0(19,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',~isempty(plot_exist), ...
      'String','Nyquist', ...
      'Units','normalized', ...
      'Position',[0.385 0.005 0.12 0.045], ...
      'BackgroundColor', checkbox_background_color, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'UserData',HelpString, ...
      'Tag','C-T Nyquist Checkbox', ...
      'TooltipString','Nyquist plot', ...
      'Callback', ...
        ['global PZG;' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
           'if get(gcbo,''Value'')==1;' ...
             'ScrSize=get(0,''ScreenSize'');' ...
             'if ScrSize(3)>1024;' ...
               'ScrPos=[150 20 450 320];' ...
             'elseif ScrSize(3)>800;' ...
               'ScrPos=[100 20 360 250];' ...
             'else;' ...
               'ScrPos=[70 20 280 200];' ...
             'end;' ...
             'nyqistpl(PZG(1).BodeFreqs,' ...
                      'PZG(1).BodeMag, PZG(1).BodePhs,' ...
                      'PZG(1).ZeroLocs, PZG(1).PoleLocs, PZG(1).Gain,' ...
                      'PZG(1).NyquistName, PZG(1).FrqSelNdx,' ...
                      'PZG(1).NyquistName, ScrPos,' ...
                      '[''if pzg_disab,return,end,' ...
                        'try,tempfs=freqserv(gcbf,1);pzg_ptr;' ...
                        'catch,pzg_err(''''button down'''');' ...
                        'end,clear tempfs;'']);' ...
             'contourpl(''bring forward'',1);' ...
           'end,' ...
           'temp_f=findobj(allchild(0),''Name'',PZG(1).NyquistName);' ...
           'if~isempty(temp_f),' ...
             'figure(temp_f(1)),' ...
             'set(temp_f,''doublebuffer'',''off'');' ...
             'set(temp_f,''doublebuffer'',''on'');' ...
             'set(gcbo,''value'',1);' ...
           'end,' ...
           'temp_c=findobj(allchild(0),''Name'',PZG(1).NyqContourPlotName);' ...
           'if~isempty(temp_c)', ...
             'figure(temp_c(1)),' ...
             'set(temp_c,''doublebuffer'',''off'');' ...
             'set(temp_c,''doublebuffer'',''on'');' ...
             'set(gcbo,''value'',1);' ...
           'end,' ...
         'catch,pzg_err(''Nyquist checkbox'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'pzg_bkup,' ...
         'clear ScrPos ScrSize temp_f temp_c;']);
  hndl.Nyquist_checkbox = temp0(19,2);

  HelpString = {' OPEN-LOOP TIME RESPONSE CHECK BOX' ' ' ...
          ' You can check this box simply by clicking on it.' ' ' ...
          ' When this box is checked, the C-T open-loop' ...
          ' step response will be created, and will' ...
          ' automatically be updated as you change' ...
          ' the pole/zero configuration, above.' ' ' ...
          ' In the response plot, there is a pulldown menu to' ...
          ' select IMPULSE, STEP, RAMP, PARABOLA or SINUSOIDAL' ...
          ' input.' ...
          ' ' 'The end-time of the plot can be changed easily,' ...
          ' by entering a different value into "Max Time".' ...
          ' ' ' When you select sinusoidal response, you' ...
          ' can specify the sinusoid frequency (in hertz),' ...
          ' and the resulting STEADY-STATE magnitude and' ...
          ' phase shift are displayed.' ' ' ...
          ' Also, when displaying sinusoidal response, there' ...
          ' is a checkbox to display only that part of the' ...
          ' response around the time the system reaches ' ...
          ' steady-state.' ' ' ...
          ' For step-response: ' ...
          ' You may select one of several PERFORMANCE' ...
          ' MEASURES, as well as the range over which it is' ...
          ' computed.  Step-response performance is automatic' ...
          ' and is always displayed, with step-input selected.'}';
  plot_exist = pzg_fndo( 1,8,'fig_h');
  temp0(5,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',~isempty(plot_exist), ...
      'String','OLresp', ...
      'Units','normalized', ...
      'Position',[0.510 0.005 0.125 0.045], ...
      'BackgroundColor', checkbox_background_color, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'UserData',HelpString, ...
      'tag','C-T OLresp checkbox', ...
      'TooltipString','open-loop time-response plot', ...
      'Callback', ...
        ['global PZG;' ...
         'pzg_onoff(0);' ...
         'if get(gcbo,''value''),' ...
           'tempmbox_h=' ...
              'msgbox({''Creating the open-loop response plot.'';' ...
                       ''' '';''     Please wait ...''},' ...
                      '''Please Wait ...'');' ...
         'else,' ...
           'tempmbox_h=[];' ...
         'end,' ...
         'drawnow,' ...
         'try,' ...
           'if get(gcbo,''Value'')==1;' ...
             'ScrSize=get(0,''ScreenSize'');' ...
             'if ScrSize(3)>1024;' ...
               'ScrPos=[495 20 375 320];' ...
             'elseif ScrSize(3)>800;' ...
               'ScrPos=[380 20 300 250];' ...
             'else;' ...
               'ScrPos=[300 20 240 200];' ...
             'end;' ...
             'resppl(PZG(1).N,PZG(1).D,' ...
                    'PZG(1).Gain,PZG(1).OLTimeRespName,' ...
                    'PZG(1).OLTimeRespName,' ...
                    '''s'',1,ScrPos);' ...
           'end,' ...
           'temp_f=findobj(allchild(0),''Name'',PZG(1).OLTimeRespName);' ...
           'if~isempty(temp_f)', ...
             'figure(temp_f(1)),' ...
             'set(temp_f,''doublebuffer'',''off'');' ...
             'set(temp_f,''doublebuffer'',''on'');' ...
             'set(gcbo,''value'',1);' ...
           'end,' ...
         'catch,pzg_err(''O.L.Resp checkbox'');end,' ...
         'if isequal(ishandle(tempmbox_h),1),' ...
           'delete(tempmbox_h),' ...
         'end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'pzg_bkup,' ...
         'clear ScrPos ScrSize temp_f tempmbox_h;']);
  hndl.OLresp_checkbox = temp0(5,2);

  HelpString = {' CLOSED-LOOP TIME RESPONSE CHECK BOX' ' ' ...
          ' You can check this box simply by clicking on it.' ' ' ...
          ' When this box is checked, the C-T closed-loop' ...
          ' step response will be created, and will' ...
          ' automatically be updated as you change' ...
          ' the pole/zero configuration, above.' ' ' ...
          ' In the response plot, there is a pulldown menu to' ...
          ' select IMPULSE, STEP, RAMP, PARABOLA or SINUSOIDAL' ...
          ' input.' ...
          ' ' 'The end-time of the plot can be changed easily,' ...
          ' by entering a different value into "Max Time".' ...
          ' ' ' When you select sinusoidal response, you' ...
          ' can select the sinusoid frequency (in hertz),' ...
          ' and the resulting STEADY-STATE magnitude and' ...
          ' phase shift are displayed.' ' ' ...
          ' Also, when displaying sinusoidal response, there' ...
          ' is a checkbox to display only that part of the' ...
          ' response around the time the system reaches ' ...
          ' steady-state.' ' ' ...
          ' For step-response: ' ...
          ' You may select one of several PERFORMANCE' ...
          ' MEASURES, as well as the range over which it is' ...
          ' computed.  Step-response performance is automatic' ...
          ' and is always displayed, with step-input selected.'}';
  plot_exist = pzg_fndo( 1,9,'fig_h');
  temp0(6,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',~isempty(plot_exist), ...
      'String','C.Lresp', ...
      'Units','normalized', ...
      'Position',[0.62 0.005 0.13 0.045], ...
      'BackgroundColor', checkbox_background_color, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'UserData',HelpString, ...
      'tag','C-T CLresp checkbox', ...
      'TooltipString','unity neg-feedback closed-loop time-response plot', ...
      'Callback', ...
        ['global PZG;' ...
         'pzg_onoff(0);' ...
         'if get(gcbo,''value''),' ...
           'tempmbox_h=' ...
              'msgbox({''Creating the closed-loop response plot.'';' ...
                       ''' '';''     Please wait ...''},' ...
                      '''Please Wait ...'');' ...
         'else,' ...
           'tempmbox_h=[];' ...
         'end,' ...
         'drawnow,' ...
         'try,' ...
           'if get(gcbo,''Value'')==1;' ...
             'ScrSize=get(0,''ScreenSize'');' ...
             'if ScrSize(3)>1024;' ...
               'ScrPos=[900 20 375 320];' ...
             'elseif ScrSize(3)>800;' ...
               'ScrPos=[700 20 300 250];' ...
             'else;' ...
               'ScrPos=[550 20 240 200];' ...
             'end;' ...
             'resppl(PZG(1).N,PZG(1).Dc,' ...
                    'PZG(1).CLGain,PZG(1).CLTimeRespName,' ...
                    'PZG(1).CLTimeRespName,''s'',1,ScrPos);' ...
           'end,' ...
           'temp_f=findobj(allchild(0),''Name'',PZG(1).CLTimeRespName);' ...
           'if~isempty(temp_f)', ...
             'set(temp_f,''visible'',''on'');' ...
             'figure(temp_f(1)),' ...
             'set(temp_f,''doublebuffer'',''off'');' ...
             'set(temp_f,''doublebuffer'',''on'');' ...
             'set(gcbo,''value'',1);' ...
           'end,' ...
         'catch,pzg_err(''C.L.Resp checkbox'');end,' ...
         'pzg_onoff(1);' ...
         'if isequal(ishandle(tempmbox_h),1),' ...
           'delete(tempmbox_h),' ...
         'end,' ...
         'pzg_unre;' ...
         'pzg_bkup,' ...
         'clear ScrPos ScrSize temp_f tempmbox_h;']);
  hndl.CLresp_checkbox = temp0(6,2);

  HelpString = {'    ROOT LOCUS PLOTTING CHECK BOX' ' ' ...
          ' You can check this box simply by clicking on it.' ' ' ...
          ' When this box is checked, the discrete-time' ...
          ' ROOT LOCUS plot will be created, and will' ...
          ' automatically be updated as you change the' ...
          ' pole/zero configuration, above, or GAIN.' ' ' ...
          ' The closed loop pole positions that result' ...
          ' from the GAIN you have specified' ...
          ' are indicated by cyan "square" markers.' ' ' ...
          ' By positioning the cursor near A ROOT LOCUS LINE,' ...
          ' you can find out the gain associated' ...
          ' with that particular computation point.  The gain' ...
          ' is displayed at the lower left corner of the' ...
          ' Nichols plot. ' ...
          ' ' ' Each of the root locus computation points' ...
          ' corresponds to a possible closed-loop pole' ...
          ' location.' }';
   
  plot_exist = pzg_fndo( 1,10,'fig_h');
  temp0(10,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',~isempty(plot_exist), ...
      'String','Rt Loc', ...
      'Units','normalized', ...
      'Position',[0.745 0.005 0.105 0.045], ...
      'BackgroundColor', checkbox_background_color, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'UserData',HelpString, ...
      'tag','C-T RtLoc checkbox', ...
      'TooltipString','root locus plot', ...
      'Callback', ...
        ['global PZG;' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
           'if get(gcbo,''Value'')==1;' ...
             'ScrSize=get(0,''ScreenSize'');' ...
             'if ScrSize(3)>1024;' ...
               'ScrPos=[485 20 375 320];' ...
             'elseif ScrSize(3)>800;' ...
               'ScrPos=[370 20 300 250];' ...
             'else;' ...
               'ScrPos=[290 20 240 200];' ...
             'end;' ...
             'rlocuspl(1,1,PZG(1).Gain,' ...
                'PZG(1).RootLocusName,[],''s'',' ...
                'PZG(1).RootLocusName,' ...
                'ScrPos,''rlocuspl(PZG(1).Gain);pzg_ptr;'','''');' ...
           'end,' ...
           'temp_f=pzg_fndo(1,10,''fig_h'');' ...
           'if~isempty(temp_f)', ...
             'figure(temp_f(1)),' ...
             'set(gcbo,''value'',1);' ...
           'end,' ...
         'catch,pzg_err(''C-T Rt.Loc. checkbox'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'pzg_bkup,' ...
         'clear ScrPos ScrSize temp_f']);
  hndl.RtLoc_checkbox = temp0(10,2);

  HelpString = {'        SENSITIVITY PLOT CHECK BOX' ' ' ...
          ' You can check this box simply by clicking on it.' ' ' ...
          ' When this box is checked, the C-T sensitivity plot' ...
          ' will be created, and will automatically be updated' ...
          ' as you change the pole/zero configuration,' ...
          ' above, or the GAIN.' ' ' ...
          ' In the sensitivity plot, if you position the cursor' ...
          ' near the FREQ RESPONSE LINE, itself,' ...
          ' that frequency will be highlighted in all' ...
          ' the frequency-domain plots, and displayed' ...
          ' near the cursor.' ' '}';
  plot_exist = pzg_fndo( 1,5,'fig_h');
  temp0(20,2) = uicontrol(CT_PZGUI,'Style','checkbox', ...
      'Value',~isempty(plot_exist), ...
      'String','Sensitivity', ...
      'Units','normalized', ...
      'Position',[0.855 0.005 0.142 0.045], ...
      'BackgroundColor', checkbox_background_color, ...
      'ForegroundColor', checkbox_foreground_color, ...
      'UserData',HelpString, ...
      'Tag','C-T Sensitivity Checkbox', ...
      'TooltipString','unity neg-feedback output-sensitivity magnitude plot', ...
      'Callback', ...
        ['global PZG;' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
           'if get(gcbo,''Value'')==1,' ...
             'ScrSize=get(0,''ScreenSize'');' ...
             'if ScrSize(3)>1024,' ...
               'ScrPos=[300 20 450 320];' ...
             'elseif ScrSize(3)>800,' ...
               'ScrPos=[250 20 360 250];' ...
             'else,' ...
               'ScrPos=[200 20 280 200];' ...
             'end;' ...
             'sensplot(PZG(1).CLBodeFreqs,' ...
                      'PZG(1).CLBodeMag,' ...
                      'PZG(1).CLBodePhs,' ...
                      'PZG(1).SensPlotName,' ...
                      'PZG(1).FrqSelNdx,' ...
                      'PZG(1).SensPlotName,' ...
                      'ScrPos,' ...
                      '[''if pzg_disab,return,end,' ...
                        'try,tempfs=freqserv(gcbf,1);pzg_ptr;' ...
                        'catch,pzg_err(''''button down'''');' ...
                        'end,clear tempfs;'']);' ...
           'end,' ...
           'temp_f=findobj(allchild(0),''Name'',PZG(1).SensPlotName);' ...
           'if~isempty(temp_f)', ...
             'figure(temp_f(1)),' ...
             'set(temp_f,''doublebuffer'',''off'');' ...
             'set(temp_f,''doublebuffer'',''on'');' ...
             'set(gcbo,''value'',1);' ...
           'end,' ...
         'catch,pzg_err(''Sensitivity checkbox'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'pzg_bkup,' ...
         'clear ScrPos ScrSize temp_f;']);
  hndl.Sensitivity_checkbox = temp0(20,2);
         
  uicontrol(CT_PZGUI,'Style','frame', ...
            'units','normalized', ...
            'position',[0.800 0.488 0.20 0.298], ...
            'backgroundcolor',[0.7 0.7 0.7])
  HelpString = {'  PULL-DOWN SELECTION MENU FOR POLE SELECTION' ...
          ' ' ' Click the arrow at the right end of it' ...
          ' to select a pole to be moved or deleted.' ' ' ...
          ' The pole will not be deleted or moved until' ...
          ' you click either the "Delete" pole pushbutton' ...
          ' or the "Move" pole pushbutton.' ...
          ' ' ' If moving, the pole will be moved to the' ...
          ' location specified in the data entry window, below.' ...
          ' ' ' The pull-down menu will list every pole' ...
          ' in the pole/zero map at the left.' ...
          ' ' ' If a complex pole is selected, in fact' ...
          ' BOTH it and its conjugate are selected.'}';
  nr_poles = numel(PZG(1).PoleLocs);
  nr_poles_str = [ num2str(nr_poles) ' POLES'];
  if nr_poles == 0
    nr_poles_str = 'NO POLES';
  elseif nr_poles == 1
    nr_poles_str = '1 POLE';
  end
  hndl.CT_number_of_poles = ...
    uicontrol(CT_PZGUI,'Style','text', ...
      'String', nr_poles_str, ...
      'Fontweight','bold', ...
      'fontsize', 10, ...
      'Units','normalized', ...
      'Position',[0.802 0.738 0.196 0.045], ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[0.7 0.7 0.7], ...
      'ForegroundColor',[0 0 0.9], ...
      'tag','C-T number of poles', ...
      'UserData',HelpString );
  SelectStr = cell(numel(PZG(1).PoleLocs)+1,1);
  for Ck = 1:numel(PZG(1).PoleLocs)
    SelectStr{Ck} = num2str(PZG(1).PoleLocs(Ck));
  end
  SelectStr{end} = 'ALL POLES';
  uicontrol(CT_PZGUI,'Style','text', ...
      'String',{'selected';'pole'}, ...
      'fontsize', 7, ...
      'Units','normalized', ...
      'Position',[0.805 0.610 0.085 0.085], ...
      'HorizontalAlignment','center', ...
      'BackgroundColor',[0.7 0.7 0.7], ...
      'ForegroundColor',[0 0 0], ...
      'Tag','pzgui pole-list dropdown menu label', ...
      'UserData',HelpString );
  temp0(7,2) = uicontrol(CT_PZGUI,'Style','popupmenu', ...
      'String',SelectStr, ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.804 0.704 0.195 0.045], ...
      'BackgroundColor',[0.7 0.8 0.9], ...
      'ForegroundColor',[0 0 0], ...
      'TooltipString','menu to select one of the model poles', ...
      'Tag','pzgui pole-list dropdown menu', ...
      'UserData',HelpString );
  hndl.pole_list_dropdown_menu = temp0(7,2);
  HelpString = {' MOVE A POLE PUSHBUTTON.' '  ' ...
          ' Click this button when you want to move' ...
          ' the pole (or poles) selected above' ...
          ' to the location indicated in the data' ...
          ' entry box (below). ' ' ' ...
          ' If a complex pole is selected,' ...
          ' its complex conjugate will be moved, too.'}';
  uicontrol(CT_PZGUI,'Style','pushbutton', ...
      'String','Move', ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.810 0.590 0.085 0.045], ...
      'BackgroundColor',[.8 .85 .95], ...
      'ForegroundColor',[0 0 0], ...
      'BusyAction','cancel', ...
      'TooltipString','move selected pole to indicated location', ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'temps6=get(gcbf,''UserData'');' ...
         'temps6=get(temps6(11,2),''String'');' ...
         'if exist(temps6);' ...
           'eval([''temps6='' temps6 '';'']);' ...
           'tempCs6=pzmvserv(''s'',temps6);' ...
         'else;' ...
           'if~isempty(str2num(temps6)),' ...
             'temps6=str2num(temps6);' ...
             'tempCs6=pzmvserv(''s'',temps6);' ...
           'else,' ...
             'tempCs6=pzmvserv(''s'');' ...
           'end,' ...
         'end;' ...
         'if tempCs6;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
           'pzgui;updatepl;' ... 
         'end;' ...
         'catch,pzg_err(''Move pushbutton'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs6 temps6;% MovePole'], ...
      'Interruptible','On', ...
      'UserData',HelpString );
  HelpString = {' DELETE A POLE PUSHBUTTON.' ' ' ...
          ' Click this button when you want to delete' ...
          ' the real pole or complex pole pair ' ...
          ' selected directly above, from the pole/zero' ...
          ' map at the left.' ' ' ...
          ' If a complex pole is selected above,' ...
          ' BOTH it and its conjugate will be deleted.'}';
  uicontrol(CT_PZGUI,'Style','pushbutton', ...
      'String','Delete', ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.900 0.644 0.085 0.045], ...
      'BackgroundColor',[.8 .85 .95], ...
      'ForegroundColor',[0 0 0], ...
      'BusyAction','cancel', ...
      'TooltipString','delete selected pole', ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'tempCs7=pzmvserv(''s'');' ...
         'if tempCs7;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
           'pzgui;updatepl;' ... 
         'end;' ...
         'catch,pzg_err(''Delete pushbutton'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs7;% DeletePole'], ...
      'UserData',HelpString );
  HelpString = {' ADD A POLE PUSHBUTTON.' '  ' ...
          ' Click this button when you want to add' ...
          ' the pole (or poles) indicated in the data' ...
          ' entry box (just below) to the pole/zero ' ...
          ' map (at left). ' ' ' ...
          ' If a complex number is entered above,' ...
          ' it will be used to add a complex PAIR.' ...
          ' ' ' CAUTION:' ...
          ' If you click this button multiple times,' ...
          ' the specified pole or poles will be added' ...
          ' multiple times.'}';
  uicontrol(CT_PZGUI,'Style','pushbutton', ...
      'String','Add', ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.905 0.586 0.085 0.045], ...
      'BackgroundColor',[.8 .85 .95], ...
      'ForegroundColor',[0 0 0], ...
      'BusyAction','cancel', ...
      'TooltipString','add poles at indicated locations', ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'temps8=get(gcbf,''UserData'');' ...
         'temps8=get(temps8(11,2),''String'');' ...
         'if exist(temps8,''var''),' ...
           'eval([''temps8='' temps8 '';'']);' ...
           'tempCs8=pzmvserv(''s'',temps8);' ...
         'else,' ...
           'if~isempty(str2num(temps8)),' ...
             'temps8=str2num(temps8);' ...
             'tempCs8=pzmvserv(''s'',temps8);' ...
           'else,' ...
             'tempCs8=pzmvserv(''s'');' ...
           'end,' ...
         'end;' ...
         'if tempCs8;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
           'pzgui;updatepl;' ... 
         'end;' ...
         'catch,pzg_err(''Add pushbutton'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs8 temps8; % AddPole'], ...
      'Interruptible','On', ...
      'UserData',HelpString );
  HelpString = {' POLE-LOCATION DATA ENTRY BOX.' ' ' ...
          ' Enter either the NUMERICAL VALUE of the' ...
          ' location where you want to place a new pole' ...
          '(or to move the currently-selected pole),' ...
          ' OR ENTER THE NAME OF A VECTOR of poles defined in' ...
          ' the main MATLAB workspace. ' ' '...
          ' If you are entering a complex number,' ...
          ' it should END with i or j; for example, -5+2i. ' ...
          ' ' ' The pole or poles specified here will not' ...
          ' actually be added until you click the "Add Pole" ' ...
          ' pushbutton below.  EACH TIME you click the' ...
          ' "Add pole" pushbutton, the specified pole or' ...
          ' poles WILL BE added, so be careful: ' ...
          ' you could accidentally get multiple poles.' }';
  uicontrol(CT_PZGUI,'Style','text', ...
      'Units','normalized', ...
      'Position',[0.802 0.492 0.196 0.050], ...
      'String',{'S-plane locations';'( or varname )'}, ...
      'fontsize', 7, ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[0.7 0.7 0.7], ...
      'ForegroundColor',[0 0 0], ...
      'TooltipString','enter s-plane location for a pole', ...
      'UserData',HelpString );
  temp0(11,2) = uicontrol(CT_PZGUI,'Style','edit', ...
      'Units','normalized', ...
      'Position',[0.81 0.542 0.18 0.045], ...
      'String','', ...
      'Fontweight','bold', ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[.9 .9 1], ...
      'ForegroundColor',[0 0 0], ...
      'Interruptible','On', ...
      'tag','pzg zero entry edit', ...
      'TooltipString','enter list (or variable name) of S-plane locations', ...
      'UserData',HelpString );
  hndl.pole_entry_edit = temp0(11,2);


  uicontrol(CT_PZGUI,'Style','frame', ...
            'units','normalized', ...
            'position',[0.800 0.171 0.20 0.307], ...
            'backgroundcolor',[0.7 0.7 0.7])
  HelpString = {' PULL-DOWN MENU FOR ZERO SELECTION' ...
          ' ' ' Click the arrow at the right end of it' ...
          ' to select a zero to move or delete. ' ' ' ...
          ' The selected zero will not be moved or deleted' ...
          ' until you click the "Move" zero or "Delete" zero' ...
          ' pushbutton, below.' ...
          ' ' ' If moving, the zero will be moved to the' ...
          ' location specified in the data entry window, below.' ...
          ' ' ' The pull-down menu will list every zero' ...
          ' in the pole/zero map at the left.' ...
          ' ' ' If a complex zero is selected, in fact' ...
          ' BOTH it and its conjugate are selected.'}';
  nr_zeros = numel(PZG(1).ZeroLocs);
  nr_zeros_str = [ num2str(nr_zeros) ' ZEROS'];
  if nr_zeros == 0
    nr_zeros_str = 'NO ZEROS';
  elseif nr_zeros == 1
    nr_zeros_str = '1 ZERO';
  end
  hndl.CT_number_of_zeros = ...
    uicontrol(CT_PZGUI,'Style','text', ...
      'String', nr_zeros_str, ...
      'Fontweight','bold', ...
      'fontsize', 10, ...
      'Units','normalized', ...
      'Position',[0.802 0.433 0.196 0.045], ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[0.7 0.7 0.7], ...
      'ForegroundColor',[0 0 0.9], ...
      'tag','C-T number of zeros', ...
      'UserData',HelpString );
  SelectStr = cell(numel(PZG(1).ZeroLocs)+1,1);
  for Ck = 1:numel(PZG(1).ZeroLocs)
    SelectStr{Ck} = num2str(PZG(1).ZeroLocs(Ck));
  end
  SelectStr{end} = 'ALL ZEROS';
  uicontrol(CT_PZGUI,'Style','text', ...
      'String',{'selected','zero'}, ...
      'fontsize', 7, ...
      'Units','normalized', ...
      'Position',[0.805 0.303 0.085 0.085], ...
      'HorizontalAlignment','center', ...
      'BackgroundColor',[0.7 0.7 0.7], ...
      'ForegroundColor',[0 0 0], ...
      'UserData',HelpString );
  temp0(8,2) = uicontrol(CT_PZGUI,'Style','popupmenu', ...
      'String',SelectStr, ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.804 0.400 0.195 0.045], ...
      'BackgroundColor',[0.7 0.8 0.9], ...
      'ForegroundColor',[0 0 0], ...
      'TooltipString','menu to select one of the model zeros', ...
      'Tag','pzgui zero-list dropdown menu', ...
      'UserData',HelpString );
  hndl.zero_list_dropdown_menu = temp0(8,2);
  HelpString = {' MOVE A ZERO PUSHBUTTON.' '  ' ...
          ' Click this button when you want to move' ...
          ' the zero (or zeros) selected above' ...
          ' to the location indicated in the data' ...
          ' entry box (below). ' ' ' ...
          ' If a complex zero is selected,' ...
          ' its complex conjugate will be moved, too.'}';
  uicontrol(CT_PZGUI,'Style','pushbutton', ...
      'String','Move', ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.81 0.28 0.085 0.045], ...
      'BackgroundColor',[.8 .85 .95], ...
      'ForegroundColor',[0 0 0], ...
      'BusyAction','cancel', ...
      'TooltipString','move selected zero to indicated location', ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'temps9=get(gcbf,''UserData'');' ...
         'temps9=get(temps9(12,2),''String'');' ...
         'if exist(temps9,''var'');' ...
           'eval([''temps9='' temps9 '';'']);' ...
           'tempCs9=pzmvserv(''s'',temps9);' ...
         'else;' ...
           'if~isempty(str2num(temps9)),' ...
             'temps9=str2num(temps9);' ...
             'tempCs9=pzmvserv(''s'',temps9);' ...
           'else,' ...
             'tempCs9=pzmvserv(''s'');' ...
           'end,' ...
         'end;' ...
         'if tempCs9;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
           'pzgui;updatepl;' ... 
         'end;' ...
         'catch,pzg_err(''Move pushbutton'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs9 temps9;% MoveZero'], ...
      'Interruptible','On', ...
      'UserData',HelpString );
  HelpString = {' DELETE A ZERO PUSHBUTTON.' ' ' ...
          ' Click this button when you want to delete' ...
          ' the real zero or complex zero pair ' ...
          ' selected directly above, from the pole/zero' ...
          ' map at the left.' ' ' ...
          ' If a complex zero is selected above,' ...
          ' BOTH it and its conjugate will be deleted.'}';
  uicontrol(CT_PZGUI,'Style','pushbutton', ...
      'String','Delete', ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.900 0.338 0.085 0.045], ...
      'BackgroundColor',[.8 .85 .95], ...
      'ForegroundColor',[0 0 0], ...
      'BusyAction','cancel', ...
      'TooltipString','delete selected zero', ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'tempCs10=pzmvserv(''s'');' ...
         'if tempCs10;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
           'pzgui;updatepl;' ... 
         'end;' ...
         'catch,pzg_err(''Delete pushbutton'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs10;% DeleteZero'], ...
      'UserData',HelpString );
  HelpString = {'    ADD A ZERO PUSHBUTTON' ' ' ...
          ' Click this button when you want to add' ...
          ' the zero (or zeros) indicated in the data' ...
          ' entry box (just below) to the pole/zero ' ...
          ' map (at left).' ' ' ...
          ' If a complex number is entered above,' ...
          ' it will be used to add a complex PAIR.' ...
          ' ' ' CAUTION:' ...
          ' If you click this button multiple times,' ...
          ' the specified zero or zeros will be added' ...
          ' multiple times.'}';
  uicontrol(CT_PZGUI,'Style','pushbutton', ...
      'String','Add', ...
      'Fontweight','bold', ...
      'Units','normalized', ...
      'Position',[0.905 0.276 0.085 0.045], ...
      'BackgroundColor',[.8 .85 .95], ...
      'ForegroundColor',[0 0 0], ...
      'BusyAction','cancel', ...
      'TooltipString','add zeros at indicated locations', ...
      'Callback', ...
        ['global PZG,' ...
         'pzg_onoff(0);' ...
         'drawnow,' ...
         'try,' ...
         'temps11=get(gcbf,''UserData'');' ...
         'temps11=get(temps11(12,2),''String'');' ...
         'if exist(temps11,''var'');' ...
           'eval([''temps11='' temps11 '';'']);' ...
           'tempCs11=pzmvserv(''s'',temps11);' ...
         'else;' ...
           'if~isempty(str2num(temps11)),' ...
             'temps11=str2num(temps11);' ...
             'tempCs11=pzmvserv(''s'',temps11);' ...
           'else,' ...
             'tempCs11=pzmvserv(''s'');' ...
           'end,' ...
         'end;' ...
         'if tempCs11;PZG(1).recompute_frf=0;pzg_cntr(1);pzg_bodex(1);' ...
           'pzgui;updatepl;' ... 
         'end;' ...
         'catch,pzg_err(''Add pushbutton'');end,' ...
         'pzg_onoff(1);' ...
         'pzg_unre;' ...
         'clear tempCs11 temps11;% AddZero'], ...
      'Interruptible','On', ...
      'UserData',HelpString );
  HelpString = {' ZERO-LOCATION DATA ENTRY BOX.' ' ' ...
          ' Enter either the NUMERICAL VALUE of the' ...
          ' location where you want to place a new zero ' ...
          ' (or move the currently-selected zero), ' ...
          ' or the NAME OF A VECTOR of zeros defined in' ...
          ' the main MATLAB workspace.' ' ' ...
          ' If you are entering a complex number,' ...
          ' it should END with i or j; for example, -5+2i.' ...
          ' ' ' The zero or zeros specified here will not' ...
          ' actually be added until you click the "Add Zero"' ...
          ' pushbutton below.  Each time you click the' ...
          ' "Add Zero" pushbutton, the specified zero or' ...
          ' zeros WILL BE added, so be careful: ' ...
          ' you could accidentally get multiple zeros.'}';
  uicontrol(CT_PZGUI,'Style','text', ...
      'Units','normalized', ...
      'Position',[0.802 0.178 0.196 0.052], ...
      'String',{'S-plane locations';'( or varname )'}, ...
      'fontsize', 7, ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[0.7 0.7 0.7], ...
      'ForegroundColor',[0 0 0], ...
      'UserData',HelpString );
  temp0(12,2) = uicontrol(CT_PZGUI,'Style','edit', ...
      'Units','normalized', ...
      'Position',[0.81 0.230 0.18 0.045], ...
      'String','', ...
      'Fontweight','bold', ...
      'HorizontalAlignment','Center', ...
      'BackgroundColor',[.9 .9 1], ...
      'ForegroundColor',[0 0 0], ...
      'Interruptible','On', ...
      'TooltipString','enter list (or variable name) of S-plane locations', ...
      'UserData',HelpString );
  hndl.zero_entry_edit = temp0(12,2);

  set(CT_PZGUI,'WindowButtonDownFcn', ...
    ['global PZG;' ...
     'if pzg_disab,return,end,' ...
     'try,' ...
       'if strcmpi(get(gcbf,''pointer''),''hand'')' ...
         '||strcmpi(get(gcbf,''pointer''),''arrow''),' ...
         'temp_helph=findobj(allchild(0),''string'',''Help'',' ...
            '''tag'',''pzg help checkbox'');' ...
         'if ~isempty(temp_helph)&&isequal(1,ishandle(temp_helph)),' ...
           'set(temp_helph,''Value'',0,' ...
                '''foregroundcolor'',1-get(gcbf,''color''),' ...
                '''fontweight'',''normal'');' ...
         'end,' ...
         'temp_helpwndw=' ...
           'findobj(allchild(0),''name'',''PZGui Help Window'');' ...
         'delete(temp_helpwndw);' ...
       'end,' ...         
       'zmintcpt;' ...
       'pzg_ptr;' ...
     'catch,' ...
       'pzg_err(''C-T PZGUI button down'');' ...
       'pzg_unre;' ...
     'end,' ...
     'clear temp_helph temp_helpwndw;']);
  set(CT_PZGUI,'WindowButtonMotionFcn', ...
    ['global PZG;' ...
     'if pzg_disab,return,end,' ...
     'try,' ...
       'pzgcalbk(gcbf,''mouse motion'');' ...
       'pzg_ptr;' ...
     'catch,pzg_err(''C-T PZGUI mouse motion'');end,' ...
     'clear temp_mousemotions_ui']);

  set(CT_PZGUI,'UserData', temp0 );
  
  bodesel_h = findobj( CTgca,'tag','Bode selection marker');
  if ~isequal( 1, numel(bodesel_h) )
    delete(bodesel_h)
    bodesel_h = ...
      plot( 0, 0, ...
           'linestyle','none', ...
           'linewidth', 3, ...
           'marker','o', ...
           'markersize', 4, ...
           'color',[0 0.8 0.8], ...
           'parent', CTgca, ...
           'visible','off', ...
           'tag','Bode selection marker');
    set( bodesel_h,'xdata', [],'ydata', [] );
  end
  hndl.Bode_selection_marker = bodesel_h;
  if PZG(1).pzg_show_frf_computation
    selVis = 'on';
  else
    selVis = 'off';
  end
  PZG(1).FrqSelNdx = abs(round(PZG(1).FrqSelNdx));
  if isempty(PZG(1).FrqSelNdx) ...
    || ( PZG(1).FrqSelNdx < 1 ) ...
    || ( PZG(1).FrqSelNdx > numel(PZG(1).BodeFreqs) )
    set( bodesel_h,'visible','off');
  else
    sel_point = PZG(1).BodeFreqs( PZG(1).FrqSelNdx );
    set( bodesel_h, ...
        'xdata', 0, ...
        'ydata', sel_point, ...
        'visible', selVis );
  end
  
  hndl.ax_xlim = get( hndl.ax,'xlim');
  hndl.ax_ylim = get( hndl.ax,'ylim');
  
  % Create the S-plane damping & natural-frequency grid lines.
  [ temp0, hndl ] = pzg_grid( temp0, CT_PZGUI, CTgca, 12, hndl );
  set( CT_PZGUI,'userdata', temp0 );    
  setappdata( CT_PZGUI,'hndl', hndl );
  pzg_cphndl( CT_PZGUI, 1, 12 )

  if ~isempty(DT_PZGUI) ...
    && ~isempty(gcbo) && isequal( get(gcbo,'parent'), DT_PZGUI ) ...
    && isequal( get(gcbo,'type'),'uicontrol') ...
    && isequal( get(gcbo,'string'),'Draw Box')
    % If figure is created from turning on "Draw Box" in D-T PZGUI,
    % create a message box explaining the "draw box" function.
    msgbox_h = ...
      msgbox({'Using the mouse as if you were "zooming-in" on the Z-plane,'; ...
              '(i.e., holding down the left-button of the mouse)'; ...
              'causes a "box" to be drawn, instead of zooming.'; ...
              ' '; ...
              'The "box" you draw is immediately mapped into the S-plane'; ...
              'by whatever method you select in the "C-T Link" menu.'; ...
              ' '; ...
              'Comparing the two boxes helps to understand distortions'; ...
              'under the different Z-to-S plane conversion methods.'; ...
              ' ';'     Click "OK" to continue'}, ...
              'D-T to C-T "Draw Box" is Enabled','modal');
    set( findobj(msgbox_h,'type','text'),'fontsize', 10 )
    msg_pos = get( msgbox_h,'position');
    msg_pos(3:4) = [ 1.2*msg_pos(3), 1.1*msg_pos(4) ];
    set( msgbox_h,'position', msg_pos );
    uiwait(msgbox_h)
  end
  
else
  % PZGUI figure already exists
  pzg_grid( temp0, CT_PZGUI, hndl.ax, 12, hndl,'off');
  set([hndl.PZmap_xaxis_highlight;hndl.PZmap_yaxis_highlight],'visible','off');
  set( hndl.pzgui_Set_TS,'String',pzg_efmt(PZG(1).Ts) );
  set( hndl.zpk_gain_entry_window, ...
      'String', pzg_efmt(PZG(1).Gain), ...
      'TooltipString', num2str(PZG(1).Gain,16) );
  set( hndl.PZG_Poles_line, ...
      'Xdata',real(PZG(1).PoleLocs), ...
      'Ydata',imag(PZG(1).PoleLocs), ...
      'MarkerSize', pz_markersize, ...
      'LineWidth', pz_linewidth );
  [ hndl, mod_hndl ] = pzg_maprep( PZG(1).PoleLocs,'pole', hndl );
  if mod_hndl
    PZG(1).plot_h{12}.hndl.pole_repstr_h = hndl.pole_repstr_h;
    setappdata( CT_PZGUI,'hndl', hndl );
  end
  set( hndl.PZG_Zeros_line, ...
      'Xdata',real(PZG(1).ZeroLocs),...
      'Ydata',imag(PZG(1).ZeroLocs), ...
      'MarkerSize', pz_markersize-2, ...
      'LineWidth', pz_linewidth );
  [ hndl, mod_hndl ] = pzg_maprep( PZG(1).ZeroLocs,'zero', hndl );
  if mod_hndl
    PZG(1).plot_h{12}.hndl.zero_repstr_h = hndl.zero_repstr_h;
    setappdata( CT_PZGUI,'hndl', hndl );
  end
  
  pzg_grid( temp0, CT_PZGUI, hndl.ax, 12, hndl );

  SelectStr = cell(numel(PZG(1).PoleLocs)+1,1);
  for Ck = 1:numel(PZG(1).PoleLocs)
    this_pole = PZG(1).PoleLocs(Ck);
    if ( abs( real(this_pole) ) < 1e-6 ) ...
      ||( abs( imag(this_pole) ) < 1e-6 )
      if isreal(this_pole)
        SelectStr{Ck} = num2str(this_pole,10);
      else
        SelectStr{Ck} = num2str(this_pole,9);
      end
    else
      SelectStr{Ck} = num2str(this_pole,7);
    end
  end
  SelectStr{end} = 'ALL POLES';
  temp1 = get( hndl.pole_list_dropdown_menu,'Value');
  temp1 = max( 1, min( temp1, numel(PZG(1).PoleLocs) ) );
  set( hndl.pole_list_dropdown_menu,'String', SelectStr,'Value', temp1 );

  SelectStr = cell(numel(PZG(1).ZeroLocs)+1,1);
  for Ck = 1:numel(PZG(1).ZeroLocs)
    this_zero = PZG(1).ZeroLocs(Ck);
    if ( abs( real(this_zero) ) < 1e-6 ) ...
      ||( abs( imag(this_zero) ) < 1e-6 )
      if isreal(this_pole)
        SelectStr{Ck} = num2str(this_zero,10);
      else
        SelectStr{Ck} = num2str(this_zero,9);
      end
    else
      SelectStr{Ck} = num2str(this_zero,7);
    end
  end
  SelectStr{end} = 'ALL ZEROS';
  temp1 = get( hndl.zero_list_dropdown_menu,'Value');
  temp1 = max(1, min( temp1, numel(PZG(1).ZeroLocs) ) );
  set( hndl.zero_list_dropdown_menu,'String', SelectStr,'Value', temp1 );
end

set( CT_PZGUI,'UserData', temp0 );

if get( hndl.LinkCheckbox,'value')
  set( [ hndl.LinkCheckbox; hndl.LinkMethod ], ...
      'foregroundcolor',1-get(CT_PZGUI,'color'), ...
      'backgroundcolor',[0 0.7 0]);
else
  set( [ hndl.LinkCheckbox; hndl.LinkMethod ], ...
      'foregroundcolor',1-get(CT_PZGUI,'color'), ...
      'backgroundcolor', get(CT_PZGUI,'color') );
end

freqserv('refresh_plot_h', CT_PZGUI );
pzg_seltxt(1)
  
if isempty(gcbf) ...
  ||( ~isempty(gcbo) && isequal( get(gcbo,'tag'),'open C-T pzgui') )
  figure(CT_PZGUI)
end

if new_ct_figure
  zmintcpt('open zoom', CT_PZGUI )
  freqserv('refresh_plot_h', CT_PZGUI );
  local_update_pid_ldlg(1)
  if PZG(1).pzg_show_frf_computation && ~isempty(PZG(1).FrqSelNdx)
    updtpzln('s')
    pzg_seltxt( 1, PZG(1).BodeFreqs(PZG(1).FrqSelNdx), 12, 0 )
  end
end

if ishandle(pwmsgbox_h)
  delete(pwmsgbox_h)
end

hndl.ax_xlim = get( hndl.ax,'xlim');
hndl.ax_ylim = get( hndl.ax,'ylim');
PZG(1).plot_h{12}.xlim = hndl.ax_xlim;
PZG(1).plot_h{12}.ylim = hndl.ax_ylim;
PZG(2).plot_h{12}.xlim = hndl.ax_xlim;
PZG(2).plot_h{12}.ylim = hndl.ax_ylim;
setappdata( CT_PZGUI,'hndl', hndl );
pzg_cphndl( CT_PZGUI, 1, 12 )
pzg_bkup

return


function local_service_request(ReqStr)
  
global PZG

msgbox_h = -1;

ct_pzgui_h = findobj( allchild(0),'name', PZG(1).PZGUIname );
dt_pzgui_h = findobj( allchild(0),'name', PZG(2).PZGUIname );
filepath = '';

switch lower(ReqStr)
  case 'refresh c-t frfs'
    PZG(1).recompute_frf = 0;
    pzg_cntr(1);
    pzg_bodex(1);
    
  case 'save model to file'
    if ~isfield(PZG(1),'save_dir') ...
      && isfield(PZG(1),'load_dir') ...
      && ischar(PZG(1).load_dir) && exist(PZG(1).load_dir,'dir')
      PZG(1).save_dir = PZG(1).load_dir;
    end
    if isfield(PZG(1),'save_dir') ...
      && ischar(PZG(1).save_dir) && exist(PZG(1).save_dir,'dir')
      save_dir = fullfile( PZG(1).save_dir,'*.mat');
    else
      save_dir = ['.' filesep '*.mat'];
    end
    
    [filename,filepath] = ...
      uiputfile('*.mat','Specify Save-File Path & Name', save_dir );
    if isnumeric(filename) || isnumeric(filepath) || isempty(filename) ...
      ||~exist( filepath,'dir')
      return
    end
    PZG0 = PZG;
    PZG0(1).cntr_data = [];
    PZG0(2).cntr_data = [];
    PZG0(1).plot_h = [];
    PZG0(2).plot_h = [];
    PZG0(1).BodeFreqs = [];
    PZG0(2).BodeFreqs = [];
    PZG0(1).BodeMag = [];
    PZG0(2).BodeMag = [];
    PZG0(1).BodePhs = [];
    PZG0(2).BodePhs = [];
    PZG0(1).CLBodeFreqs = [];
    PZG0(2).CLBodeFreqs = [];
    PZG0(1).CLBodeMag = [];
    PZG0(2).CLBodeMag = [];
    PZG0(1).CLBodePhs = [];
    PZG0(2).CLBodePhs = [];
    PZG0(1).CLPoleLocs = [];
    PZG0(2).CLPoleLocs = [];
    PZG0(1).CLZeroLocs = [];
    PZG0(2).CLZeroLocs = [];
    PZG0(1).save_dir = filepath;
    PZG0(2).save_dir = filepath;
    PZG0(1).load_dir = filepath;
    PZG0(2).load_dir = filepath;      %#ok<NASGU>
    
    save( fullfile(filepath,filename),'PZG0')
    
    PZG(1).save_dir = filepath;
    PZG(2).save_dir = filepath;
    
    return
    
  case {'export model to workspace'; ...
        'export model as a state-space (ss) variable'; ...
        'export model as a state-space (ss) zeta/wn form'; ...
        'export model to zero/pole/gain (zpk) object'; ...
        'export model to transfer-function (tf) object'; ...
        'frequency-response frd to workspace'; ...
        'partial-fraction expansion to workspace'}
    % Get noncanceling poles and zeros.
    these_z = PZG(1).ZeroLocs;
    these_p = PZG(1).PoleLocs;
    for kp = numel(these_p):-1:1
      cancel_z_ndx = [];
      for kz = numel(these_z):-1:1
        if abs( these_p(kp) - these_z(kz) ) < 1e-12
          cancel_z_ndx = kz;
        end
      end
      if ~isempty(cancel_z_ndx)
        these_z(cancel_z_ndx) = [];
        these_p(kp) = [];
      end
    end
    ct_pzg = zpk( these_z, these_p, PZG(1).Gain );
    if PZG(1).PureDelay > 0
      ct_pzg.iodelay = PZG(1).PureDelay;
    end
    
    these_z = PZG(2).ZeroLocs;
    these_p = PZG(2).PoleLocs;
    for kp = numel(these_p):-1:1
      cancel_z_ndx = [];
      for kz = numel(these_z):-1:1
        if abs( these_p(kp) - these_z(kz) ) < 1e-12
          cancel_z_ndx = kz;
        end
      end
      if ~isempty(cancel_z_ndx)
        these_z(cancel_z_ndx) = [];
        these_p(kp) = [];
      end
    end
    dt_pzg = ...
      zpk( these_z, these_p, PZG(2).Gain, PZG(2).Ts );
    if ( PZG(2).PureDelay > 0 ) ...
      && isequal( PZG(2).PureDelay, round(PZG(2).PureDelay) )
      dt_pzg.iodelay = PZG(2).PureDelay;
    end
    
    if ~isempty( strfind( get(gcbf,'name'),'Continuous') )
      default_str = 'C-T Model in PZGUI';
    else
      default_str = 'D-T Model in DPZGUI';
    end
    if ~isempty( findobj( allchild(0),'name', PZG(1).PZGUIname ) ) ...
      && ~isempty( findobj( allchild(0),'name', PZG(2).PZGUIname ) ) ...
      && ~strcmpi( ReqStr,'export model as a state-space (ss) zeta/wn form')
      ct_dt_str = ...
        questdlg( ...
          {'Save the continuous-time model in PZGUI,'; ...
           ' '; ...
           'or save the discrete-time model in DPZGUI?'; ...
           ' '}, ...
          'Save C-T or D-T Model ???', ...
          'C-T Model in PZGUI','D-T Model in DPZGUI', default_str );
      if isempty(ct_dt_str)
        return
      end
    else
      ct_dt_str = default_str;
    end
    
    ss_form = 'modal-canonic'; % Default state-space model is modal-canonic.
    if strcmpi( ReqStr,'frequency-response frd to workspace')
      obj_type_str = 'FRD';
    elseif strcmpi( ReqStr,'partial-fraction expansion to workspace')
      obj_type_str = 'PFE';
    elseif strcmpi( ReqStr,'export model as a state-space (ss) variable')
      obj_type_str = 'S-S';
    elseif strcmpi( ReqStr,'export model as a state-space (ss) zeta/wn form')
      obj_type_str = 'S-S';
      if any( abs(imag(PZG(1).PoleLocs)) > 1e-14 ) ...
        && strcmpi( ct_dt_str,'C-T Model in PZGUI')
        ss_form = 'zeta-Wn';
      end
    elseif strcmpi( ReqStr,'export model to zero/pole/gain (zpk) object')
      obj_type_str = 'ZPK';
    elseif strcmpi( ReqStr,'export model to transfer-function (tf) object')
      obj_type_str = 'T-F';
    else
      obj_type_str = ...
        questdlg( ...
          {'Select the LTI-object type for the workspace variable.'
           ' '; ...
           'ZPK = "zero/pole/gain" (Matlab zpk-object)'; ...
           'S-S = "state-space" (Matlab ss-object)'; ...
           'T-F = "transfer-function" (Matlab tf-object)'; ' '}, ...
          'Specify the Object Type', ...
          'ZPK','S-S','T-F','ZPK');
    end
    if isempty(obj_type_str)
      return
    end
    
    var_name = ...
      inputdlg('Enter a valid MATLAB variable name:', ...
               'Specify the Variable Name');
    if isempty(var_name) || ~iscell(var_name) ...
      || ~isequal( 1, numel(var_name) )
      return
    else
      var_name = var_name{1};
      % Remove space character.
      var_name( var_name == ' ') = '';
      while ~isempty(var_name) && ~isletter( var_name(1) )
        var_name(1) = '';
      end
      nonval_ndx = ...
        find( ~isletter(var_name) ...
               &( var_name ~= '_') ...
               &( ( double(var_name) < '0') ...
                 |( double(var_name) > '9') ) );
      if ~isempty(nonval_ndx)
        var_name(nonval_ndx) = '';
      end
      if isempty(var_name) || ~ischar(var_name) || ( size(var_name,1) > 1 ) ...
        || any( ~isletter(var_name) ...
               &( var_name ~= '_') ...
               &( ( double(var_name) < '0') ...
                 |( double(var_name) > '9') ) )
        errdlg_h = ...
          errordlg( ...
            {'Specified string is not a valid Matlab variable name.'; ...
             ' '; ...
             'Initial character must be a letter,'; ...
             'and all characters must be alpha-numeric'; ...
             'with no spaces (although "underscores" are ok).'; ...
             ' ';'    Click "OK" to continue ...';' '}, ...
            'Invalid Variable Name','modal');
        uiwait(errdlg_h)
        return
      elseif strcmpi( var_name,'pzg')
        errdlg_h = ...
          errordlg( ...
            {'Specified name is reserved for use by PZGUI.'; ...
             ' ';'    Click "OK" to continue ...';' '}, ...
            'Reserved Variable Name','modal');
        uiwait(errdlg_h)
        return
      elseif evalin('base',['exist(''' var_name ''',''var'')'])
        cont_str = ...
          questdlg( ...
            {'Specified variable name already exists in the workspace.'; ...
             ' '; ...
             'If you continue, the variable will be over-written.';' '}, ...
            'Overwrite Existing Variable ???', ...
            'Yes, Overwrite','No, Cancel','No, Cancel');
        if strcmpi( cont_str,'no, cancel')
          return
        end
      end
    end

    switch obj_type_str
      case 'FRD'
        % Convert FRF data to FRD object.
        if strcmpi( ct_dt_str,'C-T Model in PZGUI')
          this_frd = ...
            frd( PZG(1).cntr_data.bode2nyq_pts, ...
                 PZG(1).cntr_data.bode2nyq_freqs );
        else
          this_frd = ...
            frd( PZG(2).cntr_data.bode2nyq_pts, ...
                 PZG(2).cntr_data.bode2nyq_freqs, PZG(2).Ts );
        end
        assignin('base', var_name, this_frd );
        
      case 'PFE'
        % Convert zpk to pfe.
        if strcmpi( ct_dt_str,'C-T Model in PZGUI')
          [ reses, poles, direct ] = ...
              pzg_res( ct_pzg.z{1}, ct_pzg.p{1}, ct_pzg.k );
        else
          if PZG(2).PureDelay > 0
            dt_pzg.p{1} = [ dt_pzg.p{1}; zeros(PZG(2).PureDelay,1) ];
            dt_pzg.iodelay = 0;
          end
          [ reses, poles, direct ] = ...
              pzg_res( dt_pzg.z{1}, dt_pzg.p{1}, dt_pzg.k );
        end
        this_pfe.residues = reses;
        this_pfe.poles = poles;
        this_pfe.direct = direct;
        assignin('base', var_name, this_pfe );
        
      case 'ZPK'
        if strcmpi( ct_dt_str,'C-T Model in PZGUI')
          assignin('base', var_name, ct_pzg );
        else
          assignin('base', var_name, dt_pzg );
        end
        
      case 'T-F'
        % Convert ZPK to TF.
        if strcmpi( ct_dt_str,'C-T Model in PZGUI')
          ct_tf = tf( PZG(1).Gain*poly(PZG(1).ZeroLocs), ...
                      poly(PZG(1).PoleLocs) );
          if isempty(ct_tf) ...
            || ~iscell(ct_tf.num) ...
            || any( isnan( ct_tf.num{1} ) ) ...
            || any( isinf( ct_tf.num{1} ) )
            errdlg_h = ...
              errordlg( ...
                {'Conversion of the zero/pole/gain (ZPK) model '; ...
                   'to UNFACTORED transfer-function (TF) form'; ...
                 'is, in this case, so poorly-conditioned that it failed.'; ...
                 ' '; ...
                 'No variable is being created in the workspace.'; ...
                 ' ';'     Click "OK" to continue.'}, ...
                 'PZGui Advisory:  Conversion Failed', ...
                 'modal');
            uiwait(errdlg_h)
            return
          end
          ct_tf.iodelay = PZG(1).PureDelay;
          if iscell( ct_tf.num )
            NNN = ct_tf.num{1};
          else
            NNN = ct_tf.num;
          end
          zzz = roots(NNN);
          if iscell( ct_tf.den )
            DDD = ct_tf.den{1};
          else
            DDD = ct_tf.den;
          end
          ppp = roots(DDD);
          % Compare recovered poles and zeros to the originals.
          tf_is_ok = 1;
          if ( numel(zzz) ~= numel(PZG(1).ZeroLocs) ) ...
            ||( numel(ppp) ~= numel(PZG(1).PoleLocs) )
            tf_is_ok = 0;
          else
            avail_p_ndxs = (1:numel(PZG(1).PoleLocs));
            for kp = 1:numel(PZG(1).PoleLocs)
              if abs(PZG(1).PoleLocs(kp)) < 1e-10
                scalefac = 1;
              else
                scalefac = abs(PZG(1).PoleLocs(kp));
              end
              [ mindist, mindist_ndx ] = ...
                  min( abs( PZG(1).PoleLocs(kp) - ppp(avail_p_ndxs) ) );
              if mindist > scalefac*1e-7
                tf_is_ok = 0;
                break
              else
                avail_p_ndxs(mindist_ndx) = [];
              end
            end
            if tf_is_ok
              avail_z_ndxs = (1:numel(PZG(1).ZeroLocs));
              for kz = 1:numel(PZG(1).ZeroLocs)
                if abs(PZG(1).ZeroLocs(kz)) < 1e-10
                  scalefac = 1;
                else
                  scalefac = abs(PZG(1).ZeroLocs(kz));
                end
                [ mindist, mindist_ndx ] = ...
                    min( abs( PZG(1).ZeroLocs(kz) - zzz(avail_z_ndxs) ) );
                if mindist > scalefac*1e-7
                  tf_is_ok = 0;
                  break
                else
                  avail_z_ndxs(mindist_ndx) = [];
                end
              end
            end
          end
          if ~tf_is_ok
            errdlg_h = ...
              errordlg( ...
                {['Conversion from zero/pole/gain (ZPK) model ' ...
                   'to transfer-function (TF)']; ...
                 'is, in this case, a very poorly-conditioned operation.'; ...
                 ' '; ...
                 'The "reverse" conversion of this unfactored TF model'; ...
                 'back into ZPK form most likely WILL NOT ACCURATELY'; ...
                 'reproduce the original ZPK model.'; ...
                 ' ';'     Click "OK" to continue.'}, ...
                 'PZGui Warning:  Poorly-Conditioned Operation','modal');
            uiwait(errdlg_h)
          end
          assignin('base', var_name, ct_tf );
          
        else
          dt_tf = tf( PZG(2).Gain*poly(PZG(2).ZeroLocs), ...
                      poly(PZG(2).PoleLocs), PZG(2).Ts );
          dt_tf.iodelay = PZG(2).PureDelay;
          if iscell( dt_tf.num )
            NNN = dt_tf.num{1};
          else
            NNN = dt_tf.num;
          end
          zzz = roots(NNN);
          if iscell( dt_tf.den )
            DDD = dt_tf.den{1};
          else
            DDD = dt_tf.den;
          end
          ppp = roots(DDD);
          % Compare recovered poles and zeros to the originals.
          tf_is_ok = 1;
          if ( numel(zzz) ~= numel(PZG(2).ZeroLocs) ) ...
            ||( numel(ppp) ~= numel(PZG(2).PoleLocs) )
            tf_is_ok = 0;
          else
            avail_p_ndxs = (1:numel(PZG(2).PoleLocs));
            for kp = 1:numel(PZG(2).PoleLocs)
              if abs(PZG(2).PoleLocs(kp)) < 1e-10
                scalefac = 1;
              else
                scalefac = abs(PZG(2).PoleLocs(kp));
              end
              [ mindist, mindist_ndx ] = ...
                  min( abs( PZG(2).PoleLocs(kp) - ppp(avail_p_ndxs) ) );
              if mindist > scalefac*1e-7
                tf_is_ok = 0;
                break
              else
                avail_p_ndxs(mindist_ndx) = [];
              end
            end
            if tf_is_ok
              avail_z_ndxs = (1:numel(PZG(2).ZeroLocs));
              for kz = 1:numel(PZG(2).ZeroLocs)
                if abs(PZG(2).ZeroLocs(kz)) < 1e-10
                  scalefac = 1;
                else
                  scalefac = abs(PZG(2).ZeroLocs(kz));
                end
                [ mindist, mindist_ndx ] = ...
                    min( abs( PZG(2).ZeroLocs(kz) - zzz(avail_z_ndxs) ) );
                if mindist > scalefac*1e-7
                  tf_is_ok = 0;
                  break
                else
                  avail_z_ndxs(mindist_ndx) = [];
                end
              end
            end
          end
          if isequal( tf_is_ok, 0 )
            errdlg_h = ...
              errordlg( ...
                {['Conversion from zero/pole/gain (ZPK) model ' ...
                   'to transfer-function (TF)']; ...
                 'is, in this case, a poorly-conditioned operation.'; ...
                 ' '; ...
                 'The "reverse" conversion of this TF model'; ...
                 'back to ZPK most likely WILL NOT ACCURATELY'; ...
                 'reproduce the original ZPK model.'; ...
                 ' ';'     Click "OK" to continue.'}, ...
                 'DPZGUI WARNING:  Poorly-Conditioned Operation','modal');
            uiwait(errdlg_h)
          end
          assignin('base', var_name, dt_tf );
        end
        
      case 'S-S'
        % Convert ZPK to SS.
        if strcmpi( ct_dt_str,'C-T Model in PZGUI')
          ct_ss = pzg_moda(1);
          if ~isempty(ct_ss)
            if any( abs(imag(eig(ct_ss.a))) > 1e-14 )
              if ~strcmpi( ss_form,'modal-canonic')
                T1 = [(1+1i)/2 (1-1i)/2; (1-1i)/2 (1+1i)/2];
                for k = 1:size(ct_ss.a,1)-1
                  a_2x2 = ct_ss.a(k:k+1,k:k+1);
                  ad_2x2 = T1*a_2x2*T1';
                  eig_2x2 = diag(ad_2x2);
                  % First eigenvalue must have positive imaginary part.
                  if imag(eig_2x2(1)) < 0
                    T1 = T1';
                    ad_2x2 = T1*a_2x2*T1';
                    eig_2x2 = diag(ad_2x2);
                  end
                  if ~isreal(eig_2x2) ...
                    && ( abs( a_2x2(1,1) - real(eig_2x2(1)) ) < 1e-14 )
                    T2 = [ 1 1; eig_2x2(1) eig_2x2(2) ];
                    T2x2 = T2 * T1;
                    b_2 = ct_ss.b(k:k+1);
                    c_2 = ct_ss.c(k:k+1);
                    ct_ss.a(k:k+1,k:k+1) = T2x2*a_2x2/T2x2;
                    ct_ss.b(k:k+1) = T2x2*b_2;
                    ct_ss.c(k:k+1) = c_2/T2x2;
                    if abs(ct_ss.c(k+1))  ...
                        < max( 1e-15*abs(ct_ss.c(k)), 10*eps )
                      ct_ss.c(k+1) = 0;
                    end
                    ct_ss.b(k:k+1) = ct_ss.b(k:k+1) * ct_ss.c(k);
                    ct_ss.c(k) = 1;
                  end
                end
              end
            end
            assignin('base', var_name, ct_ss );
          else
            disp(['pzgui:  Numerical accuracy issues ' ...
                  '-- possibly too many repeated poles ??']);
            disp(['        NOT writing to variable "' var_name '".']);
          end
        else
          dt_ss = pzg_moda(2,1);
          if ~isempty(dt_ss)
            if any( abs(imag(eig(dt_ss.a))) > 1e-14 )
              ans_str = 'Modal-Canonic';
              % ans_str = ...
              %   questdlg( ...
              %     {'The default s-s A-matrix format is "modal canonic",'; ...
              %      'in which complex pole-pairs correspond to:'; ...
              %      '   [alpha -beta; beta alpha]'; ...
              %      ' '; ...
              %      'Do you prefer the model in a "classic modal" form,'; ...
              %      'in which complex pole-pairs correspond to:'; ...
              %      '   [ 0 1; P1 P2 ]'; ...
              %      'with discrete-time parameters P1 and P2?'; ...
              %      ' '}, ...
              %   'Output Format Preference', ...
              %   'Modal-Canonic','Classic Modal','Modal-Canonic');
              if isequal( ans_str,'Classic Modal')
                T1 = [(1+1i)/2 (1-1i)/2; (1-1i)/2 (1+1i)/2];
                for k = 1:size(dt_ss.a,1)-1
                  a_2x2 = dt_ss.a(k:k+1,k:k+1);
                  ad_2x2 = T1*a_2x2*T1';
                  eig_2x2 = diag(ad_2x2);
                  % First eigenvalue must have positive imaginary part.
                  if imag(eig_2x2(1)) < 0
                    T1 = T1';
                    ad_2x2 = T1*a_2x2*T1';
                    eig_2x2 = diag(ad_2x2);
                  end
                  if ~isreal(eig_2x2) ...
                    && ( abs( a_2x2(1,1) - real(eig_2x2(1)) ) < 1e-14 )
                    T2 = [ 1 1; eig_2x2(1) eig_2x2(2) ];
                    T2x2 = T2 * T1;
                    b_2 = dt_ss.b(k:k+1);
                    c_2 = dt_ss.c(k:k+1);
                    dt_ss.a(k:k+1,k:k+1) = T2x2*a_2x2/T2x2;
                    dt_ss.b(k:k+1) = T2x2*b_2;
                    dt_ss.c(k:k+1) = c_2/T2x2;
                    if abs(dt_ss.c(k+1)) ...
                        < max( 1e-15*abs(dt_ss.c(k)), 10*eps )
                      dt_ss.c(k+1) = 0;
                    end
                    dt_ss.b(k:k+1) = dt_ss.b(k:k+1) * dt_ss.c(k);
                    dt_ss.c(k) = 1;
                  end
                end
              end
            end
            assignin('base', var_name, dt_ss );
          else
            disp(['dpzgui:  Numerical accuracy issues ' ...
                  '-- possibly too many repeated poles ??']);
            disp(['        NOT writing to variable "' var_name '".']);
          end
        end
    end
    return
    
  case {'load model from file', ...
        'import model from workspace', ...
        'generate random flexible-structure', ...
        'delete all poles & zeros'}
    load_mdl = [];
    if strcmpi(ReqStr,'delete all poles & zeros')
      % Make sure the user really wants to clear the model.
      cbf_name = get( gcbf,'name');
      if ~isempty( strfind( cbf_name,'Continuous') )
        Mcb = 1;
        quest_str = ' CONTINUOUS-TIME ';
      else
        Mcb = 2;
        quest_str = ' DISCRETE-TIME ';
      end
      answer = ...
        questdlg( ...
          {['Are you sure you want to clear the' quest_str 'model?']; ...
           ' '}, ...
          'Are You Sure ???', ...
          'Yes, Clear It','No, Cancel','No, Cancel');
      if ~isequal( answer,'Yes, Clear It')
        return
      end
      load_str = 'clear model';
      load_mdl.z = [];
      load_mdl.p = [];
      load_mdl.k = 1;
      if Mcb == 1
        load_mdl.ts = 0;
      else
        load_mdl.ts = PZG(2).Ts;
      end
    elseif strcmpi(ReqStr,'load model from file')
      load_str = 'MAT-file';
    elseif strcmpi(ReqStr,'import model from workspace')
      load_str = 'workplace variable';
    elseif strcmpi(ReqStr,'generate random flexible-structure')
      load_str = 'generate random model';
    end
    
    in_nr = 1;     %#ok<NASGU>
    out_nr = 1;    %#ok<NASGU>
    
    if strcmpi( load_str,'MAT-file')
      if ~isfield(PZG(1),'load_dir') ...
        && isfield(PZG(1),'save_dir') ...
        && ischar(PZG(1).save_dir) && exist(PZG(1).save_dir,'dir')
        PZG(1).load_dir = PZG(1).save_dir;
      end
      if isfield(PZG(1),'load_dir') ...
        && ischar(PZG(1).load_dir) && exist(PZG(1).load_dir,'dir')
        load_dir = fullfile( PZG(1).load_dir,'*.mat');
      else
        load_dir = ['.' filesep '*.mat'];
      end
      [filename,filepath] = ...
        uigetfile('*.mat','Select a MAT-file to Load', load_dir );
      if ~ischar(filename) || isempty(filename)
        return
      end
      msgbox_h = ...
        msgbox({'  Loading and analyzing the specified file.'; ...
                ' ';'     Please wait ...'}, ...
                'Please Wait ...');
      drawnow
      PZG0 = load( fullfile(filepath,filename) );
      if isfield( PZG0,'PZG') && isstruct(PZG0.PZG)
        load_mdl = PZG0.PZG;
        load_mdl(1).load_dir = filepath;
      elseif isfield(PZG0,'PZG0') && isstruct(PZG0.PZG0)
        load_mdl = PZG0.PZG0;
        load_mdl(1).load_dir = filepath;
      else
        filevar_fn = fieldnames( PZG0 );
        if numel(filevar_fn) == 1
          load_mdl = PZG0.(filevar_fn{1});
          if isstruct(load_mdl) && ( numel(load_mdl) == 2 ) ...
            && isfield( load_mdl,'PoleLocs')
            load_mdl(1).load_dir = filepath;
          end
        else
          [ load_mdl, error_str ] = local_struct2lti( PZG0 );
          if ~isempty(error_str)
            if ischar(error_str)
              err_cell = { error_str;' ';'  Click "OK" to continue.'};
            else
              err_cell = [ error_str;{' '};{'  Click "OK" to continue.'}];
            end
            errdlg_h = errordlg( err_cell, 'Cannot Parse File.','modal');
            uiwait(errdlg_h)
            if ishandle(msgbox_h)
              close(msgbox_h)
            end
            return
          end
        end
      end
      if ishandle(msgbox_h)
        close(msgbox_h)
      end
    end
    
    if strcmpi( load_str,'workplace variable')
      varname_from_list = local_varname_from_list;
      if isempty(varname_from_list) || ~ischar(varname_from_list)
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        return
      end
      varname_cellstr = {varname_from_list};
      if isempty(varname_cellstr) 
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        return
      elseif isempty(varname_cellstr{1})
        msg_h = ...
          msgbox({'No name specified.  Canceling the load operation.'; ...
           ' ';'    Click "OK" to continue ...';' '}, ...
                 'No name specified.','modal');
        uiwait(msg_h)
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        return
      end
      
      varname_str = varname_cellstr{1};
      if evalin('base',['~exist(''' varname_str ''',''var'')'])
        global_vars = whos('global');
        match_found = 0;
        for k = 1:numel(global_vars)
          if strcmp( varname_str, global_vars(k).name )
            match_found = 1;
          end
        end
        if match_found
          eval(['global ' varname_str ])
          eval(['load_mdl = ' varname_str ';' ]);
        else
          if ishandle(msgbox_h)
            close(msgbox_h)
          end
          errdlg_h = ...
            errordlg({'Specified named variable is not found.'; ...
                      'Canceling the load operation.'; ...
                      ' ';'    Click "OK" to continue ...';' '}, ...
                     'Variable Not Found','modal');
          uiwait(errdlg_h)
          return
        end
      else
        load_mdl = evalin('base', varname_str );
      end
    end
    
    if strcmpi( load_str,'generate random model')
      if ~isempty( strfind( get(gcbf,'name'),'iscrete') )
        rss_mdl = pzg_rss(1);
      else
        rss_mdl = pzg_rss(0);
      end
      if isa(rss_mdl,'zpk')
        if iscell(rss_mdl.z)
          load_mdl.z = rss_mdl.z{1};
        else
          load_mdl.z = rss_mdl.z;
        end
        if iscell(rss_mdl.p)
          load_mdl.p = rss_mdl.p{1};
        else
          load_mdl.p = rss_mdl.p;
        end
        load_mdl.k = rss_mdl.k(1);
        load_mdl.ts = rss_mdl.ts;
      else
        load_mdl = rss_mdl;
        if ~isstruct(load_mdl) && ~isa( load_mdl,'ss') && ~isa( load_mdl,'zpk')
          return
        end
        if iscell(load_mdl.z)
          load_mdl.z = load_mdl.z{1};
        end
      end
      if ~isempty( strfind( get(gcbf,'name'),'iscrete') )
        % Convert to discrete-time.
        if iscell(load_mdl.z)
          load_mdl.z = load_mdl.z{1,1};
          load_mdl.k = load_mdl.k(1,1);
        end
      end
      if isempty(load_mdl)
        % User canceled.
        return
      end
    end
    
    if isstruct( load_mdl ) ...
      && ( numel(load_mdl) == 2 ) ...
      && isfield( load_mdl,'PZGUIname') ...
      && isfield( load_mdl,'Domain') ...
      && isfield( load_mdl,'ZeroLocs') ...
      && isfield( load_mdl,'PoleLocs') ...
      && isfield( load_mdl,'Gain') ...
      && isfield( load_mdl,'Ts') ...
      && isfield( load_mdl,'PureDelay') ...
      && isnumeric(load_mdl(1).ZeroLocs) && isnumeric(load_mdl(2).ZeroLocs) ...
      && isnumeric(load_mdl(1).PoleLocs) && isnumeric(load_mdl(2).PoleLocs) ...
      && isnumeric(load_mdl(1).Gain) && isnumeric(load_mdl(2).Gain) ...
      && isnumeric(load_mdl(1).Ts) && isnumeric(load_mdl(2).Ts) ...
      && isnumeric(load_mdl(1).PureDelay)&&isnumeric(load_mdl(2).PureDelay) ...
      && ( numel(load_mdl(1).Gain) == 1 ) ...
      && ( numel(load_mdl(2).Gain) == 1 ) ...
      && ( numel(load_mdl(1).Ts) == 1 ) ...
      && ( numel(load_mdl(2).Ts) == 1 ) ...
      && ( numel(load_mdl(1).PureDelay) == 1 ) ...
      && ( numel(load_mdl(2).PureDelay) == 1 ) ...
      && ( load_mdl(1).PureDelay >= 0 ) ...
      && ( load_mdl(2).PureDelay >= 0 ) ...
      && ( numel(load_mdl(1).PoleLocs) >= numel(load_mdl(1).ZeroLocs) ) ...
      && ( numel(load_mdl(2).PoleLocs) >= numel(load_mdl(2).ZeroLocs) )
      % Saved PZG object is validated (well enough) if all the above are true.
      if isempty(strfind( get(gcbf,'name'),'iscrete'))
        default_choice = 'Load C-T model only';
        dom_ndx = 1;
      else
        default_choice = 'Load D-T model only';
        dom_ndx = 2;
      end
      quest_str = ...
        questdlg( ...
         {'The selected file contains both a continuous-time (C-T)'; ...
          'and a discrete-time (D-T) model.'; ...
          ' '; ...
          'Choose whether to load just one of these, or both.'; ...
          ' '; ...
          'NOTE:  There is no "undo" for this operation.'; ...
          ' '}, ...
          'Choose Among the "Load" Option', ...
          'Load both C-T and D-T', default_choice,'Cancel', default_choice );
      if strcmpi( quest_str,'Cancel')
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        return
      end

      if strcmp( quest_str, default_choice )
        load_both_models = 0;
        save_undo_info(dom_ndx);
        PZG(dom_ndx).ZeroLocs = load_mdl(dom_ndx).ZeroLocs;
        PZG(dom_ndx).PoleLocs = load_mdl(dom_ndx).PoleLocs;
        PZG(dom_ndx).Gain = load_mdl(dom_ndx).Gain;
        PZG(dom_ndx).Ts = load_mdl(dom_ndx).Ts;
        PZG(dom_ndx).PureDelay = load_mdl(dom_ndx).PureDelay;
        PZG(dom_ndx).load_dir = filepath;
        if dom_ndx == 1
          set([ pzg_fndo( 1,(1:14),'sLDLG_Preview','sLDLG Preview'); ...
                pzg_fndo( 1,(1:14),'sPID_Preview','sPID Preview'); ...
                pzg_fndo( 1,(1:14),'sGain_Preview','sGain Preview') ], ...
              'visible','off');
        else
          set([ pzg_fndo( 2,(1:14),'zLDLG_Preview','sLDLG Preview'); ...
                pzg_fndo( 2,(1:14),'zPID_Preview','sPID Preview'); ...
                pzg_fndo( 2,(1:14),'zGain_Preview','sGain Preview') ], ...
              'visible','off');
        end
      else
        load_both_models = 1;
        for k = 1:2
          save_undo_info(k);
          PZG(k).ZeroLocs = load_mdl(k).ZeroLocs;
          PZG(k).PoleLocs = load_mdl(k).PoleLocs;
          PZG(k).Gain = load_mdl(k).Gain;
          PZG(k).Ts = load_mdl(k).Ts;
          PZG(k).PureDelay = load_mdl(k).PureDelay;
          PZG(k).load_dir = filepath;
        end
          set([ pzg_fndo( 1,(1:14),'sLDLG_Preview','sLDLG Preview'); ...
                pzg_fndo( 1,(1:14),'sPID_Preview','sPID Preview'); ...
                pzg_fndo( 1,(1:14),'sGain_Preview','sGain Preview'); ...
                pzg_fndo( 2,(1:14),'zLDLG_Preview','sLDLG Preview'); ...
                pzg_fndo( 2,(1:14),'zPID_Preview','sPID Preview'); ...
                pzg_fndo( 2,(1:14),'zGain_Preview','sGain Preview') ], ...
              'visible','off');
      end
      PZG(1).Ts = PZG(2).Ts;
      
      % Un-link C-T and D-T models, turn off Fixed-DC gain.
      if ~isempty(ct_pzgui_h)
        link_chkbox_h = ...
          [ findobj( ct_pzgui_h,'string','D-T Link by:'); ...
            findobj( ct_pzgui_h,'string','C-T Fix DC checkbox') ];
        if ~isempty(link_chkbox_h)
          set( link_chkbox_h,'value', 0 )
        end
      end
      if ~isempty(dt_pzgui_h)
        link_chkbox_h = ...
          [ findobj( dt_pzgui_h,'string','C-T Link by:'); ...
            findobj( dt_pzgui_h,'string','D-T Fix DC checkbox') ];
        if ~isempty(link_chkbox_h)
          set( link_chkbox_h,'value', 0 )
        end
      end
      
      if load_both_models
        PZG(1).recompute_frf = 0;
        pzg_cntr(1);
        pzg_bodex(1);
        local_refresh_all_plots(1)
        PZG(2).recompute_frf = 0;
        pzg_cntr(2);
        pzg_bodex(2);
        local_refresh_all_plots(2)
        if ~isempty(ct_pzgui_h)
          zmintcpt('open zoom', ct_pzgui_h )
        end
        if ~isempty(dt_pzgui_h)
          zmintcpt('open zoom', dt_pzgui_h )
        end
      elseif dom_ndx == 1
        PZG(1).recompute_frf = 0;
        pzg_cntr(1);
        pzg_bodex(1);
        local_refresh_all_plots(1)
        if ~isempty(ct_pzgui_h)
          zmintcpt('open zoom', ct_pzgui_h )
        end
      else
        PZG(2).recompute_frf = 0;
        pzg_cntr(2);
        pzg_bodex(2);
        local_refresh_all_plots(2)
        if ~isempty(dt_pzgui_h)
          zmintcpt('open zoom', dt_pzgui_h )
        end
      end

      if ishandle(msgbox_h)
        close(msgbox_h)
      end
      return
    end

    % Convert struct-variable to LTI object.
    if isa( load_mdl,'struct')
      [ load_mdl, error_str ] = local_struct2lti( load_mdl );

      if ishandle(msgbox_h)
        close(msgbox_h)
      end
      if ~isempty(error_str)
        if ischar(error_str)
          err_cell = { error_str;' ';'  Click "OK" to continue.'};
        else
          err_cell = [ error_str;{' '};{'  Click "OK" to continue.'}];
        end
        errdlg_h = errordlg( err_cell, [ mfilename ' Error'],'modal');
        uiwait(errdlg_h)
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        return
      end
    end

    if isempty(load_mdl)
      ans_str = ...
        questdlg( ...
          {'The selected model is empty.';' '; ...
           'Do you want to continue loading?';' '}, ...
          'Empty Model', ...
          'Yes, Load Empty Model','No, Cancel','No, Cancel');
      if ~strcmpi( ans_str,'Yes, Load Empty Model')
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        return
      end
    end
    
    msgbox_h = ...
      msgbox({' Loading the specified model.   Please wait ...'}, ...
              'Please Wait ...','replace');

    if isa( load_mdl,'ss')
      m = size( load_mdl.b, 2 );
      p = size( load_mdl.c, 1 );

      [ out_nr, in_nr, cancel ] = local_get_io_nrs( p, m, load_mdl.ts );
      if cancel
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        return
      end
      if isempty(load_mdl)
        mdl = load_mdl;
        Z = [];
        P = [];
        K = 1;
      else
        mdl = load_mdl(out_nr,in_nr);
        % For diagonal ss-model, remove unobservable or uncontrollable poles.
        if norm( mdl.a - diag(diag(mdl.a)) ) < 1e-14*norm(mdl.a)
          % A-matrix is diagonal.
          unctrb_unobsv_ndx = ...
            find( ( mdl.b == 0 ) | ( mdl.c' == 0 ) ); 
          if ~isempty(unctrb_unobsv_ndx)
            A = mdl.a;
            A(unctrb_unobsv_ndx,:) = [];
            A(:,unctrb_unobsv_ndx) = [];
            B = mdl.b;
            B(unctrb_unobsv_ndx,:) = [];
            C = mdl.c;
            C(:,unctrb_unobsv_ndx) = [];
            mdl = ss( A, B, C, mdl.d, mdl.ts );
          end
        end
        
        [ Z, P, K ] = ss2zp( mdl.a, mdl.b, mdl.c, mdl.d, 1 );
        % Remove unobservable/uncontrollable poles.
        LFpt = 0;
        HFpt = 100i*max(abs(imag(P)));
        if mdl.ts > 0
          LFpt = 1;
          HFpt = -1;
        end
        if ~isempty(Z)
          for k = numel(P): -1: 1
            if isempty(Z)
              continue
            end
            this_pole = P(k);
            [ dist, z_ndx ] = min( abs( P(k) - Z ) );
            this_zero = Z(z_ndx);
            if dist < 1e-14
              P(k) = [];
              Z(z_ndx) = [];
            elseif ( dist < 0.001 ) ...
              &&( ( isreal(P(k)) && isreal(Z(z_ndx)) ) ...
                 ||( ~isreal(P(k)) && ~isreal(Z(z_ndx)) ) ) 
              if mdl.ts ~= 0
                if abs(angle(this_pole)) > 1e-10
                  MFpt = exp( 1i*angle(this_pole) );
                else
                  MFpt = exp( 1i*1e-10 );
                end
              else
                if abs(imag(this_pole)) > 1e-10
                  MFpt = 1i*imag(this_pole);
                else
                  MFpt = 1i*1e-10;
                end
              end
              LFmag = abs( ( LFpt-this_zero ) / ( LFpt-this_pole ) );
              HFmag = abs( ( HFpt+this_zero ) / ( HFpt+this_pole ) );
              MFmag = abs( ( MFpt-this_zero ) / ( MFpt-this_pole ) );
              max_magdb_diff = ...
                20*max( abs(log10(HFmag)-log10(LFmag)), ...
                        max( abs(log10(HFmag)-log10(MFmag)), ...
                             abs(log10(MFmag)-log10(LFmag)) ) );
              threshold_diff = 1e-4; % (dB)
              if max_magdb_diff < threshold_diff
                P(k) = [];
                Z(z_ndx) = [];
              end
            end
          end
        end
        
        if iscell(Z)
          Z = Z{1};
        end
        Z( isinf(Z) ) = [];
        Z( isnan(Z) ) = [];
        if iscell(P)
          P = P{1};
        end
        if ~isempty(Z)
          if mdl.ts == 0
            Z( abs(Z)<1e-12 ) = 0;
          else
            Z( abs(Z-1)<1e-12 ) = 1;
          end
        end
        for kz = 1:numel(Z)
          if ( abs(imag(Z(kz))) > 1e-9 ) ...
            &&( abs( real(Z(kz))/imag(Z(kz)) ) < 1e-14 )
            Z(kz) = 1i*imag(Z(kz));
          elseif ( abs(real(Z(kz))) > 1e-9 ) ...
            &&( abs( imag(Z(kz))/real(Z(kz)) ) < 1e-14 )
            Z(kz) = real(Z(kz));
          end
        end
        
        % Verify non-real-valued poles and zeros occur in complex-conj-pairs.
        matchedZ = local_matched_conj_pairs( Z );
        matchedP = local_matched_conj_pairs( P );
        if ~matchedZ || ~matchedP
          % At least one non-real-valued zero is not in a conj pair.
          if ishandle(msgbox_h)
            close(msgbox_h)
          end
          errdlg_h = ...
            errordlg( ...
              {'At least one pole or zero is non-real-valued but is'; ...
               'not part of a complex-conjugate pair.'; ...
               ' '; ...
               '   Aborting the "Load Model" operation.'}, ...
              'Unpaired Non-Real Pole or Zero','modal');
          uiwait(errdlg_h)
          return
        end
        
        % Equalize midrange-frequency gains.
        if mdl.ts == 0
          nonzero_PZ = [ Z( abs(imag(Z)) > 1e-3 ); P( abs(imag(P)) > 1e-3 ) ];
          if isempty(nonzero_PZ)
            mid_freq = 1;
          else
            mid_freq = median( imag(abs(nonzero_PZ)) ) + (1+rand(1))*pi;
          end
          eq_pt = 1i * mid_freq;
        else
          for kz = 1:numel(Z)
            if abs( abs(Z(kz))-1 ) < 1e-13
              Z(kz) = exp( 1i*angle(Z(kz)) );
            end
          end
          nonunity_PZ = [ Z( abs(Z-1) > 1e-3 ); P( abs(P-1) > 1e-3 ) ];
          if isempty(nonunity_PZ)
            mid_angle = pi/5;
          else
            mid_angle = median( abs(angle(nonunity_PZ)) ) + (1+rand(1))/10*pi;
          end
          eq_pt = exp( 1i * mid_angle );
        end
        ss_lf_gain = freqresp( mdl, eq_pt );
        if K == 0
          K = 1;
        end
        if abs(ss_lf_gain) > 1e-10
          zpk_lf_gain = log(K);
          for kp = 1:numel(P)
            zpk_lf_gain = zpk_lf_gain - log( eq_pt - P(kp) );
            if numel(Z) >= kp
              zpk_lf_gain = zpk_lf_gain + log( eq_pt - Z(kp) );
            end
          end
          zpk_lf_gain = exp(zpk_lf_gain);
          
          K = K * abs(ss_lf_gain)/abs(zpk_lf_gain);
        end
      end

      % De-Link D-T from C-T
      link_h = [ findobj( allchild(0),'string','D-T Link by:'); ...
                 findobj( allchild(0),'string','C-T Link by:') ];
      if ~isempty(link_h)
        set( link_h,'value', 0 );
      end
      if mdl.ts == 0
        fixdc_h = findobj( allchild(0),'tag','C-T Fix DC checkbox');
        if ~isempty(fixdc_h)
          set( fixdc_h,'value', 0 )
        end
        save_undo_info(1)
        PZG(1).ZeroLocs = Z;
        PZG(1).PoleLocs = P;
        PZG(1).Gain = K;
        PZG(1).PureDelay = local_get_delay( mdl, 1, 1, 1, 1 );

        PZG(1).recompute_frf = 0;
        pzg_cntr(1);
        pzg_bodex(1);
        local_refresh_all_plots(1)
        if ~isempty(ct_pzgui_h)
          zmintcpt('open zoom', ct_pzgui_h )
        end
      else
        fixdc_h = findobj( allchild(0),'tag','D-T Fix DC checkbox');
        if ~isempty(fixdc_h)
          set( fixdc_h,'value', 0 )
        end
        save_undo_info(2)
        PZG(2).ZeroLocs = Z;
        PZG(2).PoleLocs = P;
        PZG(2).Gain = K;
        if mdl.ts > 0
          PZG(1).Ts = mdl.ts;
          PZG(2).Ts = mdl.ts;
        else
          PZG(1).Ts = 1;
          PZG(2).Ts = 1;
        end
        PZG(2).PureDelay = local_get_delay( mdl, 1, 1, 1, 1 );

        PZG(2).recompute_frf = 0;
        pzg_cntr(2);
        pzg_bodex(2);
        local_refresh_all_plots(2)
        if ~isempty(dt_pzgui_h)
          zmintcpt('open zoom', dt_pzgui_h )
        end
      end
      if ishandle(msgbox_h)
        close(msgbox_h)
      end
      return

    elseif isa( load_mdl,'tf')

      m = size( load_mdl.num, 2 );
      p = size( load_mdl.num, 1 );
      [ out_nr, in_nr, cancel ] = local_get_io_nrs( p, m, load_mdl.ts );
      if cancel
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        return
      end
      if isempty(load_mdl)
        mdl = load_mdl;
        this_num = 1;
        this_den = 1;
      else
        mdl = load_mdl(out_nr,in_nr);
        this_num = mdl.num;
        if iscell(this_num)
          this_num = this_num{1};
        end
        while( this_num(1) == 0 ) && ( numel(this_num) > 1 )
          this_num(1) = [];
        end
        this_den = mdl.den;
        if iscell(this_den)
          this_den = this_den{1};
        end
      end

      % De-Link D-T from C-T
      link_h = [ findobj( allchild(0),'string','D-T Link by:'); ...
                 findobj( allchild(0),'string','C-T Link by:') ];
      if ~isempty(link_h)
        set( link_h,'value', 0 );
      end
      
      if mdl.ts == 0
        fixdc_h = findobj( allchild(0),'tag','C-T Fix DC checkbox');
        if ~isempty(fixdc_h)
          set( fixdc_h,'value', 0 )
        end
        save_undo_info(1)
        Z = roots( this_num );
        if numel(Z) > 3
          for kz = 1:numel(Z)
            if abs(Z(kz)) < 2e-8
              Z(kz) = 0;
            elseif ( abs(imag(Z(kz))) >= 1e-8 ) ...
              &&( abs( real(Z(kz))/imag(Z(kz)) ) < 1e-14 )
              Z(kz) = 1i*imag(Z(kz));
            elseif ( abs(real(Z(kz))) >= 1e-8 ) ...
              &&( abs( imag(Z(kz))/real(Z(kz)) ) < 1e-14 )
              Z(kz) = real(Z(kz));
            end
          end
        end
        % Verify non-real-valued poles and zeros occur in complex-conj-pairs.
        matchedZ = local_matched_conj_pairs( Z );
        if ~matchedZ
          % At least one non-real-valued zero is not in a conj pair.
          if ishandle(msgbox_h)
            close(msgbox_h)
          end
          errdlg_h = ...
            errordlg( ...
              {'At least one zero is non-real-valued but is'; ...
               'not part of a complex-conjugate pair.'; ...
               ' '; ...
               '   Aborting the "Load Model" operation.'}, ...
              'Unpaired Non-Real Pole or Zero','modal');
          uiwait(errdlg_h)
          return
        end

        P = roots( this_den );
        if numel(P) > 3
          % Check for repeated poles.
          for kp = 1:numel(P)
            near_ndxs = find( ( abs( P - P(kp) )./max(1,abs(P)) ) < 1e-7 );
            if numel(near_ndxs) > 1
              P(near_ndxs) = sum( P(near_ndxs) )/numel(near_ndxs);
            end
          end
          for kp = 1:numel(P)
            if abs(P(kp)) < 2e-9
              P(kp) = 0;
            elseif ( abs(imag(P(kp))) >= 1e-9 ) ...
              &&( abs( real(P(kp))/imag(P(kp)) ) < 1e-14 )
              P(kp) = 1i*imag(P(kp));
            elseif ( abs(real(P(kp))) >= 1e-9 ) ...
              &&( abs( imag(P(kp))/real(P(kp)) ) < 1e-14 )
              P(kp) = real(P(kp));
            end
          end
        end
        % Verify non-real-valued poles and zeros occur in complex-conj-pairs.
        matchedP = local_matched_conj_pairs( P );
        if ~matchedP
          % At least one non-real-valued pole is not in a conj pair.
          if ishandle(msgbox_h)
            close(msgbox_h)
          end
          errdlg_h = ...
            errordlg( ...
              {'At least one pole is non-real-valued but is'; ...
               'not part of a complex-conjugate pair.'; ...
               ' '; ...
               '   Aborting the "Load Model" operation.'}, ...
              'Unpaired Non-Real Pole or Zero','modal');
          uiwait(errdlg_h)
          return
        end
        PZG(1).ZeroLocs = Z;
        PZG(1).PoleLocs = P;

        PZG(1).Gain = this_num(1);
        PZG(1).PureDelay = local_get_delay( mdl, 1, 1, 1, 1 );
        

        PZG(1).recompute_frf = 0;
        pzg_cntr(1);
        pzg_bodex(1);
        local_refresh_all_plots(1)
        if ~isempty(ct_pzgui_h)
          zmintcpt('open zoom', ct_pzgui_h )
        end
      else
        fixdc_h = findobj( allchild(0),'tag','D-T Fix DC checkbox');
        if ~isempty(fixdc_h)
          set( fixdc_h,'value', 0 )
        end
        save_undo_info(2)
        Z = roots( this_num );
        if numel(Z) > 3
          for kz = 1:numel(Z)
            if abs(Z(kz)-1) < 2e-8
              Z(kz) = 1;
            elseif ( abs(imag(Z(kz))) >= 1e-8 ) ...
              &&( abs( real(Z(kz))/imag(Z(kz)) ) < 1e-14 )
              Z(kz) = 1i*imag(Z(kz));
            elseif ( abs(real(Z(kz))) >= 1e-8 ) ...
              &&( abs( imag(Z(kz))/real(Z(kz)) ) < 1e-14 )
              Z(kz) = real(Z(kz));
            end
            if abs( abs(Z(kz))-1 ) < 1e-9
              Z(kz) = exp( 1i*angle(Z(kz)) );
            end
          end
        end
        % Verify non-real-valued poles and zeros occur in complex-conj-pairs.
        matchedZ = local_matched_conj_pairs( Z );
        if ~matchedZ
          % At least one non-real-valued zero is not in a conj pair.
          if ishandle(msgbox_h)
            close(msgbox_h)
          end
          errdlg_h = ...
            errordlg( ...
              {'At least one zero is non-real-valued but is'; ...
               'not part of a complex-conjugate pair.'; ...
               ' '; ...
               '   Aborting the "Load Model" operation.'}, ...
              'Unpaired Non-Real Pole or Zero','modal');
          uiwait(errdlg_h)
          return
        end
        
        P = roots( this_den );
        if numel(P) > 3
          % Check for repeated poles.
          for kp = 1:numel(P)
            near_ndxs = find( ( abs( P - P(kp) )./max(1,abs(P)) ) < 1e-7 );
            if numel(near_ndxs) > 1
              P(near_ndxs) = sum( P(near_ndxs) )/numel(near_ndxs);
            end
          end
          for kp = 1:numel(P)
            if abs(P(kp)-1) < 2e-9
              P(kp) = 1;
            elseif ( abs(imag(P(kp))) >= 1e-9 ) ...
              &&( abs( real(P(kp))/imag(P(kp)) ) < 1e-14 )
              P(kp) = 1i*imag(P(kp));
            elseif ( abs(real(P(kp))) >= 1e-9 ) ...
              &&( abs( imag(P(kp))/real(P(kp)) ) < 1e-14 )
              P(kp) = real(P(kp));
            end
            if abs( abs(P(kp))-1 ) < 1e-9
              P(kp) = exp( 1i*angle(P(kp)) );
            end
          end
        end
        matchedP = local_matched_conj_pairs( P );
        if ~matchedP
          % At least one non-real-valued pole is not in a conj pair.
          if ishandle(msgbox_h)
            close(msgbox_h)
          end
          errdlg_h = ...
            errordlg( ...
              {'At least one pole is non-real-valued but is'; ...
               'not part of a complex-conjugate pair.'; ...
               ' '; ...
               '   Aborting the "Load Model" operation.'}, ...
              'Unpaired Non-Real Pole or Zero','modal');
          uiwait(errdlg_h)
          return
        end
        PZG(2).ZeroLocs = Z;
        if ~isempty(PZG(2).ZeroLocs)
          PZG(2).ZeroLocs( abs(PZG(2).ZeroLocs-1) < 1e-12 ) = 1;
        end
        PZG(2).PoleLocs = P;

        PZG(2).Gain = this_num(1);
        if load_mdl.ts > 0
          PZG(1).Ts = load_mdl.ts;
          PZG(2).Ts = load_mdl.ts;
        else
          PZG(1).Ts = 1;
          PZG(2).Ts = 1;
        end
        PZG(2).PureDelay = local_get_delay( load_mdl, 1, 1, 1, 1 );

        PZG(2).recompute_frf = 0;
        pzg_cntr(2);
        pzg_bodex(2);
        local_refresh_all_plots(2)
        if ~isempty(dt_pzgui_h)
          zmintcpt('open zoom', dt_pzgui_h )
        end
      end
      if ishandle(msgbox_h)
        close(msgbox_h)
      end
      return

    elseif isa( load_mdl,'zpk')
      m = size( load_mdl.z, 2 );
      p = size( load_mdl.z, 1 );
      [ out_nr, in_nr, cancel ] = local_get_io_nrs( p, m, load_mdl.ts );
      if cancel
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        return
      end
      mdl = load_mdl(out_nr,in_nr);

      % Verify non-real-valued poles and zeros occur in complex-conj-pairs.
      matchedZ = local_matched_conj_pairs( mdl.z );
      matchedP = local_matched_conj_pairs( mdl.p );
      if ~matchedZ || ~matchedP
        % At least one non-real-valued zero is not in a conj pair.
        if ishandle(msgbox_h)
          close(msgbox_h)
        end
        errdlg_h = ...
          errordlg( ...
            {'At least one pole or zero is non-real-valued but is'; ...
             'not part of a complex-conjugate pair.'; ...
             ' '; ...
             '   Aborting the "Load Model" operation.'}, ...
            'Unpaired Non-Real Pole or Zero','modal');
        uiwait(errdlg_h)
        return
      end
      
      % De-Link D-T from C-T
      link_h = [ findobj( allchild(0),'string','D-T Link by:'); ...
                 findobj( allchild(0),'string','C-T Link by:') ];
      if ~isempty(link_h)
        set( link_h,'value', 0 );
      end
      
      if load_mdl.ts == 0
        fixdc_h = findobj( allchild(0),'tag','C-T Fix DC checkbox');
        if ~isempty(fixdc_h)
          set( fixdc_h,'value', 0 )
        end
        save_undo_info(1)
        PZG(1).Gain = mdl.k;
        if iscell(mdl.z)
          PZG(1).ZeroLocs = mdl.z{1};
        else
          PZG(1).ZeroLocs = mdl.z;
        end
        if iscell(mdl.p)
          PZG(1).PoleLocs = mdl.p{1};
        else
          PZG(1).PoleLocs = mdl.p;
        end
        PZG(1).PureDelay = local_get_delay( mdl, 1, 1, 1, 1 );

        PZG(1).recompute_frf = 0;
        pzg_cntr(1);
        pzg_bodex(1);
        local_refresh_all_plots(1)
        if ~isempty(ct_pzgui_h)
          zmintcpt('open zoom', ct_pzgui_h )
        end

      else
        fixdc_h = findobj( allchild(0),'tag','D-T Fix DC checkbox');
        if ~isempty(fixdc_h)
          set( fixdc_h,'value', 0 )
        end
        save_undo_info(2)
        PZG(2).Gain = mdl.k;
        if iscell(mdl.z)
          PZG(2).ZeroLocs = mdl.z{1};
        else
          PZG(2).ZeroLocs = mdl.z;
        end
        if iscell(mdl.p)
          PZG(2).PoleLocs = mdl.p{1};
        else
          PZG(2).PoleLocs = mdl.p;
        end
        PZG(2).PureDelay = local_get_delay( mdl, 1, 1, 1, 1 );
        PZG(2).Ts = mdl.ts;
        PZG(1).Ts = mdl.ts;

        PZG(2).recompute_frf = 0;
        pzg_cntr(2);
        pzg_bodex(2);
        local_refresh_all_plots(2)
        if ~isempty(dt_pzgui_h)
          zmintcpt('open zoom', dt_pzgui_h )
        end
      end

    elseif isa( load_mdl,'frd')
      [ p, m, N ] = size( load_mdl.responsedata );  %#ok<ASGLU>
      [ out_nr, in_nr, cancel ] = local_get_io_nrs( p, m, load_mdl.ts );
      if cancel
        if ishandle( msgbox_h )
          close(msgbox_h)
        end
        return
      end
      % De-Link D-T from C-T
      link_h = [ findobj( allchild(0),'string','D-T Link by:'); ...
                 findobj( allchild(0),'string','C-T Link by:') ];
      if ~isempty(link_h)
        set( link_h,'value', 0 );
      end
      
      frf_data = load_mdl.responsedata(out_nr,in_nr,:);
      if load_mdl.ts == 0
        PZG(1).TFEFreqs = load_mdl.frequency(:);
        if isempty(strfind( load_mdl.units,'rad') )
          PZG(1).TFEFreqs = PZG(1).TFEFreqs * (2*pi);
        end
        PZG(1).TFEMag = 20*log10( abs( frf_data(:) ) );
        PZG(1).TFEPhs = angle( frf_data(:) ) * (180/pi);
        
        ui_h = pzg_fndo( 1,[(1:10),12,14],'purgefrd_menu');
        if ~isempty(ui_h)
          set(ui_h,'visible','on');
        end
        % Recompute FRFs based on frequencies loaded from file.
        PZG(1).recompute_frf = 0;
        pzg_cntr(1);
        pzg_bodex(1);
        local_refresh_all_plots(1)
        CT_PZGUI = pzg_fndo( 1, 12,'fig_h');
        if ~isempty(CT_PZGUI)
          zmintcpt('open zoom', CT_PZGUI )
        end
        updatepl
      else
        PZG(2).TFEFreqs = load_mdl.frequency(:);
        if isempty(strfind( load_mdl.units,'rad') )
          PZG(2).TFEFreqs = PZG(2).TFEFreqs * (2*pi);
        end
        PZG(2).TFEMag = 20*log10( abs( frf_data(:) ) );
        PZG(2).TFEPhs = angle( frf_data(:) ) * (180/pi);
        
        % Extend the frequencies up to the Nyquist frequency, if needed.
        del_w = max(diff(PZG(2).TFEFreqs(end-3:end)));
        if PZG(2).TFEFreqs(end) < pi/load_mdl.ts-del_w*1.1
          new_w = ( PZG(2).TFEFreqs(end)+del_w: del_w: 0.9999*pi/load_mdl.ts )';
          new_mag = PZG(2).TFEMag(end)*ones(size(new_w));
          new_phs = PZG(2).TFEPhs(end)*ones(size(new_w));
          PZG(2).TFEFreqs = [ PZG(2).TFEFreqs; new_w ];
          PZG(2).TFEMag = [ PZG(2).TFEMag; new_mag ];
          PZG(2).TFEPhs = [ PZG(2).TFEPhs; new_phs ];
        end
        ui_h = pzg_fndo( 2,[(1:9),11,13,14],'purgefrd_menu');
        if ~isempty(ui_h)
          set(ui_h,'visible','on');
        end

        if ( load_mdl.ts > 0 ) ...
          && ~isequal( PZG(2).Ts, load_mdl.ts )
          PZG(1).Ts = load_mdl.ts;
          PZG(2).Ts = load_mdl.ts;
          msgbox_h2 = ...
            msgbox({'Changing the PZGUI sample period, Ts, to match'; ...
                    'the sample period of the data being loaded.'; ...
                    ' '; ...
                    '   Click "OK" to continue ...'
                    ' '}, ...
                   [mfilename ' Advisory'],'modal');
          uiwait(msgbox_h2)
        end

        PZG(2).recompute_frf = 0;
        pzg_cntr(2);
        pzg_bodex(2);
        local_refresh_all_plots(2)
        DT_PZGUI = pzg_fndo( 2, 13,'fig_h');
        if ~isempty(DT_PZGUI)
          zmintcpt('open zoom', DT_PZGUI )
        end
        dupdatep
      end
      
      if ( load_mdl.ts ~= 0 ) && isempty(DT_PZGUI)
        dpzgui;
      elseif ( load_mdl.ts == 0 ) && isempty(CT_PZGUI)
        pzgui;
      end

      if ishandle( msgbox_h )
        close(msgbox_h)
      end
      return

    else
      errdlg_h = ...
        errordlg({'Cannot parse the input variable.'; ...
                  ' '; ...
                  'Input variable can be a previously-saved PZGUI object.'; ...
                  ' '; ...
                  'Input variable can also be either an "ss"-object,'; ...
                  'a "tf"-object, or an "frd"-object, or should at least'; ...
                  'have the same fieldnames as one of those object types.'; ...
                  ' '; ...
                  'Canceling the load operation.'; ...
                  ' ';'    Click "OK" to continue ...';' '}, ...
                 'Invalid PZGUI Input Data','modal');
      uiwait(errdlg_h)
      if ishandle( msgbox_h )
        close(msgbox_h)
      end
      return
    end
    
    if ishandle( msgbox_h )
      close(msgbox_h)
    end
    
  case 'show/dont show frf computation'
    show_frf_menu_h = pzg_fndo( (1:2),(1:14),'show_dontshow_frf_comp');
    if PZG(1).pzg_show_frf_computation
      set( show_frf_menu_h,'label','Show FRF computation');
      PZG(1).pzg_show_frf_computation = 0;
      PZG(2).pzg_show_frf_computation = 0;
      updtpzln('s')
      pzg_seltxt(1,[],[],0);
      updtpzln('z')
      pzg_seltxt(2,[],[],0);
      if isfield( PZG(1),'frcomp_fig') ...
        && ~isempty( PZG(1).frcomp_fig ) ...
        && isequal( 1, ishandle(PZG(1).frcomp_fig) )
        delete(PZG(1).frcomp_fig)
      end
      PZG(1).frcomp_fig = [];
    else
      set( show_frf_menu_h,'label','Don''t show FRF computation');
      PZG(1).pzg_show_frf_computation = 1;
      PZG(2).pzg_show_frf_computation = 1;
      updtpzln('s')
      if isempty(PZG(1).FrqSelNdx)
        pzg_seltxt( 1, [], [], 0 );
      else
        pzg_seltxt( 1, PZG(1).BodeFreqs(PZG(1).FrqSelNdx), 12, 0 );        
      end
      updtpzln('z')
      if isempty(PZG(2).FrqSelNdx)
        pzg_seltxt( 2, [], [], 0 );
      else
        pzg_seltxt( 2, PZG(2).BodeFreqs(PZG(2).FrqSelNdx), ...
                    12, PZG(2).NegSelect );        
      end
      fr_disp
    end
    freqserv('refresh selected_freq');    

  otherwise
    errdlg_h = ...
      errordlg({'Cannot parse the PZGUI input data.'; ...
                'Canceling the load operation.'; ...
                ' ';'    Click "OK" to continue ...';' '}, ...
               'Invalid PZGUI Input Data','modal');
    uiwait(errdlg_h)
    if ishandle(msgbox_h)
      close(msgbox_h)
    end
    return
    
end    % switch lower(ReqStr)
  
if ishandle(msgbox_h)
  close(msgbox_h)
end

return

function varname_from_list = local_varname_from_list

  global  varname_selection
  varname_selection = '';
  
  varname_from_list = '';
  
  % Make a list of all variables in base workspace and global workspace.
  base_whos = evalin('base','whos');
  global_whos = whos('global');
  for k = numel(base_whos):-1:1
    global_var_match = 0;
    for kg = 1:numel(global_whos)
      if strcmp( base_whos(k).name, global_whos(kg).name )
        global_var_match = 1;
      end
    end
    if global_var_match
      base_whos(k) = [];
    else
      base_whos(k).global = 0;
    end
  end
  for k = 1:numel(global_whos)
    global_whos(k).global = 1;
  end
  all_whos = [ base_whos; global_whos ];
  
  for k = numel(all_whos):-1:1
    if ~ismember( all_whos(k).class, {'struct','ss','tf','zpk','frd'} ) ...
      || isequal( all_whos(k).name,'all_whos') ...
      || isequal( all_whos(k).name,'PZG') ...
      || isequal( all_whos(k).name,'pzg_drawbox')
      all_whos(k) = [];
      continue
    end
    if all_whos(k).global
      eval(['global ' all_whos(k).name ])
      eval(['this_var = ' all_whos(k).name ';'])
    else
      evalin('base', ['assignin(''caller'',''this_var'',' all_whos(k).name ');'] )
    end
    if isequal( all_whos(k).class,'struct')
      [ this_var_lti, error_str ] = local_struct2lti( this_var );
      if isempty(error_str)
        this_var = this_var_lti;
        all_whos(k).ts = this_var.ts;
      else
        all_whos(k) = [];
        continue
      end
    else
      all_whos(k).ts = this_var.ts;
    end
    all_whos(k).model_size = local_get_model_order( this_var );
  end
  if isempty( all_whos )
    errdlg_h = ...
      errordlg({'Cannot find any variable that could be loaded into PZGUI.'; ...
                ' ';'    Click "OK" to continue ...';' '}, ...
               'No "Loadable" Variable Found','modal');
    uiwait(errdlg_h)
    return
  else
    % Construct the listbox strings.
    listbox_str = cell( size(all_whos) );
    name_cell = cell(size(listbox_str));
    for k = 1:numel(name_cell)
      name_cell{k} = all_whos(k).name;
    end
    name_str = char(name_cell);
    [ name_str, sortndx ] = sortrows( lower(name_str) ); %#ok<ASGLU>
    all_whos = all_whos(sortndx);
    
    for k = 1:numel(listbox_str)
      listbox_str{k} = [' ' all_whos(k).name '   '];
      if isfield( all_whos(k),'model_size') ...
        && ~isempty(all_whos(k).model_size)
        listbox_str{k} = [ listbox_str{k} ' (' ];
        if all_whos(k).model_size(1) >= 0
          listbox_str{k} = [ listbox_str{k} ...
            'order=' num2str(all_whos(k).model_size(1)) ', '];
        end
        listbox_str{k} = [ listbox_str{k} ...
          '#out=' num2str(all_whos(k).model_size(2)) ', '];
        listbox_str{k} = [ listbox_str{k} ...
          '#in=' num2str(all_whos(k).model_size(3)) ') '];
      end
      listbox_str{k} = ...
        [ listbox_str{k} ' (class=''' all_whos(k).class ''')'];
      % Determine if it's C-T or D-T.
      if all_whos(k).ts
        listbox_str{k} = [ listbox_str{k} '  (discrete-time)'];
      else
        listbox_str{k} = [ listbox_str{k} '  (continuous-time)'];
      end
      if all_whos(k).global
        listbox_str{k} = [ listbox_str{k} ' (global)'];
      end
    end
  end
  listbox_str = [ {''}; listbox_str ];
  all_whos = [ all_whos(1); all_whos ];
  
  v_size = min( 0.5, 0.1+0.05*numel(listbox_str) );
  
  varfig_h = ...
    figure('units','normalized', ...
           'position',[0.15 0.3 0.5 v_size], ...
           'name','Select a Variable to Load', ...
           'menubar','none', ...
           'numbertitle','off', ...
           'integerhandle','off', ...
           'handlevisibility','callback');
  
  uicontrol( varfig_h, ...
    'style','text', ...
    'units','normalized', ...
    'position',[0.001 0.851 0.998 0.149], ...
    'fontsize', 14, ...
    'fontweight','bold', ...
    'string','Select a Variable to Load');

  uicontrol( varfig_h, ...
    'style','listbox', ...
    'parent', varfig_h, ...
    'units','normalized', ...
    'position',[0.001 0.17 0.998 0.679], ...
    'horizontalalignment','left', ...
    'value', 1, ...
    'string', listbox_str, ...
    'fontsize', 12, ...
    'fontweight','bold', ...
    'userdata', all_whos, ...
    'tag','loadvar listbox', ...
    'callback', ...
      ['global varname_selection,' ...
       'temp_ok_h=findobj(gcbf,''string'',''Load Selection'');' ...
       'if isempty(get(gcbo,''value''))||(get(gcbo,''value'')<2),' ...
         'set(temp_ok_h,''visible'',''off'');' ...
       'else,' ...
         'set(temp_ok_h,''visible'',''on'');' ...
         'if strcmpi(get(gcbf,''selectiontype''),''open''),' ...
           'temp_allwhos=get(gcbo,''userdata'');' ...
           'varname_selection=temp_allwhos(get(gcbo,''value'')).name;' ...
           'close(gcbf),' ...
           'drawnow,' ...
         'end,' ...
       'end,' ...
       'clear temp_ok_h temp_val temp_allwhos varname_selection'] );
   
  uicontrol( varfig_h, ...
    'style','pushbutton', ...
    'units','normalized', ...
    'position',[0.05 0.03 0.40 0.10], ...
    'horizontalalignment','center', ...
    'string','Load Selection', ...
    'fontsize', 12, ...
    'fontweight','bold', ...
    'visible','off', ...
    'tag','loadvar load pushbutton', ...
    'callback', ...
      ['global varname_selection,' ...
       'temp_list_h=findobj(gcbf,''style'',''listbox'');' ...
       'temp_allwhos=get(temp_list_h,''userdata'');' ...
       'temp_listval=get(temp_list_h,''value'');' ...
       'if temp_listval>1,' ...
         'varname_selection=temp_allwhos(temp_listval).name;' ...
       'end,' ...
       'close(gcbf),', ...
       'drawnow,' ...
       'clear temp_allwhos varname_selection temp_list_h temp_listval']);
  
  uicontrol( varfig_h, ...
    'style','pushbutton', ...
    'units','normalized', ...
    'position',[0.55 0.03 0.40 0.10], ...
    'horizontalalignment','center', ...
    'string','Cancel', ...
    'fontsize', 12, ...
    'fontweight','bold', ...
    'tag','loadvar cancel pushbutton', ...
    'callback', ...
      ['global varname_selection,' ...
       'varname_selection='''';' ...
       'clear varname_selection,' ...
       'close(gcbf)']);
  
  uiwait(varfig_h)
  
  if ischar(varname_selection)
    varname_from_list = varname_selection;
  end
  
  clear global varname_selection
  
return

function [ out_nr, in_nr, cancel ] = local_get_io_nrs( p, m, Ts )

  global pzg_io_selection
  pzg_io_selection = [];
  
  if ( nargin < 3 ) || ~isreal(Ts) || ~isequal( 1, numel(Ts) )
    Ts = 0;
  end
  
  % # outputs = p,  # inputs = m.
  out_nr = 1;
  in_nr = 1;
  cancel = 0;
  
  in_str = cellstr( num2str( (1:max(1,m))') );
  out_str = cellstr( num2str( (1:max(1,p))') );
  
  if ( m < 2 ) && ( p < 2 )
    return
  end
  
  if Ts == 0
    name_str = 'Select SISO Path from MIMO Continuous-Time Model';
  else
    name_str = 'Select SISO Path from MIMO Discrete-Time Model';
  end
  
  iofig_h = ...
    figure('units','normalized', ...
           'position',[0.15 0.4 0.3 0.15], ...
           'name', name_str, ...
           'menubar','none', ...
           'numbertitle','off', ...
           'integerhandle','off', ...
           'handlevisibility','callback');
  
  if m < 2
    ui_text = 'Input Number';
    ui_style = 'text';
  else
    ui_text = 'Select an Input Number';
    ui_style = 'popupmenu';
  end
  uicontrol( iofig_h, ...
    'style','text', ...
    'units','normalized', ...
    'position',[0.02 0.62 0.46 0.28], ...
    'fontsize', 14, ...
    'fontweight','bold', ...
    'string', ui_text );
  uicontrol( iofig_h, ...
    'style', ui_style, ...
    'units','normalized', ...
    'position',[0.02 0.30 0.46 0.28], ...
    'horizontalalignment','center', ...
    'value', 1, ...
    'string', in_str, ...
    'fontsize', 12, ...
    'fontweight','bold', ...
    'tag','input nr select');
     
  if p < 2
    ui_text = 'Output Number';
    ui_style = 'text';
  else
    ui_text = 'Select an Output Number';
    ui_style = 'popupmenu';
  end
  uicontrol( iofig_h, ...
    'style','text', ...
    'units','normalized', ...
    'position',[0.52 0.62 0.46 0.28], ...
    'fontsize', 14, ...
    'fontweight','bold', ...
    'string', ui_text );
  
  uicontrol( iofig_h, ...
    'style', ui_style, ...
    'units','normalized', ...
    'position',[0.52 0.30 0.46 0.28], ...
    'horizontalalignment','center', ...
    'value', 1, ...
    'string', out_str, ...
    'fontsize', 12, ...
    'fontweight','bold', ...
    'tag','output nr select');
   
   
  uicontrol( iofig_h, ...
    'style','pushbutton', ...
    'units','normalized', ...
    'position',[0.45 0.03 0.10 0.25], ...
    'horizontalalignment','center', ...
    'string','OK', ...
    'fontsize', 12, ...
    'fontweight','bold', ...
    'visible','on', ...
    'tag','loadvar load pushbutton', ...
    'callback', ...
      ['global pzg_io_selection,' ...
       'temp_in_h=findobj(gcbf,''tag'',''input nr select'');' ...
       'if isequal(get(temp_in_h,''style''),''text''),' ...
         'temp_in_nr=1;' ...
       'else,' ...
         'temp_in_nr=get(temp_in_h,''value'');' ...
         'if iscell(temp_in_nr),' ...
           'temp_in_nr=temp_in_nr{1};' ...
         'end,' ...
       'end,' ...
       'temp_out_h=findobj(gcbf,''tag'',''output nr select'');' ...
       'if isequal(get(temp_out_h,''style''),''text''),' ...
         'temp_out_nr=1;' ...
       'else,' ...
         'temp_out_nr=get(temp_out_h,''value'');' ...
         'if iscell(temp_out_nr),' ...
           'temp_out_nr=temp_out_nr{1};' ...
         'end,' ...
       'end,' ...
       'pzg_io_selection=[temp_out_nr(1),temp_in_nr(1)];' ...
       'close(gcbf),', ...
       'drawnow;' ...
       'clear temp_out_h temp_in_h temp_out_nr temp_in_nr pzg_io_selection']);
  
  uicontrol( iofig_h, ...
    'style','pushbutton', ...
    'units','normalized', ...
    'position',[0.75 0.03 0.15 0.25], ...
    'horizontalalignment','center', ...
    'string','Cancel', ...
    'fontsize', 12, ...
    'fontweight','bold', ...
    'tag','loadvar cancel pushbutton', ...
    'callback', ...
      ['global pzg_io_selection,' ...
       'pzg_io_selection=[];' ...
       'clear pzg_io_selection,' ...
       'close(gcbf)']);
  
  uiwait(iofig_h)

  if ~isequal( numel(pzg_io_selection), 2 ) || ~isreal(pzg_io_selection)
    cancel = 1;
    return
  end
  out_nr = pzg_io_selection(1);
  in_nr = pzg_io_selection(2);
  
  return

function total_delay = ...
           local_get_delay( load_mdl, nr_in, nr_out, in_nr, out_nr )

  total_delay = 0;
  
  if isfield( load_mdl,'delay')
    if numel(load_mdl.delay) == 1
      total_delay = total_delay + load_mdl.delay;
    elseif isequal( size(load_mdl.delay), [nr_out,nr_in] )
      total_delay = ...
        total_delay + load_mdl.delay(out_nr,in_nr);
    end
  end
  if isfield( load_mdl,'puredelay')
    if numel(load_mdl.puredelay) == 1
      total_delay = total_delay + load_mdl.puredelay;
    elseif isequal( size(load_mdl.puredelay), [nr_out,nr_in] )
      total_delay = ...
        total_delay + load_mdl.puredelay(out_nr,in_nr);
    end
  end
  if isfield( load_mdl,'ioDelay') || isa( load_mdl,'lti')
    if numel(load_mdl.ioDelay) == 1
      total_delay = total_delay + load_mdl.ioDelay;
    elseif isequal( size(load_mdl.ioDelay), [nr_out,nr_in] )
      total_delay = ...
        total_delay + load_mdl.ioDelay(out_nr,in_nr);
    end
  end
  if isfield( load_mdl,'InputDelay') || isa( load_mdl,'lti')
    if numel(load_mdl.InputDelay) == 1
      total_delay = total_delay + load_mdl.InputDelay;
    elseif isequal( numel(load_mdl.InputDelay), nr_in )
      total_delay = ...
        total_delay + load_mdl.InputDelay(in_nr);
    end
  end
  if isfield( load_mdl,'OutputDelay') || isa( load_mdl,'lti')
    if numel(load_mdl.OutputDelay) == 1
      total_delay = total_delay + load_mdl.OutputDelay;
    elseif isequal( numel(load_mdl.OutputDelay), nr_out )
      total_delay = ...
        total_delay + load_mdl.OutputDelay(out_nr);
    end
  end

return

function  [ mdl_lti, error_str ] = local_struct2lti( mdl_struct )

  mdl_lti = ss;
  error_str = '';
  
  if isa( mdl_struct,'lti')
    mdl_lti = mdl_struct;
  elseif ~isa( mdl_struct,'struct')
    error_str = 'Error:  Input arg must be a structure variable.';
    return
  elseif isfield( mdl_struct,'ZeroLocs') ...
    || isfield( mdl_struct,'PoleLocs') ...
    || isfield( mdl_struct,'cntr_data')
    error_str = 'Error:  Input arg is a pzgui struture, not to be imported.';
    return
  end
  
  mdl_fn = fieldnames( mdl_struct );
  mdl_fn_lc = lower(mdl_fn);
  
  % Extract sample period, ts.  Default value is zero.
  ts = 0;
  ts_ndx = find( strcmpi('ts', mdl_fn_lc) );
  if isempty(ts_ndx)
    ts_ndx = find( strcmpi('t', mdl_fn_lc) );
  end
  if ~isempty(ts_ndx)
    ts_ndx = ts_ndx(1);
    ts_spec = mdl_struct.(mdl_fn{ts_ndx});
    if isreal(ts_spec) && ( numel(ts_spec) == 1 )
      if ts_spec < 0
        ts = 1;
      elseif ts_spec > 0
        ts = ts_spec;
      end
    end
  end
  
  % Extract delays.  Default value is zero.
  iodelay = 0;
  delay_ndx = find( strcmpi('delay',mdl_fn_lc) );
  if ~isempty(delay_ndx)
    iodelay = mdl_struct.(mdl_fn{delay_ndx});
    if ~isnumeric(iodelay) || isempty(iodelay)
      iodelay = 0;
    end
  end
  iodelay_ndx = find( strcmpi('iodelay',mdl_fn_lc) );
  if ~isempty(iodelay_ndx)
    more_delay = mdl_struct.(mdl_fn{iodelay_ndx});
    if isnumeric(more_delay) && ~isempty(more_delay)
      iodelay = iodelay + more_delay;
    end
  end
  
  inputdelay = 0;
  inputdelay_ndx = find( strcmpi('inputdelay',mdl_fn_lc) );
  if ~isempty(inputdelay_ndx)
    inputdelay = mdl_struct.(mdl_fn{inputdelay_ndx});
    if ~isnumeric(inputdelay) || isempty(inputdelay)
      inputdelay = 0;
    end
  end
  
  outputdelay = 0;
  outputdelay_ndx = find( strcmpi('outputdelay',mdl_fn_lc) );
  if ~isempty(outputdelay_ndx)
    outputdelay = mdl_struct.(mdl_fn{outputdelay_ndx});
    if ~isnumeric(outputdelay) || isempty(outputdelay)
      outputdelay = 0;
    end
  end
  
  % Identify fields needed for LTI objects.
  % For SS-object.
  a_ndx = find( strcmpi('a',mdl_fn_lc) );
  b_ndx = find( strcmpi('b',mdl_fn_lc) );
  c_ndx = find( strcmpi('c',mdl_fn_lc) );
  d_ndx = find( strcmpi('d',mdl_fn_lc) );
  % For ZPK-object.
  z_ndx = [ find( strcmpi('z',mdl_fn_lc) ); ...
            find( strcmpi('zz',mdl_fn_lc) ); ...
            find( strcmpi('zero',mdl_fn_lc) ); ...
            find( strcmpi('zeros',mdl_fn_lc) ) ];
  p_ndx = [ find( strcmpi('p',mdl_fn_lc) ); ...
            find( strcmpi('pp',mdl_fn_lc) ); ...
            find( strcmpi('pole',mdl_fn_lc) ); ...
            find( strcmpi('poles',mdl_fn_lc) ) ];
  k_ndx = [ find( strcmpi('k',mdl_fn_lc) ); ...
            find( strcmpi('kk',mdl_fn_lc) ); ...
            find( strcmpi('gain',mdl_fn_lc) ); ...
            find( strcmpi('gains',mdl_fn_lc) ) ];
  % For TF-object.
  num_ndx = [ find( strcmpi('n',mdl_fn_lc) ); ...
              find( strcmpi('num',mdl_fn_lc) ); ...
              find( strcmpi('numer',mdl_fn_lc) ); ...
              find( strcmpi('numerator',mdl_fn_lc) ) ];
  den_ndx = [ find( strcmpi('d',mdl_fn_lc) ); ...
              find( strcmpi('den',mdl_fn_lc) ); ...
              find( strcmpi('denom',mdl_fn_lc) ); ...
              find( strcmpi('denominator',mdl_fn_lc) ) ];
  % For FRD-object.
  freq_ndx = [ find( strcmpi('freq',mdl_fn_lc) ); ...
               find( strcmpi('frequency',mdl_fn_lc) ); ...
               find( strcmpi('freq_radsec',mdl_fn_lc) ); ...
               find( strcmpi('freqs_radsec',mdl_fn_lc) ); ...
               find( strcmpi('freq_hertz',mdl_fn_lc) ); ...
               find( strcmpi('freqs_hertz',mdl_fn_lc) ); ...
               find( strcmpi('frequencies',mdl_fn_lc) ) ];
  resp_ndx = [ find( strcmpi('resp',mdl_fn_lc) ); ...
               find( strcmpi('response',mdl_fn_lc) ); ...
               find( strcmpi('frf',mdl_fn_lc) ); ...
               find( strcmpi('frfdata',mdl_fn_lc) ); ...
               find( strcmpi('responsedata',mdl_fn_lc) ); ...
               find( strcmpi('data',mdl_fn_lc) ) ];
  units_ndx = [ find( strcmpi('units',mdl_fn_lc) ); ...
                find( strcmpi('freq_units',mdl_fn_lc) ); ...
                find( strcmpi('frequnits',mdl_fn_lc) ); ...
                find( strcmpi('frequency_units',mdl_fn_lc) ); ...
                find( strcmpi('frequencyunits',mdl_fn_lc) ) ];
  
  if ( numel(a_ndx) == 1 ) && ( numel(b_ndx) == 1 ) ...
    && ( numel(c_ndx) == 1 ) && ( numel(d_ndx) == 1 )
    % State-space model.
    a = mdl_struct.(mdl_fn{a_ndx});
    b = mdl_struct.(mdl_fn{b_ndx});
    c = mdl_struct.(mdl_fn{c_ndx});
    d = mdl_struct.(mdl_fn{d_ndx});
    if ~isnumeric(a) || ~isnumeric(b) || ~isnumeric(c) || ~isnumeric(d) ...
      ||~isequal(2,ndims(a)) || ~isequal(2,ndims(b)) ...
      ||~isequal(2,ndims(c)) || ~isequal(2,ndims(d))
      error_str = 'Could not parse model a/b/c/d for ss-object.';
      return
    elseif ( size(a,1) ~= size(a,2) ) ...
          ||( size(a,2) ~= size(c,2) ) ...
          ||( size(a,1) ~= size(b,1) ) ...
          ||( (numel(d)~=1) ...
             &&( ( size(d,1) ~= size(c,1) ) ...
                ||( size(d,2) ~= size(b,2) ) ) )
      error_str = 'Fields a/b/c/d are not conformable for ss-object.';
      return
    end
    nr_out = size(c,1);
    nr_in = size(b,2);
    if ~isequal( size(d), [nr_out nr_in] )
      error_str = 'Could not parse model a/b/c/d for ss-object (D-matrix)';
      return
    end
    mdl_lti = ss( a, b, c, d, ts );
    
    
  elseif ( numel(z_ndx) == 1 ) && ( numel(p_ndx) == 1 ) ...
       && ( numel(k_ndx) == 1 )
    % Zero/pole/gain model.
    Z = mdl_struct.(mdl_fn{z_ndx});
    P = mdl_struct.(mdl_fn{p_ndx});
    K = mdl_struct.(mdl_fn{k_ndx});
    % Make sure Z is cell-array, same size as K.
    if ~isnumeric(K) || ~isequal( ndims(K), 2 )
      error_str = 'Could not parse model gain "K" for Z/P/K object.';
      return
    end
    if isempty(Z)
      Z = [];
    elseif iscell(Z)
      if ~isequal( size(Z), size(K) )
        if numel(Z) == numel(K)
          % Assume K has the correct shape.
          Z = reshape( Z, size(K,1), size(K,2) );
        else
          error_str = 'Could not parse model zeros "Z" for Z/P/K object.';
          return
        end
      end
    elseif isnumeric(Z)
      if ~isempty(Z) ...
        && ( ( size(Z,2) ~= numel(K) ) || ( min(size(K)) > 1 ) )
        error_str = 'Could not parse model zeros for Z/P/K object.';
        return
      end
      newZ = cell(size(K));
      for m = 1:numel(newZ)
        newZ{m} = Z(:,m);
      end
      Z = newZ;
    else
      error_str = 'Could not parse model zeros for Z/P/K object.';
      return
    end
    if iscell(P)
      if numel(P) == 1
        P = P{1};
      end
    end
    % Check that the number of zeros along each path
    % doesn't exceed the number of poles.
    for m1 = 1:size(Z,1)
      for m2 = 1:size(Z,2)
        if iscell(P) && ( numel(P) > 1 )
          thisP = P{m1,m2};
        elseif iscell(P)
          thisP = P{1};
        else
          thisP = P;
        end
        if ~isnumeric(thisP) ...
          ||( min(size(thisP)) ~= 1 ) ...
          ||( ndims(thisP) > 2 ) 
          error_str = 'ZPK conversion:  Invalid vector of poles P.';
          return
        elseif ~isnumeric(Z{m1,m2}) ...
          ||( min(size(Z{m1,m2})) ~= 1 ) ...
          ||( ndims(Z{m1,m2}) > 2 ) %#ok<*ISMAT>
          error_str = ['ZPK conversion:  Invalid zeros in Z(' ...
                       num2str(m1) ',' num2str(m2) ').'];
          return
        elseif numel(Z{m1,m2}) > numel(P)
          error_str = ['ZPK conversion:  Model H(' ...
                       num2str(m1) ',' num2str(m2) ') is not proper.'];
          return
        end
      end
    end
    nr_out = size(K,1);    
    nr_in = size(K,2);
    mdl_lti = zpk( Z, P, K, ts );
    
    
  elseif ( numel(num_ndx) == 1 ) && ( numel(den_ndx) == 1 )
    % Transfer-function model.
    num = mdl_struct.(mdl_fn{num_ndx});
    den = mdl_struct.(mdl_fn{den_ndx});
    if iscell(num) && iscell(den)
      if ( numel(den) ~= 1 ) && ~isequal( size(den), size(num) )
        error_str = 'Fields NUM and DEN are not conformable for tf-object.';
        return
      end
    elseif ~isnumeric(num) && ~isnumeric(den)
      error_str = 'Fields NUM and DEN cannot be converted to tf-object.';
      return
    end
    if isnumeric(num)
      % Convert numerator to cell-array.
      if min(size(num)) == 1
        num = { num(:).' };
      else
        % Assume rows are polynomial coefficients.
        newNum = cell( size(num,1), 1 );
        for m = 1:numel(newNum)
          newNum{m} = num(m,:);
        end
        num = newNum;
      end
    end
    if isnumeric(den)
      % Convert numerator to cell-array.
      if min(size(den)) == 1
        den = { den(:).' };
      else
        % Assume rows are polynomial coefficients.
        newDen = cell( size(den,1), 1 );
        for m = 1:numel(newDen)
          newDen{m} = den(m,:);
        end
        den = newDen;
      end
    end
    
    % Check that order of numerator polynomial
    % doesn't exceed order of denominator polynomial.
    if isempty(num)
      num = [];
    end
    for m1 = 1:size(num,1)
      for m2 = 1:size(num,2)
        if iscell(den) && ( numel(den) > 1 )
          this_den = den{m1,m2};
        elseif iscell(den)
          this_den = den{1};
        else
          this_den = den;
        end
        if ~isreal(this_den) ...
          ||( min(size(this_den)) ~= 1 ) ...
          ||( ndims(this_den) > 2 )
          error_str = 'TF conversion:  Invalid denominator.';
          return
        elseif ~isreal(num{m1,m2}) ...
          ||( min(size(num{m1,m2})) ~= 1 ) ...
          ||( ndims(num{m1,m2}) > 2 )
          error_str = ['TF conversion:  Invalid numerator N(' ...
                       num2str(m1) ',' num2str(m2) ').'];
          return
        elseif ( numel(num{m1,m2}) > numel(this_den) )
          error_str = ['TF conversion:  Model H(' ...
                       num2str(m1) ',' num2str(m2) ') is not proper.'];
          return
        end
      end
    end
    nr_out = size(num,1);
    nr_in = size(num,2);
    % Factor in gain, if it is given separately.
    if ( numel(num) == 1 ) && iscell(num) ...
      &&( num{1}(1) == 1 ) && ~isempty(k_ndx)
      Gain = mdl_struct.(mdl_fn{k_ndx});
      if isreal(Gain) && ( numel(Gain) == 1 )
        num{1} = Gain * num{1};
      end
    end
    mdl_lti = tf( num, den, ts );
    
    
  elseif ( numel(freq_ndx) == 1 ) && ( numel(resp_ndx) == 1 )
    resp = mdl_struct.(mdl_fn{resp_ndx});
    freq = mdl_struct.(mdl_fn{freq_ndx});
    if ( ~isnumeric(resp) || ~isnumeric(freq) ) ...
      || ( min(size(freq)) > 1 ) ...
      || ( ndims(resp) > 3 ) ...
      || ~any( numel(freq) == size(resp) )
      error_str = 'Could not parse data for FRD object.';
      return
    end
    freq = freq(:);
    if ndims(resp) == 2
      if ( size(resp,2) == numel(freq) ) ...
        &&( size(resp,1) ~= numel(freq) )
        resp = resp.';
      end
      newResp = zeros(size(resp,2),1,numel(freq));
      for m = 1:size(resp,1)
        newResp(m,1,:) = reshape( resp(:,m),1,1,numel(freq) );
      end
      resp = newResp;
    else
      freq_dim = ( size(resp) == numel(freq) );
      if freq_dim(1)
        resp = shiftdim( resp, 1 );
      elseif freq_dim(2)
        resp = shiftdim( resp, 2 );
      end
    end
    
    % PZGUI assumed units for frequency vector:  radians/second
    for m = 1:numel(units_ndx)
      this_units = mdl_struct.(mdl_fn{units_ndx(m)});
      if ischar( this_units ) ...
        &&( ~isempty( strfind( lower(this_units),'hz') ) ...
           ||~isempty( strfind( lower(this_units),'hertz') ) )
        freq = freq * 2*pi;
      end
    end
    nr_out = size(resp,1);
    nr_in = size(resp,2);
    mdl_lti = frd( resp, freq, ts );
    
  else
    error_str = 'Could not parse the variable into an LTI object.';
    return
  end
  
  % Transplant the delay information.
  if any(iodelay)
    if ( numel(iodelay) == 1 ) ...
      ||( ( size(iodelay,1) == nr_out ) && ( size(iodelay,2) == nr_in ) )
      if ( mdl_lti.ts > 0 ) && ~isequal( iodelay, round(iodelay) )
        % D-T delay must be an integer number (of sample periods).
        iodelay = round( iodelay / mdl_lti.ts );
      end
      mdl_lti.iodelay = iodelay;
    end
  end
  if any(inputdelay)
    if ( numel(inputdelay) == 1 ) || ( numel(inputdelay) == nr_in )
      if ( mdl_lti.ts > 0 ) && ~isequal( iodelay, round(inputdelay) )
        % D-T delay must be an integer number (of sample periods).
        inputdelay = round( inputdelay / mdl_lti.ts );
      end
      mdl_lti.inputdelay = inputdelay;
    end
  end
  if any(outputdelay)
    if ( numel(outputdelay) == 1 ) || ( numel(outputdelay) == nr_out )
      if ( mdl_lti.ts > 0 ) && ~isequal( iodelay, round(outputdelay) )
        % D-T delay must be an integer number (of sample periods).
        outputdelay = round( outputdelay / mdl_lti.ts );
      end
      mdl_lti.outputdelay = outputdelay(:);
    end
  end

return

function ss_mdl = local_zp2block( Z, P, K, ts ) %#ok<DEFNU>

ss_mdl = ss;

if nargin < 4
  ts = 0;
end

if ~isnumeric(Z) || ~isnumeric(P) || ~isnumeric(K) ...
  || ~isequal( 1, numel(K) )
  return
elseif ( ndims(Z) > 2 ) || ( ndims(P) > 2 ) || ( ndims(K) > 2 )
  return
elseif numel(P) < numel(Z)
  return
end

if ~isempty(Z)
  Z = Z(:);
end
if ~isempty(P)
  P = P(:);
end
K = K(1);

common_pz = intersect(P,Z);
for k = 1:numel(common_pz)
  p_ndx = find( P == common_pz(k) );
  P(p_ndx(1)) = [];
  z_ndx = find( Z == common_pz(k) );
  Z(z_ndx(1)) = [];
end

zeropole_ss = ss(1);
lone_cplx_z = [];
zero_pole_ndxs = find( abs(P) < 1e-14 );
nr_zero_poles = numel(zero_pole_ndxs);
zeropole_companions = [];
if nr_zero_poles > 1
  if ( numel(P) == numel(Z) )
    nr_companions = nr_zero_poles;
  else
    nr_companions = nr_zero_poles - 1;
  end
  cplx_z_ndx = find( imag(Z) > 0 );
  while ( numel(zeropole_companions) < ( nr_companions - 1 ) ) ...
       && ~isempty(cplx_z_ndx)
    zeropole_companions = ...
      [ zeropole_companions;  ...
        Z(cplx_z_ndx(1)); conj(Z(cplx_z_ndx(1))) ]; %#ok<AGROW>
    cplx_z_ndx(1) = [];
  end
  real_z_ndx = find( imag(Z) == 0 );
  while ( numel(zeropole_companions) < nr_companions ) ...
       && ~isempty(real_z_ndx)
    zeropole_companions = ...
      [ zeropole_companions; Z(real_z_ndx(1)) ]; %#ok<AGROW>
    real_z_ndx(1) = [];
  end
  if ( numel(zeropole_companions) < nr_companions ) ...
    && ~isempty(cplx_z_ndx)
    zeropole_companions = ...
      [ zeropole_companions; Z(cplx_z_ndx(1)) ];
    lone_cplx_z = conj(Z(cplx_z_ndx(1)));
  end
  for k = 1:numel(zeropole_companions)
    [ temp, min_ndx ] = ...
       min( abs( Z - zeropole_companions(k) ) ); %#ok<ASGLU>
    Z(min_ndx) = [];
  end
  P(zero_pole_ndxs) = [];
  % Denom order = index
  zeropole_res = poly(zeropole_companions);
  while numel(zeropole_res) < ( nr_zero_poles + 1 )
    zeropole_res = [ 0, zeropole_res ]; %#ok<AGROW>
  end
  Azp = diag( ones(1,nr_zero_poles-1), 1 );
  Bzp = zeros( nr_zero_poles, 1 );
  Bzp(end) = 1;
  Czp = fliplr(zeropole_res(2:end));
  Dzp = zeropole_res(1);
  zeropole_ss = ss( Azp, Bzp, Czp, Dzp, ts );
end

unitypole_ss = ss(1);
unity_pole_ndxs = find( abs(1-P) < 1e-14 );
nr_unity_poles = numel(unity_pole_ndxs);
unitypole_companions = [];
if nr_unity_poles > 1
  if ( numel(P) == numel(Z) )
    nr_companions = nr_unity_poles;
  else
    nr_companions = nr_unity_poles - 1;
  end
  cplx_z_ndx = find( imag(Z) > 0 );
  while ( numel(unitypole_companions) < ( nr_companions - 1 ) ) ...
       && ~isempty(cplx_z_ndx)
    unitypole_companions = ...
      [ unitypole_companions;  ...
        Z(cplx_z_ndx(1)); conj(Z(cplx_z_ndx(1))) ]; %#ok<AGROW>
    cplx_z_ndx(1) = [];
  end
  real_z_ndx = find( imag(Z) == 0 );
  while ( numel(unitypole_companions) < nr_companions ) ...
       && ~isempty(real_z_ndx)
    unitypole_companions = ...
      [ unitypole_companions; Z(real_z_ndx(1)) ]; %#ok<AGROW>
    real_z_ndx(1) = [];
  end
  if ( numel(unitypole_companions) < nr_companions ) ...
    && ~isempty(cplx_z_ndx)
    if isempty(lone_cplx_z)
      unitypole_companions = ...
        [ unitypole_companions; Z(cplx_z_ndx(1)) ];
    else
      unitypole_companions = ...
        [ unitypole_companions; lone_cplx_z ];
    end
  end
  for k = 1:numel(unitypole_companions)
    [ temp, min_ndx ] = ...
       min( abs( Z - unitypole_companions(k) ) ); %#ok<ASGLU>
    Z(min_ndx) = [];
  end
  P(unity_pole_ndxs) = [];
  % Denom order = index
  if isempty(unitypole_companions)
    unitypole_res = 1;
  else
    unitypole_res = poly( unitypole_companions - 1 );
  end
  while numel(unitypole_res) < ( nr_unity_poles + 1 )
    unitypole_res = [ 0, unitypole_res ]; %#ok<AGROW>
  end
  Aup = eye(nr_unity_poles);
  Aup = Aup + diag( ones(1,nr_unity_poles-1), 1 );
  Bup = zeros( nr_unity_poles, 1 );
  Bup(end) = 1;
  Cup = fliplr(unitypole_res(2:end));
  Dup = unitypole_res(1);
  if ts > 0
    for ki = 2:nr_unity_poles
      Bup(ki:end) = Bup(ki:end) / ts;
      Cup(ki:end) = Cup(ki:end) * ts;
      Aup(ki-1,ki) = ts;
    end
  end
  unitypole_ss = ss( Aup, Bup, Cup, Dup, ts );
end

if isempty(P)
  middle_ss = ss(K);
  
elseif ~isequal( numel(unique(P)), numel(P) ) ...
      || ( numel(P) == 1 )
  [ res, poles, direct ] = residue( K*poly(Z), poly(P) );
  % !!!!!  CONSTRUCT "middle_ss" FOR THIS CASE  !!!!!
  a = diag(poles);
  b = res(:);
  c = ones(1,numel(poles));
  d = direct;
  blocks = {};
  for k = 1:numel(poles)-1
    if ( abs( poles(k) - poles(k+1) ) < 1e-14 ) ...
      && isequal( sign(imag(poles(k))), sign(imag(poles(k+1))) )
      a(k,k+1) = 1;
      if ( k == 1 ) || isempty(blocks) ...
        || (  abs( poles(k) - poles(k-1) ) > 1e-14 )
        blocks{end+1}.ndx = [ k, k+1 ];                %#ok<AGROW>
        blocks{end}.p = poles(k);
      else
        blocks{end}.ndx = [ blocks{end}.ndx, k+1 ];
      end
    end
  end
  for k = 1:numel(blocks)
    if ( k < numel(blocks) ) ...
      && ~isreal( blocks{k}.p ) ...
      && isequal( blocks{k}.p, conj(blocks{k+1}.p) )
      % If a non-real-valued pole is repeated, re-order the states.
      shuffle_ndxs = [ blocks{k}.ndx; blocks{k+1}.ndx ];
      shuffle_ndxs = shuffle_ndxs(:);
      block_ndxs = sort(shuffle_ndxs);
      a(block_ndxs,block_ndxs) = a(shuffle_ndxs,shuffle_ndxs);
      b(block_ndxs) = b(shuffle_ndxs);
      c(block_ndxs) = c(shuffle_ndxs);
    end
  end
  T2x2 = [ (1-1i)/2 (1+1i)/2; (1+1i)/2 (1-1i)/2 ];
  T = eye(size(a));
  tblock_ndxs = [];
  for k = 1:size(a,1)-1
    if ~isreal(a(k,k)) && ( abs( a(k,k)-conj(a(k+1,k+1)) ) < 1e-14 )
      if isempty(tblock_ndxs) ...
        || ( k > (tblock_ndxs(end)+1) )
        T(k:k+1,k:k+1) = T2x2;
        tblock_ndxs = [ tblock_ndxs; k ]; %#ok<AGROW>
      end
    end
  end
  a = real( T' * a * T );
  b = real( T' * b );
  c = real( c * T );
  middle_ss = ss( a, b, c, d, ts );
  
else
  direct = 0;
  if numel(P) == numel(Z)
    direct = K;
  end
  pimag_ndx = find( imag(P) > 0 );
  newP = [];
  for k = 1:numel(pimag_ndx)
    newP = [ newP; ...
             P(pimag_ndx(k)); ...
             conj(P(pimag_ndx(k))) ];   %#ok<AGROW>
  end
  newP = [ newP; P(imag(P)==0) ];
  P = newP;
  res = zeros(size(P));
  for k = 1:numel(P)
    this_pole = P(k);
    other_poles = P;
    other_poles(k) = [];
    res(k) = K * prod(this_pole-Z) / prod(this_pole-other_poles);
  end
  Amp = diag(P);
  Bmp = res;
  Cmp = ones(1,numel(P));
  T2x2 = [ (1-1i)/2 (1+1i)/2; (1+1i)/2 (1-1i)/2 ];
  T = eye(size(Amp));
  for k = 1:numel(pimag_ndx)
    ndx = 2*k-1;
    T(ndx:ndx+1,ndx:ndx+1) = T2x2;
  end
  Amp = real( T' * Amp * T );
  Bmp = real( T' * Bmp );
  Cmp = real( Cmp * T );
  if ~isempty(direct)
    Dmp = direct;
  else
    Dmp = 0;
  end
  middle_ss = ss( Amp, Bmp, Cmp, Dmp, ts );
end

ss_mdl = middle_ss * unitypole_ss * zeropole_ss;

return

function model_size = local_get_model_order( sys )
  model_size = [];
  if isstruct(sys)
    [ mdl_lti, error_str ] = local_struct2lti( sys );
    if ~isempty(error_str)
      return
    end
  elseif isa( sys,'lti')
    mdl_lti = sys;
  else
    mdl_lti = [];
  end
  if ~isempty(mdl_lti)
    if isa( mdl_lti,'ss')
      model_size = ...
        [ size(mdl_lti.a,1), size(mdl_lti.c,1), size(mdl_lti.b,2) ];
    elseif isa( mdl_lti,'tf')
      [num,den] = tfdata(mdl_lti);
      model_size = [ numel(den{1})-1, size(num,1) size(num,2) ];
    elseif isa( mdl_lti,'zpk')
      [zz,pp,kk] = zpkdata(mdl_lti);  %#ok<ASGLU>
      model_size = [ numel(pp{1}), size(zz,1), size(zz,2) ];
    elseif isa( mdl_lti,'frd')
      if ndims(mdl_lti.ResponseData) == 3
        model_size = ...
          [ -1, size(mdl_lti.ResponseData,1) size(mdl_lti.ResponseData,2) ];
      else
        model_size = [ -1, 1, 1 ];
      end
    end
  end

return

function save_undo_info(DomainNdx)

  global PZG

  M = DomainNdx;
  if ~isreal(M) || ~isequal(numel(M),1) ...
    || (M<1) || (M>2) || ~isequal(round(M),M)
    return
  end

  undo_info.PoleLocs = PZG(M).PoleLocs;
  undo_info.ZeroLocs = PZG(M).ZeroLocs;
  undo_info.Gain = PZG(M).Gain;
  undo_info.Ts = PZG(M).Ts;
  undo_info.PureDelay = PZG(M).PureDelay;
  if isfield(PZG(M),'DCgain')
    undo_info.DCgain = PZG(M).DCgain;
  else
    undo_info.DCgain = [];
  end

  if ~isfield(PZG,'undo_info') || ~iscell(PZG(M).undo_info)
    PZG(M).undo_info = {};
  end
  if isempty(PZG(M).undo_info) ...
    ||~isequal( PZG(M).undo_info{end}, undo_info )
    PZG(M).undo_info{end+1} = undo_info;
    rloc_h = pzg_fndo( M, 9+M,'fig_h');
    if ~isempty(rloc_h)
      gaintxt_h = pzg_fndo( M, 9+M,'rlocuspl_gain_text');
      set( gaintxt_h,'backgroundcolor',[0.9 0.9 0.9],'string','');
      gainmark_h = pzg_fndo( M, 9+M,'rlocuspl_gain_marker');
      set( gainmark_h,'visible','off');
    end
  end
  
return

function local_update_pid_ldlg(dom_ndx)
  curr_tools = pzg_tools(dom_ndx);
  if curr_tools(1)
    if dom_ndx == 1
      gainfilt('s-Domain Pure Gain Design GUI');
    else
      gainfilt('z-Domain Pure Gain Design GUI');
    end
  elseif curr_tools(2)
    if dom_ndx == 1
      gainfilt('s-Domain Lead Lag Design GUI');
    else
      gainfilt('z-Domain Lead Lag Design GUI');
    end
  elseif curr_tools(3)
    if dom_ndx == 1
      gainfilt('s-Domain PID Design GUI');
    else
      gainfilt('z-Domain PID Design GUI');
    end
  end
return

function local_refresh_all_plots(PZGndx)
  global PZG
  if ~nargin || isempty(PZGndx) || ~isnumeric(PZGndx) ...
    || isempty( intersect( PZGndx,[1;2]) )
    PZGndx = [1;2];
  end
  for kx = 1:numel(PZGndx)
    k = PZGndx(kx);
    if ~isfield( PZG(k),'plot_h') ...
      || iscell(PZG(k).plot_h) ...
      || isempty(PZG(k).plot_h)
      pzg_h = findobj(allchild(0),'name', PZG(k).PZGUIname );
      if ~isempty(pzg_h)
        freqserv('refresh_plot_h', pzg_h(1) );
      end
    end
    
    if isfield( PZG(k),'plot_h') ...
      && iscell(PZG(k).plot_h)
      for kc = 1:numel(PZG(k).plot_h)
        if ~isempty(PZG(k).plot_h{kc}) ...
          && isfield( PZG(k).plot_h{kc},'fig_h') ...
          && isequal( 1, ishandle(PZG(k).plot_h{kc}.fig_h) )
          if k == 1
            if PZG(1).recompute_frf
              PZG(1).recompute_frf = 0;
              pzg_cntr(1);
              pzg_bodex(1);
            end
            pzgui;
            updatepl;
          else
            if PZG(2).recompute_frf
              PZG(2).recompute_frf = 0;
              pzg_cntr(2);
              pzg_bodex(2);
            end
            dpzgui;
            dupdatep;
          end
          break
        end
      end
    end
  end
  pzg_grid;
return

function matched = local_matched_conj_pairs( vec )
  matched = 1;
  % Verify that all non-real-valued elements occur in complex-conj-pairs.
  if iscell(vec) && ~isempty(vec)
    vec = vec{1};
  end
  for k = 1:numel(vec)
    this_zero = vec(k);
    if abs(imag(vec(k))) > 1e-13*abs(vec(k))
      zrep = sum( abs(vec-this_zero) < 1e-13*abs(this_zero) );
      zconjrep = ...
        sum( abs(conj(vec)-this_zero) < 1e-13*abs(this_zero) );
      if ~isequal( zrep, zconjrep )
        matched = 0;
        return
      end
    end
  end
return
